RootNode(len children=15,parent=0,current_idx=0)

Registered Datatypes: 
int, float, double, char, short, long, unsigned, signed, void, bool, size_t, ssize_t, 
*, MUJOCO_MJMODEL_H_, mjPI, mjMAXVAL, mjMINMU, mjMINIMP, mjMAXIMP, mjMAXCONPAIR, 
mjMAXTREEDEPTH, mjNEQDATA, mjNDYN, mjNGAIN, mjNBIAS, mjNFLUID, mjNREF, mjNIMP, mjNSOLVER, 
mjNISLAND, mjtDisableBit, mjtEnableBit, mjtGeom, mjtTrn, mjtObj, 

	SingleCommentNode(parent=0,current_idx=1)// Copyright 2021 DeepMind Technologies Limited
	SingleCommentNode(parent=0,current_idx=2)//
	SingleCommentNode(parent=0,current_idx=3)// Licensed under the Apache License ,  Version 2.0 (the "License") ; 
	SingleCommentNode(parent=0,current_idx=4)// you may not use this file except in compliance with the License.
	SingleCommentNode(parent=0,current_idx=5)// You may obtain a copy of the License at
	SingleCommentNode(parent=0,current_idx=6)//
	SingleCommentNode(parent=0,current_idx=7)//     http://www.apache.org/licenses/LICENSE-2.0
	SingleCommentNode(parent=0,current_idx=8)//
	SingleCommentNode(parent=0,current_idx=9)// Unless required by applicable law or agreed to in writing ,  software
	SingleCommentNode(parent=0,current_idx=10)// distributed under the License is distributed on an "AS IS" BASIS , 
	SingleCommentNode(parent=0,current_idx=11)// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND ,  either express or implied.
	SingleCommentNode(parent=0,current_idx=12)// See the License for the specific language governing permissions and
	SingleCommentNode(parent=0,current_idx=13)// limitations under the License.
	WhitespaceNode(parent=0,n_lines=1,current_idx=14)
	MacroIfNDefNode(parent=0,current_idx=15)#ifndef MUJOCO_MJMODEL_H_
		MacroDefineNode(parent=15,current_idx=16)#define MUJOCO_MJMODEL_H_ 
		IncludeNode(parent=15,current_idx=17)#include <stddef.h>
		IncludeNode(parent=15,current_idx=18)#include <stdint.h>
		WhitespaceNode(parent=15,n_lines=2,current_idx=19) 
		IncludeNode(parent=15,current_idx=20)#include <mujoco/mjtnum.h>
		WhitespaceNode(parent=15,n_lines=1,current_idx=21)
		SingleCommentNode(parent=15,current_idx=22)// global constants
		MacroDefineNode(parent=15,current_idx=23)#define mjPI            3.14159265358979323846
		MacroDefineNode(parent=15,current_idx=24)#define mjMAXVAL        1E+10    
		SingleCommentNode(parent=15,current_idx=25)// maximum value in qpos ,  qvel ,  qacc
		MacroDefineNode(parent=15,current_idx=26)#define mjMINMU         1E-5     
		SingleCommentNode(parent=15,current_idx=27)// minimum friction coefficient
		MacroDefineNode(parent=15,current_idx=28)#define mjMINIMP        0.0001   
		SingleCommentNode(parent=15,current_idx=29)// minimum constraint impedance
		MacroDefineNode(parent=15,current_idx=30)#define mjMAXIMP        0.9999   
		SingleCommentNode(parent=15,current_idx=31)// maximum constraint impedance
		MacroDefineNode(parent=15,current_idx=32)#define mjMAXCONPAIR    50       
		SingleCommentNode(parent=15,current_idx=33)// maximum number of contacts per geom pair
		MacroDefineNode(parent=15,current_idx=34)#define mjMAXTREEDEPTH  50       
		SingleCommentNode(parent=15,current_idx=35)// maximum bounding volume hierarchy depth
		WhitespaceNode(parent=15,n_lines=2,current_idx=36) 
		SingleCommentNode(parent=15,current_idx=37)//---------------------------------- sizes ---------------------------------------------------------
		WhitespaceNode(parent=15,n_lines=1,current_idx=38)
		MacroDefineNode(parent=15,current_idx=39)#define mjNEQDATA       11       
		SingleCommentNode(parent=15,current_idx=40)// number of eq_data fields
		MacroDefineNode(parent=15,current_idx=41)#define mjNDYN          10       
		SingleCommentNode(parent=15,current_idx=42)// number of actuator dynamics parameters
		MacroDefineNode(parent=15,current_idx=43)#define mjNGAIN         10       
		SingleCommentNode(parent=15,current_idx=44)// number of actuator gain parameters
		MacroDefineNode(parent=15,current_idx=45)#define mjNBIAS         10       
		SingleCommentNode(parent=15,current_idx=46)// number of actuator bias parameters
		MacroDefineNode(parent=15,current_idx=47)#define mjNFLUID        12       
		SingleCommentNode(parent=15,current_idx=48)// number of fluid interaction parameters
		MacroDefineNode(parent=15,current_idx=49)#define mjNREF          2        
		SingleCommentNode(parent=15,current_idx=50)// number of solver reference parameters
		MacroDefineNode(parent=15,current_idx=51)#define mjNIMP          5        
		SingleCommentNode(parent=15,current_idx=52)// number of solver impedance parameters
		MacroDefineNode(parent=15,current_idx=53)#define mjNSOLVER       200      
		SingleCommentNode(parent=15,current_idx=54)// size of one mjData.solver array
		MacroDefineNode(parent=15,current_idx=55)#define mjNISLAND       20       
		SingleCommentNode(parent=15,current_idx=56)// number of mjData.solver arrays
		WhitespaceNode(parent=15,n_lines=1,current_idx=57)
		SingleCommentNode(parent=15,current_idx=58)//---------------------------------- enum types (mjt) ----------------------------------------------
		WhitespaceNode(parent=15,n_lines=1,current_idx=59)
		TypedefNode(parent=15,current_idx=60,typename=mjtDisableBit)typedef
			EnumNode(name=mjtDisableBit_,parent=60,current_idx=61)enum mjtDisableBit_
				ScopeNode(parent=61,current_idx=62,scope_type=ENUM){
					WhitespaceNode(parent=62,n_lines=1,current_idx=63)   
					SingleCommentNode(parent=62,current_idx=64)// disable default feature bitflags
					WhitespaceNode(parent=62,n_lines=1,current_idx=65) 
					EnumFieldNode(field_name=mjDSBL_CONSTRAINT,parent=62,current_idx=66)mjDSBL_CONSTRAINT   = 1<<0 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=67)    
					SingleCommentNode(parent=62,current_idx=68)// entire constraint solver
					WhitespaceNode(parent=62,n_lines=1,current_idx=69) 
					EnumFieldNode(field_name=mjDSBL_EQUALITY,parent=62,current_idx=70)mjDSBL_EQUALITY     = 1<<1 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=71)    
					SingleCommentNode(parent=62,current_idx=72)// equality constraints
					WhitespaceNode(parent=62,n_lines=1,current_idx=73) 
					EnumFieldNode(field_name=mjDSBL_FRICTIONLOSS,parent=62,current_idx=74)mjDSBL_FRICTIONLOSS = 1<<2 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=75)    
					SingleCommentNode(parent=62,current_idx=76)// joint and tendon frictionloss constraints
					WhitespaceNode(parent=62,n_lines=1,current_idx=77) 
					EnumFieldNode(field_name=mjDSBL_LIMIT,parent=62,current_idx=78)mjDSBL_LIMIT        = 1<<3 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=79)    
					SingleCommentNode(parent=62,current_idx=80)// joint and tendon limit constraints
					WhitespaceNode(parent=62,n_lines=1,current_idx=81) 
					EnumFieldNode(field_name=mjDSBL_CONTACT,parent=62,current_idx=82)mjDSBL_CONTACT      = 1<<4 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=83)    
					SingleCommentNode(parent=62,current_idx=84)// contact constraints
					WhitespaceNode(parent=62,n_lines=1,current_idx=85) 
					EnumFieldNode(field_name=mjDSBL_PASSIVE,parent=62,current_idx=86)mjDSBL_PASSIVE      = 1<<5 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=87)    
					SingleCommentNode(parent=62,current_idx=88)// passive forces
					WhitespaceNode(parent=62,n_lines=1,current_idx=89) 
					EnumFieldNode(field_name=mjDSBL_GRAVITY,parent=62,current_idx=90)mjDSBL_GRAVITY      = 1<<6 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=91)    
					SingleCommentNode(parent=62,current_idx=92)// gravitational forces
					WhitespaceNode(parent=62,n_lines=1,current_idx=93) 
					EnumFieldNode(field_name=mjDSBL_CLAMPCTRL,parent=62,current_idx=94)mjDSBL_CLAMPCTRL    = 1<<7 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=95)    
					SingleCommentNode(parent=62,current_idx=96)// clamp control to specified range
					WhitespaceNode(parent=62,n_lines=1,current_idx=97) 
					EnumFieldNode(field_name=mjDSBL_WARMSTART,parent=62,current_idx=98)mjDSBL_WARMSTART    = 1<<8 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=99)    
					SingleCommentNode(parent=62,current_idx=100)// warmstart constraint solver
					WhitespaceNode(parent=62,n_lines=1,current_idx=101) 
					EnumFieldNode(field_name=mjDSBL_FILTERPARENT,parent=62,current_idx=102)mjDSBL_FILTERPARENT = 1<<9 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=103)    
					SingleCommentNode(parent=62,current_idx=104)// remove collisions with parent body
					WhitespaceNode(parent=62,n_lines=1,current_idx=105) 
					EnumFieldNode(field_name=mjDSBL_ACTUATION,parent=62,current_idx=106)mjDSBL_ACTUATION    = 1<<10 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=107)   
					SingleCommentNode(parent=62,current_idx=108)// apply actuation forces
					WhitespaceNode(parent=62,n_lines=1,current_idx=109) 
					EnumFieldNode(field_name=mjDSBL_REFSAFE,parent=62,current_idx=110)mjDSBL_REFSAFE      = 1<<11 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=111)   
					SingleCommentNode(parent=62,current_idx=112)// integrator safety: make ref[0]>=2*timestep
					WhitespaceNode(parent=62,n_lines=1,current_idx=113) 
					EnumFieldNode(field_name=mjDSBL_SENSOR,parent=62,current_idx=114)mjDSBL_SENSOR       = 1<<12 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=115)   
					SingleCommentNode(parent=62,current_idx=116)// sensors
					WhitespaceNode(parent=62,n_lines=1,current_idx=117) 
					EnumFieldNode(field_name=mjDSBL_MIDPHASE,parent=62,current_idx=118)mjDSBL_MIDPHASE     = 1<<13 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=119)   
					SingleCommentNode(parent=62,current_idx=120)// mid-phase collision filtering
					WhitespaceNode(parent=62,n_lines=1,current_idx=121) 
					EnumFieldNode(field_name=mjDSBL_EULERDAMP,parent=62,current_idx=122)mjDSBL_EULERDAMP    = 1<<14 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=123)   
					SingleCommentNode(parent=62,current_idx=124)// implicit integration of joint damping in Euler integrator
					WhitespaceNode(parent=62,n_lines=1,current_idx=125) 
					EnumFieldNode(field_name=mjDSBL_AUTORESET,parent=62,current_idx=126)mjDSBL_AUTORESET    = 1<<15 ,
					WhitespaceNode(parent=62,n_lines=1,current_idx=127)   
					SingleCommentNode(parent=62,current_idx=128)// automatic reset when numerical issues are detected
					WhitespaceNode(parent=62,n_lines=2,current_idx=129)  
					EnumFieldNode(field_name=mjNDISABLE,parent=62,current_idx=130)mjNDISABLE          = 16
					WhitespaceNode(parent=62,n_lines=1,current_idx=131)      
					SingleCommentNode(parent=62,current_idx=132)// number of disable flags
				}
			DeletedNode(parent=15,current_idx=0)mjtDisableBit
		mjtDisableBit ;
		WhitespaceNode(parent=15,n_lines=3,current_idx=134)  
		TypedefNode(parent=15,current_idx=135,typename=mjtEnableBit)typedef
			EnumNode(name=mjtEnableBit_,parent=135,current_idx=136)enum mjtEnableBit_
				ScopeNode(parent=136,current_idx=137,scope_type=ENUM){
					WhitespaceNode(parent=137,n_lines=1,current_idx=138)    
					SingleCommentNode(parent=137,current_idx=139)// enable optional feature bitflags
					WhitespaceNode(parent=137,n_lines=1,current_idx=140) 
					EnumFieldNode(field_name=mjENBL_OVERRIDE,parent=137,current_idx=141)mjENBL_OVERRIDE     = 1<<0 ,
					WhitespaceNode(parent=137,n_lines=1,current_idx=142)    
					SingleCommentNode(parent=137,current_idx=143)// override contact parameters
					WhitespaceNode(parent=137,n_lines=1,current_idx=144) 
					EnumFieldNode(field_name=mjENBL_ENERGY,parent=137,current_idx=145)mjENBL_ENERGY       = 1<<1 ,
					WhitespaceNode(parent=137,n_lines=1,current_idx=146)    
					SingleCommentNode(parent=137,current_idx=147)// energy computation
					WhitespaceNode(parent=137,n_lines=1,current_idx=148) 
					EnumFieldNode(field_name=mjENBL_FWDINV,parent=137,current_idx=149)mjENBL_FWDINV       = 1<<2 ,
					WhitespaceNode(parent=137,n_lines=1,current_idx=150)    
					SingleCommentNode(parent=137,current_idx=151)// record solver statistics
					WhitespaceNode(parent=137,n_lines=1,current_idx=152) 
					EnumFieldNode(field_name=mjENBL_INVDISCRETE,parent=137,current_idx=153)mjENBL_INVDISCRETE  = 1<<3 ,
					WhitespaceNode(parent=137,n_lines=1,current_idx=154)    
					SingleCommentNode(parent=137,current_idx=155)// discrete-time inverse dynamics
					WhitespaceNode(parent=137,n_lines=1,current_idx=156)                                 
					SingleCommentNode(parent=137,current_idx=157)// experimental features:
					WhitespaceNode(parent=137,n_lines=1,current_idx=158) 
					EnumFieldNode(field_name=mjENBL_MULTICCD,parent=137,current_idx=159)mjENBL_MULTICCD     = 1<<4 ,
					WhitespaceNode(parent=137,n_lines=1,current_idx=160)    
					SingleCommentNode(parent=137,current_idx=161)// multi-point convex collision detection
					WhitespaceNode(parent=137,n_lines=1,current_idx=162) 
					EnumFieldNode(field_name=mjENBL_ISLAND,parent=137,current_idx=163)mjENBL_ISLAND       = 1<<5 ,
					WhitespaceNode(parent=137,n_lines=1,current_idx=164)    
					SingleCommentNode(parent=137,current_idx=165)// constraint island discovery
					WhitespaceNode(parent=137,n_lines=1,current_idx=166) 
					EnumFieldNode(field_name=mjENBL_NATIVECCD,parent=137,current_idx=167)mjENBL_NATIVECCD    = 1<<6 ,
					WhitespaceNode(parent=137,n_lines=1,current_idx=168)    
					SingleCommentNode(parent=137,current_idx=169)// native convex collision detection
					WhitespaceNode(parent=137,n_lines=2,current_idx=170)  
					EnumFieldNode(field_name=mjNENABLE,parent=137,current_idx=171)mjNENABLE           = 7
					WhitespaceNode(parent=137,n_lines=1,current_idx=172)       
					SingleCommentNode(parent=137,current_idx=173)// number of enable flags
				}
			DeletedNode(parent=15,current_idx=0)mjtEnableBit
		mjtEnableBit ;
		WhitespaceNode(parent=15,n_lines=3,current_idx=175)  
		TypedefNode(parent=15,current_idx=176,typename=mjtGeom)typedef
			EnumNode(name=mjtJoint_,parent=176,current_idx=177)enum mjtJoint_
				ScopeNode(parent=177,current_idx=178,scope_type=ENUM){
					WhitespaceNode(parent=178,n_lines=1,current_idx=179)        
					SingleCommentNode(parent=178,current_idx=180)// type of degree of freedom
					WhitespaceNode(parent=178,n_lines=1,current_idx=181) 
					EnumFieldNode(field_name=mjJNT_FREE,parent=178,current_idx=182)mjJNT_FREE          = 0 ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=183)       
					SingleCommentNode(parent=178,current_idx=184)// global position and orientation (quat)       (7)
					WhitespaceNode(parent=178,n_lines=1,current_idx=185) 
					EnumFieldNode(field_name=mjJNT_BALL,parent=178,current_idx=186)mjJNT_BALL ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=187)                    
					SingleCommentNode(parent=178,current_idx=188)// orientation (quat) relative to parent        (4)
					WhitespaceNode(parent=178,n_lines=1,current_idx=189) 
					EnumFieldNode(field_name=mjJNT_SLIDE,parent=178,current_idx=190)mjJNT_SLIDE ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=191)                   
					SingleCommentNode(parent=178,current_idx=192)// sliding distance along body-fixed axis       (1)
					WhitespaceNode(parent=178,n_lines=1,current_idx=193) 
					EnumFieldNode(field_name=mjJNT_HINGE,parent=178,current_idx=194)mjJNT_HINGE                     // rotation angle (rad) around body-fixed axis  (1) } mjtJoint ;    typedef enum mjtGeom_ {           // type of geometric shape   // regular geom types   mjGEOM_PLANE        = 0 ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=195)       
					SingleCommentNode(parent=178,current_idx=196)// plane
					WhitespaceNode(parent=178,n_lines=1,current_idx=197) 
					EnumFieldNode(field_name=mjGEOM_HFIELD,parent=178,current_idx=198)mjGEOM_HFIELD ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=199)                 
					SingleCommentNode(parent=178,current_idx=200)// height field
					WhitespaceNode(parent=178,n_lines=1,current_idx=201) 
					EnumFieldNode(field_name=mjGEOM_SPHERE,parent=178,current_idx=202)mjGEOM_SPHERE ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=203)                 
					SingleCommentNode(parent=178,current_idx=204)// sphere
					WhitespaceNode(parent=178,n_lines=1,current_idx=205) 
					EnumFieldNode(field_name=mjGEOM_CAPSULE,parent=178,current_idx=206)mjGEOM_CAPSULE ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=207)                
					SingleCommentNode(parent=178,current_idx=208)// capsule
					WhitespaceNode(parent=178,n_lines=1,current_idx=209) 
					EnumFieldNode(field_name=mjGEOM_ELLIPSOID,parent=178,current_idx=210)mjGEOM_ELLIPSOID ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=211)              
					SingleCommentNode(parent=178,current_idx=212)// ellipsoid
					WhitespaceNode(parent=178,n_lines=1,current_idx=213) 
					EnumFieldNode(field_name=mjGEOM_CYLINDER,parent=178,current_idx=214)mjGEOM_CYLINDER ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=215)               
					SingleCommentNode(parent=178,current_idx=216)// cylinder
					WhitespaceNode(parent=178,n_lines=1,current_idx=217) 
					EnumFieldNode(field_name=mjGEOM_BOX,parent=178,current_idx=218)mjGEOM_BOX ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=219)                    
					SingleCommentNode(parent=178,current_idx=220)// box
					WhitespaceNode(parent=178,n_lines=1,current_idx=221) 
					EnumFieldNode(field_name=mjGEOM_MESH,parent=178,current_idx=222)mjGEOM_MESH ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=223)                   
					SingleCommentNode(parent=178,current_idx=224)// mesh
					WhitespaceNode(parent=178,n_lines=1,current_idx=225) 
					EnumFieldNode(field_name=mjGEOM_SDF,parent=178,current_idx=226)mjGEOM_SDF ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=227)                    
					SingleCommentNode(parent=178,current_idx=228)// signed distance field
					WhitespaceNode(parent=178,n_lines=2,current_idx=229)  
					EnumFieldNode(field_name=mjNGEOMTYPES,parent=178,current_idx=230)mjNGEOMTYPES ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=231)                  
					SingleCommentNode(parent=178,current_idx=232)// number of regular geom types
					WhitespaceNode(parent=178,n_lines=2,current_idx=233)  
					SingleCommentNode(parent=178,current_idx=234)// rendering-only geom types: not used in mjModel ,  not counted in mjNGEOMTYPES
					WhitespaceNode(parent=178,n_lines=1,current_idx=235) 
					EnumFieldNode(field_name=mjGEOM_ARROW,parent=178,current_idx=236)mjGEOM_ARROW        = 100 ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=237)     
					SingleCommentNode(parent=178,current_idx=238)// arrow
					WhitespaceNode(parent=178,n_lines=1,current_idx=239) 
					EnumFieldNode(field_name=mjGEOM_ARROW1,parent=178,current_idx=240)mjGEOM_ARROW1 ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=241)                 
					SingleCommentNode(parent=178,current_idx=242)// arrow without wedges
					WhitespaceNode(parent=178,n_lines=1,current_idx=243) 
					EnumFieldNode(field_name=mjGEOM_ARROW2,parent=178,current_idx=244)mjGEOM_ARROW2 ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=245)                 
					SingleCommentNode(parent=178,current_idx=246)// arrow in both directions
					WhitespaceNode(parent=178,n_lines=1,current_idx=247) 
					EnumFieldNode(field_name=mjGEOM_LINE,parent=178,current_idx=248)mjGEOM_LINE ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=249)                   
					SingleCommentNode(parent=178,current_idx=250)// line
					WhitespaceNode(parent=178,n_lines=1,current_idx=251) 
					EnumFieldNode(field_name=mjGEOM_LINEBOX,parent=178,current_idx=252)mjGEOM_LINEBOX ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=253)                
					SingleCommentNode(parent=178,current_idx=254)// box with line edges
					WhitespaceNode(parent=178,n_lines=1,current_idx=255) 
					EnumFieldNode(field_name=mjGEOM_FLEX,parent=178,current_idx=256)mjGEOM_FLEX ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=257)                   
					SingleCommentNode(parent=178,current_idx=258)// flex
					WhitespaceNode(parent=178,n_lines=1,current_idx=259) 
					EnumFieldNode(field_name=mjGEOM_SKIN,parent=178,current_idx=260)mjGEOM_SKIN ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=261)                   
					SingleCommentNode(parent=178,current_idx=262)// skin
					WhitespaceNode(parent=178,n_lines=1,current_idx=263) 
					EnumFieldNode(field_name=mjGEOM_LABEL,parent=178,current_idx=264)mjGEOM_LABEL ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=265)                  
					SingleCommentNode(parent=178,current_idx=266)// text label
					WhitespaceNode(parent=178,n_lines=1,current_idx=267) 
					EnumFieldNode(field_name=mjGEOM_TRIANGLE,parent=178,current_idx=268)mjGEOM_TRIANGLE ,
					WhitespaceNode(parent=178,n_lines=1,current_idx=269)               
					SingleCommentNode(parent=178,current_idx=270)// triangle
					WhitespaceNode(parent=178,n_lines=2,current_idx=271)  
					EnumFieldNode(field_name=mjGEOM_NONE,parent=178,current_idx=272)mjGEOM_NONE         = 1001
					WhitespaceNode(parent=178,n_lines=1,current_idx=273)    
					SingleCommentNode(parent=178,current_idx=274)// missing geom type
				}
			DeletedNode(parent=15,current_idx=0)mjtGeom
		mjtGeom ;
		WhitespaceNode(parent=15,n_lines=3,current_idx=276)  
		TypedefNode(parent=15,current_idx=277,typename=mjtTrn)typedef
			EnumNode(name=mjtCamLight_,parent=277,current_idx=278)enum mjtCamLight_
				ScopeNode(parent=278,current_idx=279,scope_type=ENUM){
					WhitespaceNode(parent=279,n_lines=1,current_idx=280)     
					SingleCommentNode(parent=279,current_idx=281)// tracking mode for camera and light
					WhitespaceNode(parent=279,n_lines=1,current_idx=282) 
					EnumFieldNode(field_name=mjCAMLIGHT_FIXED,parent=279,current_idx=283)mjCAMLIGHT_FIXED    = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=284)       
					SingleCommentNode(parent=279,current_idx=285)// pos and rot fixed in body
					WhitespaceNode(parent=279,n_lines=1,current_idx=286) 
					EnumFieldNode(field_name=mjCAMLIGHT_TRACK,parent=279,current_idx=287)mjCAMLIGHT_TRACK ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=288)              
					SingleCommentNode(parent=279,current_idx=289)// pos tracks body ,  rot fixed in global
					WhitespaceNode(parent=279,n_lines=1,current_idx=290) 
					EnumFieldNode(field_name=mjCAMLIGHT_TRACKCOM,parent=279,current_idx=291)mjCAMLIGHT_TRACKCOM ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=292)           
					SingleCommentNode(parent=279,current_idx=293)// pos tracks subtree com ,  rot fixed in body
					WhitespaceNode(parent=279,n_lines=1,current_idx=294) 
					EnumFieldNode(field_name=mjCAMLIGHT_TARGETBODY,parent=279,current_idx=295)mjCAMLIGHT_TARGETBODY ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=296)         
					SingleCommentNode(parent=279,current_idx=297)// pos fixed in body ,  rot tracks target body
					WhitespaceNode(parent=279,n_lines=1,current_idx=298) 
					EnumFieldNode(field_name=mjCAMLIGHT_TARGETBODYCOM,parent=279,current_idx=299)mjCAMLIGHT_TARGETBODYCOM        // pos fixed in body ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=300)
					EnumFieldNode(field_name=rot,parent=279,current_idx=301)rot tracks target subtree com } mjtCamLight ;    typedef enum mjtTexture_ {        // type of texture   mjTEXTURE_2D        = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=302)       
					SingleCommentNode(parent=279,current_idx=303)// 2d texture ,  suitable for planes and hfields
					WhitespaceNode(parent=279,n_lines=1,current_idx=304) 
					EnumFieldNode(field_name=mjTEXTURE_CUBE,parent=279,current_idx=305)mjTEXTURE_CUBE ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=306)                
					SingleCommentNode(parent=279,current_idx=307)// cube texture ,  suitable for all other geom types
					WhitespaceNode(parent=279,n_lines=1,current_idx=308) 
					EnumFieldNode(field_name=mjTEXTURE_SKYBOX,parent=279,current_idx=309)mjTEXTURE_SKYBOX                // cube texture used as skybox } mjtTexture ;    typedef enum mjtTextureRole_ {    // role of texture map in rendering   mjTEXROLE_USER      = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=310)       
					SingleCommentNode(parent=279,current_idx=311)// unspecified
					WhitespaceNode(parent=279,n_lines=1,current_idx=312) 
					EnumFieldNode(field_name=mjTEXROLE_RGB,parent=279,current_idx=313)mjTEXROLE_RGB ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=314)                 
					SingleCommentNode(parent=279,current_idx=315)// base color (albedo)
					WhitespaceNode(parent=279,n_lines=1,current_idx=316) 
					EnumFieldNode(field_name=mjTEXROLE_OCCLUSION,parent=279,current_idx=317)mjTEXROLE_OCCLUSION ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=318)           
					SingleCommentNode(parent=279,current_idx=319)// ambient occlusion
					WhitespaceNode(parent=279,n_lines=1,current_idx=320) 
					EnumFieldNode(field_name=mjTEXROLE_ROUGHNESS,parent=279,current_idx=321)mjTEXROLE_ROUGHNESS ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=322)           
					SingleCommentNode(parent=279,current_idx=323)// roughness
					WhitespaceNode(parent=279,n_lines=1,current_idx=324) 
					EnumFieldNode(field_name=mjTEXROLE_METALLIC,parent=279,current_idx=325)mjTEXROLE_METALLIC ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=326)            
					SingleCommentNode(parent=279,current_idx=327)// metallic
					WhitespaceNode(parent=279,n_lines=1,current_idx=328) 
					EnumFieldNode(field_name=mjTEXROLE_NORMAL,parent=279,current_idx=329)mjTEXROLE_NORMAL ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=330)              
					SingleCommentNode(parent=279,current_idx=331)// normal (bump) map
					WhitespaceNode(parent=279,n_lines=1,current_idx=332) 
					EnumFieldNode(field_name=mjTEXROLE_OPACITY,parent=279,current_idx=333)mjTEXROLE_OPACITY ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=334)             
					SingleCommentNode(parent=279,current_idx=335)// transperancy
					WhitespaceNode(parent=279,n_lines=1,current_idx=336) 
					EnumFieldNode(field_name=mjTEXROLE_EMISSIVE,parent=279,current_idx=337)mjTEXROLE_EMISSIVE ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=338)            
					SingleCommentNode(parent=279,current_idx=339)// light emission
					WhitespaceNode(parent=279,n_lines=1,current_idx=340) 
					EnumFieldNode(field_name=mjTEXROLE_RGBA,parent=279,current_idx=341)mjTEXROLE_RGBA ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=342)                
					SingleCommentNode(parent=279,current_idx=343)// base color ,  opacity
					WhitespaceNode(parent=279,n_lines=1,current_idx=344) 
					EnumFieldNode(field_name=mjTEXROLE_ORM,parent=279,current_idx=345)mjTEXROLE_ORM ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=346)                 
					SingleCommentNode(parent=279,current_idx=347)// occlusion ,  roughness ,  metallic
					WhitespaceNode(parent=279,n_lines=1,current_idx=348) 
					EnumFieldNode(field_name=mjNTEXROLE,parent=279,current_idx=349)mjNTEXROLE } mjtTextureRole ;    typedef enum mjtIntegrator_ {     // integrator mode   mjINT_EULER         = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=350)       
					SingleCommentNode(parent=279,current_idx=351)// semi-implicit Euler
					WhitespaceNode(parent=279,n_lines=1,current_idx=352) 
					EnumFieldNode(field_name=mjINT_RK4,parent=279,current_idx=353)mjINT_RK4 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=354)                     
					SingleCommentNode(parent=279,current_idx=355)// 4th-order Runge Kutta
					WhitespaceNode(parent=279,n_lines=1,current_idx=356) 
					EnumFieldNode(field_name=mjINT_IMPLICIT,parent=279,current_idx=357)mjINT_IMPLICIT ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=358)                
					SingleCommentNode(parent=279,current_idx=359)// implicit in velocity
					WhitespaceNode(parent=279,n_lines=1,current_idx=360) 
					EnumFieldNode(field_name=mjINT_IMPLICITFAST,parent=279,current_idx=361)mjINT_IMPLICITFAST              // implicit in velocity ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=362)
					EnumFieldNode(field_name=no,parent=279,current_idx=363)no rne derivative } mjtIntegrator ;    typedef enum mjtCone_ {           // type of friction cone   mjCONE_PYRAMIDAL     = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=364)      
					SingleCommentNode(parent=279,current_idx=365)// pyramidal
					WhitespaceNode(parent=279,n_lines=1,current_idx=366) 
					EnumFieldNode(field_name=mjCONE_ELLIPTIC,parent=279,current_idx=367)mjCONE_ELLIPTIC                 // elliptic } mjtCone ;    typedef enum mjtJacobian_ {       // type of constraint Jacobian   mjJAC_DENSE          = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=368)      
					SingleCommentNode(parent=279,current_idx=369)// dense
					WhitespaceNode(parent=279,n_lines=1,current_idx=370) 
					EnumFieldNode(field_name=mjJAC_SPARSE,parent=279,current_idx=371)mjJAC_SPARSE ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=372)                  
					SingleCommentNode(parent=279,current_idx=373)// sparse
					WhitespaceNode(parent=279,n_lines=1,current_idx=374) 
					EnumFieldNode(field_name=mjJAC_AUTO,parent=279,current_idx=375)mjJAC_AUTO                      // dense if nv<60 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=376)
					EnumFieldNode(field_name=sparse,parent=279,current_idx=377)sparse otherwise } mjtJacobian ;    typedef enum mjtSolver_ {         // constraint solver algorithm   mjSOL_PGS            = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=378)      
					SingleCommentNode(parent=279,current_idx=379)// PGS    (dual)
					WhitespaceNode(parent=279,n_lines=1,current_idx=380) 
					EnumFieldNode(field_name=mjSOL_CG,parent=279,current_idx=381)mjSOL_CG ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=382)                      
					SingleCommentNode(parent=279,current_idx=383)// CG     (primal)
					WhitespaceNode(parent=279,n_lines=1,current_idx=384) 
					EnumFieldNode(field_name=mjSOL_NEWTON,parent=279,current_idx=385)mjSOL_NEWTON                    // Newton (primal) } mjtSolver ;    typedef enum mjtEq_ {             // type of equality constraint   mjEQ_CONNECT        = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=386)       
					SingleCommentNode(parent=279,current_idx=387)// connect two bodies at a point (ball joint)
					WhitespaceNode(parent=279,n_lines=1,current_idx=388) 
					EnumFieldNode(field_name=mjEQ_WELD,parent=279,current_idx=389)mjEQ_WELD ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=390)                     
					SingleCommentNode(parent=279,current_idx=391)// fix relative position and orientation of two bodies
					WhitespaceNode(parent=279,n_lines=1,current_idx=392) 
					EnumFieldNode(field_name=mjEQ_JOINT,parent=279,current_idx=393)mjEQ_JOINT ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=394)                    
					SingleCommentNode(parent=279,current_idx=395)// couple the values of two scalar joints with cubic
					WhitespaceNode(parent=279,n_lines=1,current_idx=396) 
					EnumFieldNode(field_name=mjEQ_TENDON,parent=279,current_idx=397)mjEQ_TENDON ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=398)                   
					SingleCommentNode(parent=279,current_idx=399)// couple the lengths of two tendons with cubic
					WhitespaceNode(parent=279,n_lines=1,current_idx=400) 
					EnumFieldNode(field_name=mjEQ_FLEX,parent=279,current_idx=401)mjEQ_FLEX ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=402)                     
					SingleCommentNode(parent=279,current_idx=403)// fix all edge lengths of a flex
					WhitespaceNode(parent=279,n_lines=1,current_idx=404) 
					EnumFieldNode(field_name=mjEQ_DISTANCE,parent=279,current_idx=405)mjEQ_DISTANCE                   // unsupported ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=406)
					EnumFieldNode(field_name=will,parent=279,current_idx=407)will cause an error if used } mjtEq ;    typedef enum mjtWrap_ {           // type of tendon wrap object   mjWRAP_NONE         = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=408)       
					SingleCommentNode(parent=279,current_idx=409)// null object
					WhitespaceNode(parent=279,n_lines=1,current_idx=410) 
					EnumFieldNode(field_name=mjWRAP_JOINT,parent=279,current_idx=411)mjWRAP_JOINT ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=412)                  
					SingleCommentNode(parent=279,current_idx=413)// constant moment arm
					WhitespaceNode(parent=279,n_lines=1,current_idx=414) 
					EnumFieldNode(field_name=mjWRAP_PULLEY,parent=279,current_idx=415)mjWRAP_PULLEY ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=416)                 
					SingleCommentNode(parent=279,current_idx=417)// pulley used to split tendon
					WhitespaceNode(parent=279,n_lines=1,current_idx=418) 
					EnumFieldNode(field_name=mjWRAP_SITE,parent=279,current_idx=419)mjWRAP_SITE ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=420)                   
					SingleCommentNode(parent=279,current_idx=421)// pass through site
					WhitespaceNode(parent=279,n_lines=1,current_idx=422) 
					EnumFieldNode(field_name=mjWRAP_SPHERE,parent=279,current_idx=423)mjWRAP_SPHERE ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=424)                 
					SingleCommentNode(parent=279,current_idx=425)// wrap around sphere
					WhitespaceNode(parent=279,n_lines=1,current_idx=426) 
					EnumFieldNode(field_name=mjWRAP_CYLINDER,parent=279,current_idx=427)mjWRAP_CYLINDER                 // wrap around (infinite) cylinder } mjtWrap ;    typedef enum mjtTrn_ {            // type of actuator transmission   mjTRN_JOINT         = 0 ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=428)       
					SingleCommentNode(parent=279,current_idx=429)// force on joint
					WhitespaceNode(parent=279,n_lines=1,current_idx=430) 
					EnumFieldNode(field_name=mjTRN_JOINTINPARENT,parent=279,current_idx=431)mjTRN_JOINTINPARENT ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=432)           
					SingleCommentNode(parent=279,current_idx=433)// force on joint ,  expressed in parent frame
					WhitespaceNode(parent=279,n_lines=1,current_idx=434) 
					EnumFieldNode(field_name=mjTRN_SLIDERCRANK,parent=279,current_idx=435)mjTRN_SLIDERCRANK ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=436)             
					SingleCommentNode(parent=279,current_idx=437)// force via slider-crank linkage
					WhitespaceNode(parent=279,n_lines=1,current_idx=438) 
					EnumFieldNode(field_name=mjTRN_TENDON,parent=279,current_idx=439)mjTRN_TENDON ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=440)                  
					SingleCommentNode(parent=279,current_idx=441)// force on tendon
					WhitespaceNode(parent=279,n_lines=1,current_idx=442) 
					EnumFieldNode(field_name=mjTRN_SITE,parent=279,current_idx=443)mjTRN_SITE ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=444)                    
					SingleCommentNode(parent=279,current_idx=445)// force on site
					WhitespaceNode(parent=279,n_lines=1,current_idx=446) 
					EnumFieldNode(field_name=mjTRN_BODY,parent=279,current_idx=447)mjTRN_BODY ,
					WhitespaceNode(parent=279,n_lines=1,current_idx=448)                    
					SingleCommentNode(parent=279,current_idx=449)// adhesion force on a body's geoms
					WhitespaceNode(parent=279,n_lines=2,current_idx=450)  
					EnumFieldNode(field_name=mjTRN_UNDEFINED,parent=279,current_idx=451)mjTRN_UNDEFINED     = 1000
					WhitespaceNode(parent=279,n_lines=1,current_idx=452)    
					SingleCommentNode(parent=279,current_idx=453)// undefined transmission type
				}
			DeletedNode(parent=15,current_idx=0)mjtTrn
		mjtTrn ;
		WhitespaceNode(parent=15,n_lines=3,current_idx=455)  
		TypedefNode(parent=15,current_idx=456,typename=mjtObj)typedef
			EnumNode(name=mjtDyn_,parent=456,current_idx=457)enum mjtDyn_
				ScopeNode(parent=457,current_idx=458,scope_type=ENUM){
					WhitespaceNode(parent=458,n_lines=1,current_idx=459)          
					SingleCommentNode(parent=458,current_idx=460)// type of actuator dynamics
					WhitespaceNode(parent=458,n_lines=1,current_idx=461) 
					EnumFieldNode(field_name=mjDYN_NONE,parent=458,current_idx=462)mjDYN_NONE          = 0 ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=463)       
					SingleCommentNode(parent=458,current_idx=464)// no internal dynamics ;  ctrl specifies force
					WhitespaceNode(parent=458,n_lines=1,current_idx=465) 
					EnumFieldNode(field_name=mjDYN_INTEGRATOR,parent=458,current_idx=466)mjDYN_INTEGRATOR ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=467)              
					SingleCommentNode(parent=458,current_idx=468)// integrator: da/dt = u
					WhitespaceNode(parent=458,n_lines=1,current_idx=469) 
					EnumFieldNode(field_name=mjDYN_FILTER,parent=458,current_idx=470)mjDYN_FILTER ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=471)                  
					SingleCommentNode(parent=458,current_idx=472)// linear filter: da/dt = (u-a) / tau
					WhitespaceNode(parent=458,n_lines=1,current_idx=473) 
					EnumFieldNode(field_name=mjDYN_FILTEREXACT,parent=458,current_idx=474)mjDYN_FILTEREXACT ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=475)             
					SingleCommentNode(parent=458,current_idx=476)// linear filter: da/dt = (u-a) / tau ,  with exact integration
					WhitespaceNode(parent=458,n_lines=1,current_idx=477) 
					EnumFieldNode(field_name=mjDYN_MUSCLE,parent=458,current_idx=478)mjDYN_MUSCLE ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=479)                  
					SingleCommentNode(parent=458,current_idx=480)// piece-wise linear filter with two time constants
					WhitespaceNode(parent=458,n_lines=1,current_idx=481) 
					EnumFieldNode(field_name=mjDYN_USER,parent=458,current_idx=482)mjDYN_USER                      // user-defined dynamics type } mjtDyn ;    typedef enum mjtGain_ {           // type of actuator gain   mjGAIN_FIXED        = 0 ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=483)       
					SingleCommentNode(parent=458,current_idx=484)// fixed gain
					WhitespaceNode(parent=458,n_lines=1,current_idx=485) 
					EnumFieldNode(field_name=mjGAIN_AFFINE,parent=458,current_idx=486)mjGAIN_AFFINE ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=487)                 
					SingleCommentNode(parent=458,current_idx=488)// const + kp*length + kv*velocity
					WhitespaceNode(parent=458,n_lines=1,current_idx=489) 
					EnumFieldNode(field_name=mjGAIN_MUSCLE,parent=458,current_idx=490)mjGAIN_MUSCLE ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=491)                 
					SingleCommentNode(parent=458,current_idx=492)// muscle FLV curve computed by mju_muscleGain()
					WhitespaceNode(parent=458,n_lines=1,current_idx=493) 
					EnumFieldNode(field_name=mjGAIN_USER,parent=458,current_idx=494)mjGAIN_USER                     // user-defined gain type } mjtGain ;    typedef enum mjtBias_ {           // type of actuator bias   mjBIAS_NONE         = 0 ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=495)       
					SingleCommentNode(parent=458,current_idx=496)// no bias
					WhitespaceNode(parent=458,n_lines=1,current_idx=497) 
					EnumFieldNode(field_name=mjBIAS_AFFINE,parent=458,current_idx=498)mjBIAS_AFFINE ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=499)                 
					SingleCommentNode(parent=458,current_idx=500)// const + kp*length + kv*velocity
					WhitespaceNode(parent=458,n_lines=1,current_idx=501) 
					EnumFieldNode(field_name=mjBIAS_MUSCLE,parent=458,current_idx=502)mjBIAS_MUSCLE ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=503)                 
					SingleCommentNode(parent=458,current_idx=504)// muscle passive force computed by mju_muscleBias()
					WhitespaceNode(parent=458,n_lines=1,current_idx=505) 
					EnumFieldNode(field_name=mjBIAS_USER,parent=458,current_idx=506)mjBIAS_USER                     // user-defined bias type } mjtBias ;    typedef enum mjtObj_ {            // type of MujoCo object   mjOBJ_UNKNOWN       = 0 ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=507)       
					SingleCommentNode(parent=458,current_idx=508)// unknown object type
					WhitespaceNode(parent=458,n_lines=1,current_idx=509) 
					EnumFieldNode(field_name=mjOBJ_BODY,parent=458,current_idx=510)mjOBJ_BODY ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=511)                    
					SingleCommentNode(parent=458,current_idx=512)// body
					WhitespaceNode(parent=458,n_lines=1,current_idx=513) 
					EnumFieldNode(field_name=mjOBJ_XBODY,parent=458,current_idx=514)mjOBJ_XBODY ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=515)                   
					SingleCommentNode(parent=458,current_idx=516)// body ,  used to access regular frame instead of i-frame
					WhitespaceNode(parent=458,n_lines=1,current_idx=517) 
					EnumFieldNode(field_name=mjOBJ_JOINT,parent=458,current_idx=518)mjOBJ_JOINT ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=519)                   
					SingleCommentNode(parent=458,current_idx=520)// joint
					WhitespaceNode(parent=458,n_lines=1,current_idx=521) 
					EnumFieldNode(field_name=mjOBJ_DOF,parent=458,current_idx=522)mjOBJ_DOF ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=523)                     
					SingleCommentNode(parent=458,current_idx=524)// dof
					WhitespaceNode(parent=458,n_lines=1,current_idx=525) 
					EnumFieldNode(field_name=mjOBJ_GEOM,parent=458,current_idx=526)mjOBJ_GEOM ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=527)                    
					SingleCommentNode(parent=458,current_idx=528)// geom
					WhitespaceNode(parent=458,n_lines=1,current_idx=529) 
					EnumFieldNode(field_name=mjOBJ_SITE,parent=458,current_idx=530)mjOBJ_SITE ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=531)                    
					SingleCommentNode(parent=458,current_idx=532)// site
					WhitespaceNode(parent=458,n_lines=1,current_idx=533) 
					EnumFieldNode(field_name=mjOBJ_CAMERA,parent=458,current_idx=534)mjOBJ_CAMERA ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=535)                  
					SingleCommentNode(parent=458,current_idx=536)// camera
					WhitespaceNode(parent=458,n_lines=1,current_idx=537) 
					EnumFieldNode(field_name=mjOBJ_LIGHT,parent=458,current_idx=538)mjOBJ_LIGHT ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=539)                   
					SingleCommentNode(parent=458,current_idx=540)// light
					WhitespaceNode(parent=458,n_lines=1,current_idx=541) 
					EnumFieldNode(field_name=mjOBJ_FLEX,parent=458,current_idx=542)mjOBJ_FLEX ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=543)                    
					SingleCommentNode(parent=458,current_idx=544)// flex
					WhitespaceNode(parent=458,n_lines=1,current_idx=545) 
					EnumFieldNode(field_name=mjOBJ_MESH,parent=458,current_idx=546)mjOBJ_MESH ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=547)                    
					SingleCommentNode(parent=458,current_idx=548)// mesh
					WhitespaceNode(parent=458,n_lines=1,current_idx=549) 
					EnumFieldNode(field_name=mjOBJ_SKIN,parent=458,current_idx=550)mjOBJ_SKIN ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=551)                    
					SingleCommentNode(parent=458,current_idx=552)// skin
					WhitespaceNode(parent=458,n_lines=1,current_idx=553) 
					EnumFieldNode(field_name=mjOBJ_HFIELD,parent=458,current_idx=554)mjOBJ_HFIELD ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=555)                  
					SingleCommentNode(parent=458,current_idx=556)// heightfield
					WhitespaceNode(parent=458,n_lines=1,current_idx=557) 
					EnumFieldNode(field_name=mjOBJ_TEXTURE,parent=458,current_idx=558)mjOBJ_TEXTURE ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=559)                 
					SingleCommentNode(parent=458,current_idx=560)// texture
					WhitespaceNode(parent=458,n_lines=1,current_idx=561) 
					EnumFieldNode(field_name=mjOBJ_MATERIAL,parent=458,current_idx=562)mjOBJ_MATERIAL ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=563)                
					SingleCommentNode(parent=458,current_idx=564)// material for rendering
					WhitespaceNode(parent=458,n_lines=1,current_idx=565) 
					EnumFieldNode(field_name=mjOBJ_PAIR,parent=458,current_idx=566)mjOBJ_PAIR ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=567)                    
					SingleCommentNode(parent=458,current_idx=568)// geom pair to include
					WhitespaceNode(parent=458,n_lines=1,current_idx=569) 
					EnumFieldNode(field_name=mjOBJ_EXCLUDE,parent=458,current_idx=570)mjOBJ_EXCLUDE ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=571)                 
					SingleCommentNode(parent=458,current_idx=572)// body pair to exclude
					WhitespaceNode(parent=458,n_lines=1,current_idx=573) 
					EnumFieldNode(field_name=mjOBJ_EQUALITY,parent=458,current_idx=574)mjOBJ_EQUALITY ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=575)                
					SingleCommentNode(parent=458,current_idx=576)// equality constraint
					WhitespaceNode(parent=458,n_lines=1,current_idx=577) 
					EnumFieldNode(field_name=mjOBJ_TENDON,parent=458,current_idx=578)mjOBJ_TENDON ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=579)                  
					SingleCommentNode(parent=458,current_idx=580)// tendon
					WhitespaceNode(parent=458,n_lines=1,current_idx=581) 
					EnumFieldNode(field_name=mjOBJ_ACTUATOR,parent=458,current_idx=582)mjOBJ_ACTUATOR ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=583)                
					SingleCommentNode(parent=458,current_idx=584)// actuator
					WhitespaceNode(parent=458,n_lines=1,current_idx=585) 
					EnumFieldNode(field_name=mjOBJ_SENSOR,parent=458,current_idx=586)mjOBJ_SENSOR ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=587)                  
					SingleCommentNode(parent=458,current_idx=588)// sensor
					WhitespaceNode(parent=458,n_lines=1,current_idx=589) 
					EnumFieldNode(field_name=mjOBJ_NUMERIC,parent=458,current_idx=590)mjOBJ_NUMERIC ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=591)                 
					SingleCommentNode(parent=458,current_idx=592)// numeric
					WhitespaceNode(parent=458,n_lines=1,current_idx=593) 
					EnumFieldNode(field_name=mjOBJ_TEXT,parent=458,current_idx=594)mjOBJ_TEXT ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=595)                    
					SingleCommentNode(parent=458,current_idx=596)// text
					WhitespaceNode(parent=458,n_lines=1,current_idx=597) 
					EnumFieldNode(field_name=mjOBJ_TUPLE,parent=458,current_idx=598)mjOBJ_TUPLE ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=599)                   
					SingleCommentNode(parent=458,current_idx=600)// tuple
					WhitespaceNode(parent=458,n_lines=1,current_idx=601) 
					EnumFieldNode(field_name=mjOBJ_KEY,parent=458,current_idx=602)mjOBJ_KEY ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=603)                     
					SingleCommentNode(parent=458,current_idx=604)// keyframe
					WhitespaceNode(parent=458,n_lines=1,current_idx=605) 
					EnumFieldNode(field_name=mjOBJ_PLUGIN,parent=458,current_idx=606)mjOBJ_PLUGIN ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=607)                  
					SingleCommentNode(parent=458,current_idx=608)// plugin instance
					WhitespaceNode(parent=458,n_lines=2,current_idx=609)  
					EnumFieldNode(field_name=mjNOBJECT,parent=458,current_idx=610)mjNOBJECT ,
					WhitespaceNode(parent=458,n_lines=1,current_idx=611)                     
					SingleCommentNode(parent=458,current_idx=612)// number of object types
					WhitespaceNode(parent=458,n_lines=2,current_idx=613)  
					SingleCommentNode(parent=458,current_idx=614)// meta elements ,  do not appear in mjModel
					WhitespaceNode(parent=458,n_lines=1,current_idx=615) 
					EnumFieldNode(field_name=mjOBJ_FRAME,parent=458,current_idx=616)mjOBJ_FRAME         = 100
					WhitespaceNode(parent=458,n_lines=1,current_idx=617)     
					SingleCommentNode(parent=458,current_idx=618)// frame
				}
			DeletedNode(parent=15,current_idx=0)mjtObj
		mjtObj ;
		WhitespaceNode(parent=15,n_lines=3,current_idx=620)  
		TypedefNode(parent=15,current_idx=621,typename=typedef)typedef
			EnumNode(name=mjtConstraint_,parent=621,current_idx=622)enum mjtConstraint_
				ScopeNode(parent=622,current_idx=623,scope_type=ENUM){
					WhitespaceNode(parent=623,n_lines=1,current_idx=624)   
					SingleCommentNode(parent=623,current_idx=625)// type of constraint
					WhitespaceNode(parent=623,n_lines=1,current_idx=626) 
					EnumFieldNode(field_name=mjCNSTR_EQUALITY,parent=623,current_idx=627)mjCNSTR_EQUALITY    = 0 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=628)       
					SingleCommentNode(parent=623,current_idx=629)// equality constraint
					WhitespaceNode(parent=623,n_lines=1,current_idx=630) 
					EnumFieldNode(field_name=mjCNSTR_FRICTION_DOF,parent=623,current_idx=631)mjCNSTR_FRICTION_DOF ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=632)          
					SingleCommentNode(parent=623,current_idx=633)// dof friction
					WhitespaceNode(parent=623,n_lines=1,current_idx=634) 
					EnumFieldNode(field_name=mjCNSTR_FRICTION_TENDON,parent=623,current_idx=635)mjCNSTR_FRICTION_TENDON ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=636)       
					SingleCommentNode(parent=623,current_idx=637)// tendon friction
					WhitespaceNode(parent=623,n_lines=1,current_idx=638) 
					EnumFieldNode(field_name=mjCNSTR_LIMIT_JOINT,parent=623,current_idx=639)mjCNSTR_LIMIT_JOINT ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=640)           
					SingleCommentNode(parent=623,current_idx=641)// joint limit
					WhitespaceNode(parent=623,n_lines=1,current_idx=642) 
					EnumFieldNode(field_name=mjCNSTR_LIMIT_TENDON,parent=623,current_idx=643)mjCNSTR_LIMIT_TENDON ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=644)          
					SingleCommentNode(parent=623,current_idx=645)// tendon limit
					WhitespaceNode(parent=623,n_lines=1,current_idx=646) 
					EnumFieldNode(field_name=mjCNSTR_CONTACT_FRICTIONLESS,parent=623,current_idx=647)mjCNSTR_CONTACT_FRICTIONLESS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=648)  
					SingleCommentNode(parent=623,current_idx=649)// frictionless contact
					WhitespaceNode(parent=623,n_lines=1,current_idx=650) 
					EnumFieldNode(field_name=mjCNSTR_CONTACT_PYRAMIDAL,parent=623,current_idx=651)mjCNSTR_CONTACT_PYRAMIDAL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=652)     
					SingleCommentNode(parent=623,current_idx=653)// frictional contact ,  pyramidal friction cone
					WhitespaceNode(parent=623,n_lines=1,current_idx=654) 
					EnumFieldNode(field_name=mjCNSTR_CONTACT_ELLIPTIC,parent=623,current_idx=655)mjCNSTR_CONTACT_ELLIPTIC        // frictional contact ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=656)
					EnumFieldNode(field_name=elliptic,parent=623,current_idx=657)elliptic friction cone } mjtConstraint ;    typedef enum mjtConstraintState_ {  // constraint state   mjCNSTRSTATE_SATISFIED = 0 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=658)      
					SingleCommentNode(parent=623,current_idx=659)// constraint satisfied ,  zero cost (limit ,  contact)
					WhitespaceNode(parent=623,n_lines=1,current_idx=660) 
					EnumFieldNode(field_name=mjCNSTRSTATE_QUADRATIC,parent=623,current_idx=661)mjCNSTRSTATE_QUADRATIC ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=662)          
					SingleCommentNode(parent=623,current_idx=663)// quadratic cost (equality ,  friction ,  limit ,  contact)
					WhitespaceNode(parent=623,n_lines=1,current_idx=664) 
					EnumFieldNode(field_name=mjCNSTRSTATE_LINEARNEG,parent=623,current_idx=665)mjCNSTRSTATE_LINEARNEG ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=666)          
					SingleCommentNode(parent=623,current_idx=667)// linear cost ,  negative side (friction)
					WhitespaceNode(parent=623,n_lines=1,current_idx=668) 
					EnumFieldNode(field_name=mjCNSTRSTATE_LINEARPOS,parent=623,current_idx=669)mjCNSTRSTATE_LINEARPOS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=670)          
					SingleCommentNode(parent=623,current_idx=671)// linear cost ,  positive side (friction)
					WhitespaceNode(parent=623,n_lines=1,current_idx=672) 
					EnumFieldNode(field_name=mjCNSTRSTATE_CONE,parent=623,current_idx=673)mjCNSTRSTATE_CONE                 // squared distance to cone cost (elliptic contact) } mjtConstraintState ;    typedef enum mjtSensor_ {         // type of sensor   // common robotic sensors ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=674)
					EnumFieldNode(field_name=attached,parent=623,current_idx=675)attached to a site   mjSENS_TOUCH        = 0 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=676)       
					SingleCommentNode(parent=623,current_idx=677)// scalar contact normal forces summed over sensor zone
					WhitespaceNode(parent=623,n_lines=1,current_idx=678) 
					EnumFieldNode(field_name=mjSENS_ACCELEROMETER,parent=623,current_idx=679)mjSENS_ACCELEROMETER ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=680)          
					SingleCommentNode(parent=623,current_idx=681)// 3D linear acceleration ,  in local frame
					WhitespaceNode(parent=623,n_lines=1,current_idx=682) 
					EnumFieldNode(field_name=mjSENS_VELOCIMETER,parent=623,current_idx=683)mjSENS_VELOCIMETER ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=684)            
					SingleCommentNode(parent=623,current_idx=685)// 3D linear velocity ,  in local frame
					WhitespaceNode(parent=623,n_lines=1,current_idx=686) 
					EnumFieldNode(field_name=mjSENS_GYRO,parent=623,current_idx=687)mjSENS_GYRO ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=688)                   
					SingleCommentNode(parent=623,current_idx=689)// 3D angular velocity ,  in local frame
					WhitespaceNode(parent=623,n_lines=1,current_idx=690) 
					EnumFieldNode(field_name=mjSENS_FORCE,parent=623,current_idx=691)mjSENS_FORCE ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=692)                  
					SingleCommentNode(parent=623,current_idx=693)// 3D force between site's body and its parent body
					WhitespaceNode(parent=623,n_lines=1,current_idx=694) 
					EnumFieldNode(field_name=mjSENS_TORQUE,parent=623,current_idx=695)mjSENS_TORQUE ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=696)                 
					SingleCommentNode(parent=623,current_idx=697)// 3D torque between site's body and its parent body
					WhitespaceNode(parent=623,n_lines=1,current_idx=698) 
					EnumFieldNode(field_name=mjSENS_MAGNETOMETER,parent=623,current_idx=699)mjSENS_MAGNETOMETER ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=700)           
					SingleCommentNode(parent=623,current_idx=701)// 3D magnetometer
					WhitespaceNode(parent=623,n_lines=1,current_idx=702) 
					EnumFieldNode(field_name=mjSENS_RANGEFINDER,parent=623,current_idx=703)mjSENS_RANGEFINDER ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=704)            
					SingleCommentNode(parent=623,current_idx=705)// scalar distance to nearest geom or site along z-axis
					WhitespaceNode(parent=623,n_lines=1,current_idx=706) 
					EnumFieldNode(field_name=mjSENS_CAMPROJECTION,parent=623,current_idx=707)mjSENS_CAMPROJECTION ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=708)          
					SingleCommentNode(parent=623,current_idx=709)// pixel coordinates of a site in the camera image
					WhitespaceNode(parent=623,n_lines=2,current_idx=710)  
					SingleCommentNode(parent=623,current_idx=711)// sensors related to scalar joints ,  tendons ,  actuators
					WhitespaceNode(parent=623,n_lines=1,current_idx=712) 
					EnumFieldNode(field_name=mjSENS_JOINTPOS,parent=623,current_idx=713)mjSENS_JOINTPOS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=714)               
					SingleCommentNode(parent=623,current_idx=715)// scalar joint position (hinge and slide only)
					WhitespaceNode(parent=623,n_lines=1,current_idx=716) 
					EnumFieldNode(field_name=mjSENS_JOINTVEL,parent=623,current_idx=717)mjSENS_JOINTVEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=718)               
					SingleCommentNode(parent=623,current_idx=719)// scalar joint velocity (hinge and slide only)
					WhitespaceNode(parent=623,n_lines=1,current_idx=720) 
					EnumFieldNode(field_name=mjSENS_TENDONPOS,parent=623,current_idx=721)mjSENS_TENDONPOS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=722)              
					SingleCommentNode(parent=623,current_idx=723)// scalar tendon position
					WhitespaceNode(parent=623,n_lines=1,current_idx=724) 
					EnumFieldNode(field_name=mjSENS_TENDONVEL,parent=623,current_idx=725)mjSENS_TENDONVEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=726)              
					SingleCommentNode(parent=623,current_idx=727)// scalar tendon velocity
					WhitespaceNode(parent=623,n_lines=1,current_idx=728) 
					EnumFieldNode(field_name=mjSENS_ACTUATORPOS,parent=623,current_idx=729)mjSENS_ACTUATORPOS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=730)            
					SingleCommentNode(parent=623,current_idx=731)// scalar actuator position
					WhitespaceNode(parent=623,n_lines=1,current_idx=732) 
					EnumFieldNode(field_name=mjSENS_ACTUATORVEL,parent=623,current_idx=733)mjSENS_ACTUATORVEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=734)            
					SingleCommentNode(parent=623,current_idx=735)// scalar actuator velocity
					WhitespaceNode(parent=623,n_lines=1,current_idx=736) 
					EnumFieldNode(field_name=mjSENS_ACTUATORFRC,parent=623,current_idx=737)mjSENS_ACTUATORFRC ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=738)            
					SingleCommentNode(parent=623,current_idx=739)// scalar actuator force
					WhitespaceNode(parent=623,n_lines=1,current_idx=740) 
					EnumFieldNode(field_name=mjSENS_JOINTACTFRC,parent=623,current_idx=741)mjSENS_JOINTACTFRC ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=742)            
					SingleCommentNode(parent=623,current_idx=743)// scalar actuator force ,  measured at the joint
					WhitespaceNode(parent=623,n_lines=2,current_idx=744)  
					SingleCommentNode(parent=623,current_idx=745)// sensors related to ball joints
					WhitespaceNode(parent=623,n_lines=1,current_idx=746) 
					EnumFieldNode(field_name=mjSENS_BALLQUAT,parent=623,current_idx=747)mjSENS_BALLQUAT ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=748)               
					SingleCommentNode(parent=623,current_idx=749)// 4D ball joint quaternion
					WhitespaceNode(parent=623,n_lines=1,current_idx=750) 
					EnumFieldNode(field_name=mjSENS_BALLANGVEL,parent=623,current_idx=751)mjSENS_BALLANGVEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=752)             
					SingleCommentNode(parent=623,current_idx=753)// 3D ball joint angular velocity
					WhitespaceNode(parent=623,n_lines=2,current_idx=754)  
					SingleCommentNode(parent=623,current_idx=755)// joint and tendon limit sensors ,  in constraint space
					WhitespaceNode(parent=623,n_lines=1,current_idx=756) 
					EnumFieldNode(field_name=mjSENS_JOINTLIMITPOS,parent=623,current_idx=757)mjSENS_JOINTLIMITPOS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=758)          
					SingleCommentNode(parent=623,current_idx=759)// joint limit distance-margin
					WhitespaceNode(parent=623,n_lines=1,current_idx=760) 
					EnumFieldNode(field_name=mjSENS_JOINTLIMITVEL,parent=623,current_idx=761)mjSENS_JOINTLIMITVEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=762)          
					SingleCommentNode(parent=623,current_idx=763)// joint limit velocity
					WhitespaceNode(parent=623,n_lines=1,current_idx=764) 
					EnumFieldNode(field_name=mjSENS_JOINTLIMITFRC,parent=623,current_idx=765)mjSENS_JOINTLIMITFRC ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=766)          
					SingleCommentNode(parent=623,current_idx=767)// joint limit force
					WhitespaceNode(parent=623,n_lines=1,current_idx=768) 
					EnumFieldNode(field_name=mjSENS_TENDONLIMITPOS,parent=623,current_idx=769)mjSENS_TENDONLIMITPOS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=770)         
					SingleCommentNode(parent=623,current_idx=771)// tendon limit distance-margin
					WhitespaceNode(parent=623,n_lines=1,current_idx=772) 
					EnumFieldNode(field_name=mjSENS_TENDONLIMITVEL,parent=623,current_idx=773)mjSENS_TENDONLIMITVEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=774)         
					SingleCommentNode(parent=623,current_idx=775)// tendon limit velocity
					WhitespaceNode(parent=623,n_lines=1,current_idx=776) 
					EnumFieldNode(field_name=mjSENS_TENDONLIMITFRC,parent=623,current_idx=777)mjSENS_TENDONLIMITFRC ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=778)         
					SingleCommentNode(parent=623,current_idx=779)// tendon limit force
					WhitespaceNode(parent=623,n_lines=2,current_idx=780)  
					SingleCommentNode(parent=623,current_idx=781)// sensors attached to an object with spatial frame: (x)body ,  geom ,  site ,  camera
					WhitespaceNode(parent=623,n_lines=1,current_idx=782) 
					EnumFieldNode(field_name=mjSENS_FRAMEPOS,parent=623,current_idx=783)mjSENS_FRAMEPOS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=784)               
					SingleCommentNode(parent=623,current_idx=785)// 3D position
					WhitespaceNode(parent=623,n_lines=1,current_idx=786) 
					EnumFieldNode(field_name=mjSENS_FRAMEQUAT,parent=623,current_idx=787)mjSENS_FRAMEQUAT ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=788)              
					SingleCommentNode(parent=623,current_idx=789)// 4D unit quaternion orientation
					WhitespaceNode(parent=623,n_lines=1,current_idx=790) 
					EnumFieldNode(field_name=mjSENS_FRAMEXAXIS,parent=623,current_idx=791)mjSENS_FRAMEXAXIS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=792)             
					SingleCommentNode(parent=623,current_idx=793)// 3D unit vector: x-axis of object's frame
					WhitespaceNode(parent=623,n_lines=1,current_idx=794) 
					EnumFieldNode(field_name=mjSENS_FRAMEYAXIS,parent=623,current_idx=795)mjSENS_FRAMEYAXIS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=796)             
					SingleCommentNode(parent=623,current_idx=797)// 3D unit vector: y-axis of object's frame
					WhitespaceNode(parent=623,n_lines=1,current_idx=798) 
					EnumFieldNode(field_name=mjSENS_FRAMEZAXIS,parent=623,current_idx=799)mjSENS_FRAMEZAXIS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=800)             
					SingleCommentNode(parent=623,current_idx=801)// 3D unit vector: z-axis of object's frame
					WhitespaceNode(parent=623,n_lines=1,current_idx=802) 
					EnumFieldNode(field_name=mjSENS_FRAMELINVEL,parent=623,current_idx=803)mjSENS_FRAMELINVEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=804)            
					SingleCommentNode(parent=623,current_idx=805)// 3D linear velocity
					WhitespaceNode(parent=623,n_lines=1,current_idx=806) 
					EnumFieldNode(field_name=mjSENS_FRAMEANGVEL,parent=623,current_idx=807)mjSENS_FRAMEANGVEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=808)            
					SingleCommentNode(parent=623,current_idx=809)// 3D angular velocity
					WhitespaceNode(parent=623,n_lines=1,current_idx=810) 
					EnumFieldNode(field_name=mjSENS_FRAMELINACC,parent=623,current_idx=811)mjSENS_FRAMELINACC ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=812)            
					SingleCommentNode(parent=623,current_idx=813)// 3D linear acceleration
					WhitespaceNode(parent=623,n_lines=1,current_idx=814) 
					EnumFieldNode(field_name=mjSENS_FRAMEANGACC,parent=623,current_idx=815)mjSENS_FRAMEANGACC ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=816)            
					SingleCommentNode(parent=623,current_idx=817)// 3D angular acceleration
					WhitespaceNode(parent=623,n_lines=2,current_idx=818)  
					SingleCommentNode(parent=623,current_idx=819)// sensors related to kinematic subtrees ;  attached to a body (which is the subtree root)
					WhitespaceNode(parent=623,n_lines=1,current_idx=820) 
					EnumFieldNode(field_name=mjSENS_SUBTREECOM,parent=623,current_idx=821)mjSENS_SUBTREECOM ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=822)             
					SingleCommentNode(parent=623,current_idx=823)// 3D center of mass of subtree
					WhitespaceNode(parent=623,n_lines=1,current_idx=824) 
					EnumFieldNode(field_name=mjSENS_SUBTREELINVEL,parent=623,current_idx=825)mjSENS_SUBTREELINVEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=826)          
					SingleCommentNode(parent=623,current_idx=827)// 3D linear velocity of subtree
					WhitespaceNode(parent=623,n_lines=1,current_idx=828) 
					EnumFieldNode(field_name=mjSENS_SUBTREEANGMOM,parent=623,current_idx=829)mjSENS_SUBTREEANGMOM ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=830)          
					SingleCommentNode(parent=623,current_idx=831)// 3D angular momentum of subtree
					WhitespaceNode(parent=623,n_lines=2,current_idx=832)  
					SingleCommentNode(parent=623,current_idx=833)// sensors for geometric distance ;  attached to geoms or bodies
					WhitespaceNode(parent=623,n_lines=1,current_idx=834) 
					EnumFieldNode(field_name=mjSENS_GEOMDIST,parent=623,current_idx=835)mjSENS_GEOMDIST ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=836)               
					SingleCommentNode(parent=623,current_idx=837)// signed distance between two geoms
					WhitespaceNode(parent=623,n_lines=1,current_idx=838) 
					EnumFieldNode(field_name=mjSENS_GEOMNORMAL,parent=623,current_idx=839)mjSENS_GEOMNORMAL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=840)             
					SingleCommentNode(parent=623,current_idx=841)// normal direction between two geoms
					WhitespaceNode(parent=623,n_lines=1,current_idx=842) 
					EnumFieldNode(field_name=mjSENS_GEOMFROMTO,parent=623,current_idx=843)mjSENS_GEOMFROMTO ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=844)             
					SingleCommentNode(parent=623,current_idx=845)// segment between two geoms
					WhitespaceNode(parent=623,n_lines=2,current_idx=846)  
					SingleCommentNode(parent=623,current_idx=847)// global sensors
					WhitespaceNode(parent=623,n_lines=1,current_idx=848) 
					EnumFieldNode(field_name=mjSENS_CLOCK,parent=623,current_idx=849)mjSENS_CLOCK ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=850)                  
					SingleCommentNode(parent=623,current_idx=851)// simulation time
					WhitespaceNode(parent=623,n_lines=2,current_idx=852)  
					SingleCommentNode(parent=623,current_idx=853)// plugin-controlled sensors
					WhitespaceNode(parent=623,n_lines=1,current_idx=854) 
					EnumFieldNode(field_name=mjSENS_PLUGIN,parent=623,current_idx=855)mjSENS_PLUGIN ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=856)                 
					SingleCommentNode(parent=623,current_idx=857)// plugin-controlled
					WhitespaceNode(parent=623,n_lines=2,current_idx=858)  
					SingleCommentNode(parent=623,current_idx=859)// user-defined sensor
					WhitespaceNode(parent=623,n_lines=1,current_idx=860) 
					EnumFieldNode(field_name=mjSENS_USER,parent=623,current_idx=861)mjSENS_USER                     // sensor data provided by mjcb_sensor callback } mjtSensor ;    typedef enum mjtStage_ {          // computation stage   mjSTAGE_NONE        = 0 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=862)       
					SingleCommentNode(parent=623,current_idx=863)// no computations
					WhitespaceNode(parent=623,n_lines=1,current_idx=864) 
					EnumFieldNode(field_name=mjSTAGE_POS,parent=623,current_idx=865)mjSTAGE_POS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=866)                   
					SingleCommentNode(parent=623,current_idx=867)// position-dependent computations
					WhitespaceNode(parent=623,n_lines=1,current_idx=868) 
					EnumFieldNode(field_name=mjSTAGE_VEL,parent=623,current_idx=869)mjSTAGE_VEL ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=870)                   
					SingleCommentNode(parent=623,current_idx=871)// velocity-dependent computations
					WhitespaceNode(parent=623,n_lines=1,current_idx=872) 
					EnumFieldNode(field_name=mjSTAGE_ACC,parent=623,current_idx=873)mjSTAGE_ACC                     // acceleration/force-dependent computations } mjtStage ;    typedef enum mjtDataType_ {       // data type for sensors   mjDATATYPE_REAL     = 0 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=874)       
					SingleCommentNode(parent=623,current_idx=875)// real values ,  no constraints
					WhitespaceNode(parent=623,n_lines=1,current_idx=876) 
					EnumFieldNode(field_name=mjDATATYPE_POSITIVE,parent=623,current_idx=877)mjDATATYPE_POSITIVE ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=878)           
					SingleCommentNode(parent=623,current_idx=879)// positive values ;  0 or negative: inactive
					WhitespaceNode(parent=623,n_lines=1,current_idx=880) 
					EnumFieldNode(field_name=mjDATATYPE_AXIS,parent=623,current_idx=881)mjDATATYPE_AXIS ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=882)               
					SingleCommentNode(parent=623,current_idx=883)// 3D unit vector
					WhitespaceNode(parent=623,n_lines=1,current_idx=884) 
					EnumFieldNode(field_name=mjDATATYPE_QUATERNION,parent=623,current_idx=885)mjDATATYPE_QUATERNION           // unit quaternion } mjtDataType ;    typedef enum mjtSameFrame_ {      // frame alignment of bodies with their children   mjSAMEFRAME_NONE    = 0 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=886)       
					SingleCommentNode(parent=623,current_idx=887)// no alignment
					WhitespaceNode(parent=623,n_lines=1,current_idx=888) 
					EnumFieldNode(field_name=mjSAMEFRAME_BODY,parent=623,current_idx=889)mjSAMEFRAME_BODY ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=890)              
					SingleCommentNode(parent=623,current_idx=891)// frame is same as body frame
					WhitespaceNode(parent=623,n_lines=1,current_idx=892) 
					EnumFieldNode(field_name=mjSAMEFRAME_INERTIA,parent=623,current_idx=893)mjSAMEFRAME_INERTIA ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=894)           
					SingleCommentNode(parent=623,current_idx=895)// frame is same as inertial frame
					WhitespaceNode(parent=623,n_lines=1,current_idx=896) 
					EnumFieldNode(field_name=mjSAMEFRAME_BODYROT,parent=623,current_idx=897)mjSAMEFRAME_BODYROT ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=898)           
					SingleCommentNode(parent=623,current_idx=899)// frame orientation is same as body orientation
					WhitespaceNode(parent=623,n_lines=1,current_idx=900) 
					EnumFieldNode(field_name=mjSAMEFRAME_INERTIAROT,parent=623,current_idx=901)mjSAMEFRAME_INERTIAROT          // frame orientation is same as inertia orientation } mjtSameFrame ;    typedef enum mjtLRMode_ {         // mode for actuator length range computation   mjLRMODE_NONE   = 0 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=902)           
					SingleCommentNode(parent=623,current_idx=903)// do not process any actuators
					WhitespaceNode(parent=623,n_lines=1,current_idx=904) 
					EnumFieldNode(field_name=mjLRMODE_MUSCLE,parent=623,current_idx=905)mjLRMODE_MUSCLE ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=906)               
					SingleCommentNode(parent=623,current_idx=907)// process muscle actuators
					WhitespaceNode(parent=623,n_lines=1,current_idx=908) 
					EnumFieldNode(field_name=mjLRMODE_MUSCLEUSER,parent=623,current_idx=909)mjLRMODE_MUSCLEUSER ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=910)           
					SingleCommentNode(parent=623,current_idx=911)// process muscle and user actuators
					WhitespaceNode(parent=623,n_lines=1,current_idx=912) 
					EnumFieldNode(field_name=mjLRMODE_ALL,parent=623,current_idx=913)mjLRMODE_ALL                    // process all actuators } mjtLRMode ;    typedef enum mjtFlexSelf_ {       // mode for flex selfcollide   mjFLEXSELF_NONE   = 0 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=914)         
					SingleCommentNode(parent=623,current_idx=915)// no self-collisions
					WhitespaceNode(parent=623,n_lines=1,current_idx=916) 
					EnumFieldNode(field_name=mjFLEXSELF_NARROW,parent=623,current_idx=917)mjFLEXSELF_NARROW ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=918)             
					SingleCommentNode(parent=623,current_idx=919)// skip midphase ,  go directly to narrowphase
					WhitespaceNode(parent=623,n_lines=1,current_idx=920) 
					EnumFieldNode(field_name=mjFLEXSELF_BVH,parent=623,current_idx=921)mjFLEXSELF_BVH ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=922)                
					SingleCommentNode(parent=623,current_idx=923)// use BVH in midphase (if midphase enabled)
					WhitespaceNode(parent=623,n_lines=1,current_idx=924) 
					EnumFieldNode(field_name=mjFLEXSELF_SAP,parent=623,current_idx=925)mjFLEXSELF_SAP ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=926)                
					SingleCommentNode(parent=623,current_idx=927)// use SAP in midphase
					WhitespaceNode(parent=623,n_lines=1,current_idx=928) 
					EnumFieldNode(field_name=mjFLEXSELF_AUTO,parent=623,current_idx=929)mjFLEXSELF_AUTO                 // choose between BVH and SAP automatically } mjtFlexSelf ;    //---------------------------------- mjLROpt -------------------------------------------------------  struct mjLROpt_ {                 // options for mj_setLengthRange()   // flags   int mode ;                        // which actuators to process (mjtLRMode)   int useexisting ;                 // use existing length range if available   int uselimit ;                    // use joint and tendon limits if available    // algorithm parameters   mjtNum accel ;                    // target acceleration used to compute force   mjtNum maxforce ;                 // maximum force ;  0: no limit   mjtNum timeconst ;                // time constant for velocity reduction ;  min 0.01   mjtNum timestep ;                 // simulation timestep ;  0: use mjOption.timestep   mjtNum inttotal ;                 // total simulation time interval   mjtNum interval ;                 // evaluation time interval (at the end)   mjtNum tolrange ;                 // convergence tolerance (relative to range) } ;  typedef struct mjLROpt_ mjLROpt ;    //---------------------------------- mjVFS ---------------------------------------------------------  struct mjVFS_ {                               // virtual file system for loading from memory   void* impl_ ;                                 // internal pointer to VFS memory } ;  typedef struct mjVFS_ mjVFS ;   //---------------------------------- mjOption ------------------------------------------------------  struct mjOption_ {                // physics options   // timing parameters   mjtNum timestep ;                 // timestep   mjtNum apirate ;                  // update rate for remote API (Hz)    // solver parameters   mjtNum impratio ;                 // ratio of friction-to-normal contact impedance   mjtNum tolerance ;                // main solver tolerance   mjtNum ls_tolerance ;             // CG/Newton linesearch tolerance   mjtNum noslip_tolerance ;         // noslip solver tolerance   mjtNum ccd_tolerance ;            // convex collision solver tolerance    // physical constants   mjtNum gravity[3] ;               // gravitational acceleration   mjtNum wind[3] ;                  // wind (for lift ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=930)
					EnumFieldNode(field_name=drag,parent=623,current_idx=931)drag and viscosity)   mjtNum magnetic[3] ;              // global magnetic flux   mjtNum density ;                  // density of medium   mjtNum viscosity ;                // viscosity of medium    // override contact solver parameters (if enabled)   mjtNum o_margin ;                 // margin   mjtNum o_solref[mjNREF] ;         // solref   mjtNum o_solimp[mjNIMP] ;         // solimp   mjtNum o_friction[5] ;            // friction    // discrete settings   int integrator ;                  // integration mode (mjtIntegrator)   int cone ;                        // type of friction cone (mjtCone)   int jacobian ;                    // type of Jacobian (mjtJacobian)   int solver ;                      // solver algorithm (mjtSolver)   int iterations ;                  // maximum number of main solver iterations   int ls_iterations ;               // maximum number of CG/Newton linesearch iterations   int noslip_iterations ;           // maximum number of noslip solver iterations   int ccd_iterations ;              // maximum number of convex collision solver iterations   int disableflags ;                // bit flags for disabling standard features   int enableflags ;                 // bit flags for enabling optional features   int disableactuator ;             // bit flags for disabling actuators by group id    // sdf collision settings   int sdf_initpoints ;              // number of starting points for gradient descent   int sdf_iterations ;              // max number of iterations for gradient descent } ;  typedef struct mjOption_ mjOption ;    //---------------------------------- mjVisual ------------------------------------------------------  struct mjVisual_ {                // visualization options   struct {                        // global parameters     int orthographic ;              // is the free camera orthographic (0: no ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=932)
					EnumFieldNode(field_name=1:,parent=623,current_idx=933)1: yes)     float fovy ;                    // y field-of-view of free camera (orthographic ? length : degree)     float ipd ;                     // inter-pupilary distance for free camera     float azimuth ;                 // initial azimuth of free camera (degrees)     float elevation ;               // initial elevation of free camera (degrees)     float linewidth ;               // line width for wireframe and ray rendering     float glow ;                    // glow coefficient for selected body     float realtime ;                // initial real-time factor (1: real time)     int   offwidth ;                // width of offscreen buffer     int   offheight ;               // height of offscreen buffer     int   ellipsoidinertia ;        // geom for inertia visualization (0: box ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=934)
					EnumFieldNode(field_name=1:,parent=623,current_idx=935)1: ellipsoid)     int   bvactive ;                // visualize active bounding volumes (0: no ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=936)
					EnumFieldNode(field_name=1:,parent=623,current_idx=937)1: yes)   } global ;     struct {                        // rendering quality     int   shadowsize ;              // size of shadowmap texture     int   offsamples ;              // number of multisamples for offscreen rendering     int   numslices ;               // number of slices for builtin geom drawing     int   numstacks ;               // number of stacks for builtin geom drawing     int   numquads ;                // number of quads for box rendering   } quality ;     struct {                        // head light     float ambient[3] ;              // ambient rgb (alpha=1)     float diffuse[3] ;              // diffuse rgb (alpha=1)     float specular[3] ;             // specular rgb (alpha=1)     int   active ;                  // is headlight active   } headlight ;     struct {                        // mapping     float stiffness ;               // mouse perturbation stiffness (space->force)     float stiffnessrot ;            // mouse perturbation stiffness (space->torque)     float force ;                   // from force units to space units     float torque ;                  // from torque units to space units     float alpha ;                   // scale geom alphas when transparency is enabled     float fogstart ;                // OpenGL fog starts at fogstart * mjModel.stat.extent     float fogend ;                  // OpenGL fog ends at fogend * mjModel.stat.extent     float znear ;                   // near clipping plane = znear
					EnumFieldNode(field_name=*,parent=623,current_idx=938)* mjModel.stat.extent     float zfar ;                    // far clipping plane = zfar
					EnumFieldNode(field_name=*,parent=623,current_idx=939)* mjModel.stat.extent     float haze ;                    // haze ratio     float shadowclip ;              // directional light: shadowclip * mjModel.stat.extent     float shadowscale ;             // spot light: shadowscale * light.cutoff     float actuatortendon ;          // scale tendon width   } map ;     struct {                        // scale of decor elements relative to mean body size     float forcewidth ;              // width of force arrow     float contactwidth ;            // contact width     float contactheight ;           // contact height     float connect ;                 // autoconnect capsule width     float com ;                     // com radius     float camera ;                  // camera object     float light ;                   // light object     float selectpoint ;             // selection point     float jointlength ;             // joint length     float jointwidth ;              // joint width     float actuatorlength ;          // actuator length     float actuatorwidth ;           // actuator width     float framelength ;             // bodyframe axis length     float framewidth ;              // bodyframe axis width     float constraint ;              // constraint width     float slidercrank ;             // slidercrank width     float frustum ;                 // frustum zfar plane   } scale ;     struct {                        // color of decor elements     float fog[4] ;                  // fog     float haze[4] ;                 // haze     float force[4] ;                // external force     float inertia[4] ;              // inertia box     float joint[4] ;                // joint     float actuator[4] ;             // actuator ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=940)
					EnumFieldNode(field_name=neutral,parent=623,current_idx=941)neutral     float actuatornegative[4] ;     // actuator ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=942)
					EnumFieldNode(field_name=negative,parent=623,current_idx=943)negative limit     float actuatorpositive[4] ;     // actuator ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=944)
					EnumFieldNode(field_name=positive,parent=623,current_idx=945)positive limit     float com[4] ;                  // center of mass     float camera[4] ;               // camera object     float light[4] ;                // light object     float selectpoint[4] ;          // selection point     float connect[4] ;              // auto connect     float contactpoint[4] ;         // contact point     float contactforce[4] ;         // contact force     float contactfriction[4] ;      // contact friction force     float contacttorque[4] ;        // contact torque     float contactgap[4] ;           // contact point in gap     float rangefinder[4] ;          // rangefinder ray     float constraint[4] ;           // constraint     float slidercrank[4] ;          // slidercrank     float crankbroken[4] ;          // used when crank must be stretched/broken     float frustum[4] ;              // camera frustum     float bv[4] ;                   // bounding volume     float bvactive[4] ;             // active bounding volume   } rgba ;  } ;  typedef struct mjVisual_ mjVisual ;    //---------------------------------- mjStatistic ---------------------------------------------------  struct mjStatistic_ {             // model statistics (in qpos0)   mjtNum meaninertia ;              // mean diagonal inertia   mjtNum meanmass ;                 // mean body mass   mjtNum meansize ;                 // mean body size   mjtNum extent ;                   // spatial extent   mjtNum center[3] ;                // center of model } ;  typedef struct mjStatistic_ mjStatistic ;    //---------------------------------- mjModel -------------------------------------------------------  struct mjModel_ {   // ------------------------------- sizes    // sizes needed at mjModel construction   int nq ;                          // number of generalized coordinates = dim(qpos)
					WhitespaceNode(parent=623,n_lines=1,current_idx=946) 
					BasicDataTypeNode(parent=623,current_idx=947,is_compound=False)int
					EnumFieldNode(field_name=nv,parent=623,current_idx=948)nv ;                          // number of degrees of freedom = dim(qvel)
					WhitespaceNode(parent=623,n_lines=1,current_idx=949) 
					BasicDataTypeNode(parent=623,current_idx=950,is_compound=False)int
					EnumFieldNode(field_name=nu,parent=623,current_idx=951)nu ;                          // number of actuators/controls = dim(ctrl)
					WhitespaceNode(parent=623,n_lines=1,current_idx=952) 
					BasicDataTypeNode(parent=623,current_idx=953,is_compound=False)int
					EnumFieldNode(field_name=na,parent=623,current_idx=954)na ;                          // number of activation states = dim(act)
					WhitespaceNode(parent=623,n_lines=1,current_idx=955) 
					BasicDataTypeNode(parent=623,current_idx=956,is_compound=False)int
					EnumFieldNode(field_name=nbody,parent=623,current_idx=957)nbody ;                       // number of bodies   int nbvh ;                        // number of total bounding volumes in all bodies   int nbvhstatic ;                  // number of static bounding volumes (aabb stored in mjModel)   int nbvhdynamic ;                 // number of dynamic bounding volumes (aabb stored in mjData)   int njnt ;                        // number of joints   int ngeom ;                       // number of geoms   int nsite ;                       // number of sites   int ncam ;                        // number of cameras   int nlight ;                      // number of lights   int nflex ;                       // number of flexes   int nflexvert ;                   // number of vertices in all flexes   int nflexedge ;                   // number of edges in all flexes   int nflexelem ;                   // number of elements in all flexes   int nflexelemdata ;               // number of element vertex ids in all flexes   int nflexelemedge ;               // number of element edge ids in all flexes   int nflexshelldata ;              // number of shell fragment vertex ids in all flexes   int nflexevpair ;                 // number of element-vertex pairs in all flexes   int nflextexcoord ;               // number of vertices with texture coordinates   int nmesh ;                       // number of meshes   int nmeshvert ;                   // number of vertices in all meshes   int nmeshnormal ;                 // number of normals in all meshes   int nmeshtexcoord ;               // number of texcoords in all meshes   int nmeshface ;                   // number of triangular faces in all meshes   int nmeshgraph ;                  // number of ints in mesh auxiliary data   int nskin ;                       // number of skins   int nskinvert ;                   // number of vertices in all skins   int nskintexvert ;                // number of vertiex with texcoords in all skins   int nskinface ;                   // number of triangular faces in all skins   int nskinbone ;                   // number of bones in all skins   int nskinbonevert ;               // number of vertices in all skin bones   int nhfield ;                     // number of heightfields   int nhfielddata ;                 // number of data points in all heightfields   int ntex ;                        // number of textures   int ntexdata ;                    // number of bytes in texture rgb data   int nmat ;                        // number of materials   int npair ;                       // number of predefined geom pairs   int nexclude ;                    // number of excluded geom pairs   int neq ;                         // number of equality constraints   int ntendon ;                     // number of tendons   int nwrap ;                       // number of wrap objects in all tendon paths   int nsensor ;                     // number of sensors   int nnumeric ;                    // number of numeric custom fields   int nnumericdata ;                // number of mjtNums in all numeric fields   int ntext ;                       // number of text custom fields   int ntextdata ;                   // number of mjtBytes in all text fields   int ntuple ;                      // number of tuple custom fields   int ntupledata ;                  // number of objects in all tuple fields   int nkey ;                        // number of keyframes   int nmocap ;                      // number of mocap bodies   int nplugin ;                     // number of plugin instances   int npluginattr ;                 // number of chars in all plugin config attributes   int nuser_body ;                  // number of mjtNums in body_user   int nuser_jnt ;                   // number of mjtNums in jnt_user   int nuser_geom ;                  // number of mjtNums in geom_user   int nuser_site ;                  // number of mjtNums in site_user   int nuser_cam ;                   // number of mjtNums in cam_user   int nuser_tendon ;                // number of mjtNums in tendon_user   int nuser_actuator ;              // number of mjtNums in actuator_user   int nuser_sensor ;                // number of mjtNums in sensor_user   int nnames ;                      // number of chars in all names   int nnames_map ;                  // number of slots in the names hash map   int npaths ;                      // number of chars in all paths    // sizes set after mjModel construction (only affect mjData)   int nM ;                          // number of non-zeros in sparse inertia matrix   int nB ;                          // number of non-zeros in sparse body-dof matrix   int nC ;                          // number of non-zeros in sparse reduced dof-dof matrix   int nD ;                          // number of non-zeros in sparse dof-dof matrix   int ntree ;                       // number of kinematic trees under world body   int ngravcomp ;                   // number of bodies with nonzero gravcomp   int nemax ;                       // number of potential equality-constraint rows   int njmax ;                       // number of available rows in constraint Jacobian   int nconmax ;                     // number of potential contacts in contact list   int nuserdata ;                   // number of mjtNums reserved for the user   int nsensordata ;                 // number of mjtNums in sensor data vector   int npluginstate ;                // number of mjtNums in plugin state vector    size_t narena ;                   // number of bytes in the mjData arena (inclusive of stack)   size_t nbuffer ;                  // number of bytes in buffer    // ------------------------------- options and statistics    mjOption opt ;                    // physics options   mjVisual vis ;                    // visualization options   mjStatistic stat ;                // model statistics    // ------------------------------- buffers    // main buffer   void*     buffer ;                // main buffer ;  all pointers point in it    (nbuffer)    // default generalized coordinates   mjtNum*   qpos0 ;                 // qpos values at default pose              (nq x 1)   mjtNum*   qpos_spring ;           // reference pose for springs               (nq x 1)    // bodies   int*      body_parentid ;         // id of body's parent                      (nbody x 1)   int*      body_rootid ;           // id of root above body                    (nbody x 1)   int*      body_weldid ;           // id of body that this body is welded to   (nbody x 1)   int*      body_mocapid ;          // id of mocap data ;  -1: none               (nbody x 1)   int*      body_jntnum ;           // number of joints for this body           (nbody x 1)   int*      body_jntadr ;           // start addr of joints ;  -1: no joints      (nbody x 1)   int*      body_dofnum ;           // number of motion degrees of freedom      (nbody x 1)   int*      body_dofadr ;           // start addr of dofs ;  -1: no dofs          (nbody x 1)   int*      body_treeid ;           // id of body's kinematic tree ;  -1: static  (nbody x 1)   int*      body_geomnum ;          // number of geoms                          (nbody x 1)   int*      body_geomadr ;          // start addr of geoms ;  -1: no geoms        (nbody x 1)   mjtByte*  body_simple ;           // 1: diag M ;  2: diag M ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=958)
					EnumFieldNode(field_name=sliders,parent=623,current_idx=959)sliders only       (nbody x 1)   mjtByte*  body_sameframe ;        // same frame as inertia (mjtSameframe)     (nbody x 1)   mjtNum*   body_pos ;              // position offset rel. to parent body      (nbody x 3)   mjtNum*   body_quat ;             // orientation offset rel. to parent body   (nbody x 4)   mjtNum*   body_ipos ;             // local position of center of mass         (nbody x 3)   mjtNum*   body_iquat ;            // local orientation of inertia ellipsoid   (nbody x 4)   mjtNum*   body_mass ;             // mass                                     (nbody x 1)   mjtNum*   body_subtreemass ;      // mass of subtree starting at this body    (nbody x 1)   mjtNum*   body_inertia ;          // diagonal inertia in ipos/iquat frame     (nbody x 3)   mjtNum*   body_invweight0 ;       // mean inv inert in qpos0 (trn ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=960)
					EnumFieldNode(field_name=rot),parent=623,current_idx=961)rot)       (nbody x 2)   mjtNum*   body_gravcomp ;         // antigravity force ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=962)
					EnumFieldNode(field_name=units,parent=623,current_idx=963)units of body weight  (nbody x 1)   mjtNum*   body_margin ;           // MAX over all geom margins                (nbody x 1)   mjtNum*   body_user ;             // user data                                (nbody x nuser_body)   int*      body_plugin ;           // plugin instance id ;  -1: not in use       (nbody x 1)   int*      body_contype ;          // OR over all geom contypes                (nbody x 1)   int*      body_conaffinity ;      // OR over all geom conaffinities           (nbody x 1)   int*      body_bvhadr ;           // address of bvh root                      (nbody x 1)   int*      body_bvhnum ;           // number of bounding volumes               (nbody x 1)    // bounding volume hierarchy   int*      bvh_depth ;             // depth in the bounding volume hierarchy   (nbvh x 1)   int*      bvh_child ;             // left and right children in tree          (nbvh x 2)   int*      bvh_nodeid ;            // geom or elem id of node ;  -1: non-leaf    (nbvh x 1)   mjtNum*   bvh_aabb ;              // local bounding box (center ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=964)
					EnumFieldNode(field_name=size),parent=623,current_idx=965)size)        (nbvhstatic x 6)    // joints   int*      jnt_type ;              // type of joint (mjtJoint)                 (njnt x 1)   int*      jnt_qposadr ;           // start addr in 'qpos' for joint's data    (njnt x 1)   int*      jnt_dofadr ;            // start addr in 'qvel' for joint's data    (njnt x 1)   int*      jnt_bodyid ;            // id of joint's body                       (njnt x 1)   int*      jnt_group ;             // group for visibility                     (njnt x 1)   mjtByte*  jnt_limited ;           // does joint have limits                   (njnt x 1)   mjtByte*  jnt_actfrclimited ;     // does joint have actuator force limits    (njnt x 1)   mjtByte*  jnt_actgravcomp ;       // is gravcomp force applied via actuators  (njnt x 1)   mjtNum*   jnt_solref ;            // constraint solver reference: limit       (njnt x mjNREF)   mjtNum*   jnt_solimp ;            // constraint solver impedance: limit       (njnt x mjNIMP)   mjtNum*   jnt_pos ;               // local anchor position                    (njnt x 3)   mjtNum*   jnt_axis ;              // local joint axis                         (njnt x 3)   mjtNum*   jnt_stiffness ;         // stiffness coefficient                    (njnt x 1)   mjtNum*   jnt_range ;             // joint limits                             (njnt x 2)   mjtNum*   jnt_actfrcrange ;       // range of total actuator force            (njnt x 2)   mjtNum*   jnt_margin ;            // min distance for limit detection         (njnt x 1)   mjtNum*   jnt_user ;              // user data                                (njnt x nuser_jnt)    // dofs   int*      dof_bodyid ;            // id of dof's body                         (nv x 1)   int*      dof_jntid ;             // id of dof's joint                        (nv x 1)   int*      dof_parentid ;          // id of dof's parent ;  -1: none             (nv x 1)   int*      dof_treeid ;            // id of dof's kinematic tree               (nv x 1)   int*      dof_Madr ;              // dof address in M-diagonal                (nv x 1)   int*      dof_simplenum ;         // number of consecutive simple dofs        (nv x 1)   mjtNum*   dof_solref ;            // constraint solver reference:frictionloss (nv x mjNREF)   mjtNum*   dof_solimp ;            // constraint solver impedance:frictionloss (nv x mjNIMP)   mjtNum*   dof_frictionloss ;      // dof friction loss                        (nv x 1)   mjtNum*   dof_armature ;          // dof armature inertia/mass                (nv x 1)   mjtNum*   dof_damping ;           // damping coefficient                      (nv x 1)   mjtNum*   dof_invweight0 ;        // diag. inverse inertia in qpos0           (nv x 1)   mjtNum*   dof_M0 ;                // diag. inertia in qpos0                   (nv x 1)    // geoms   int*      geom_type ;             // geometric type (mjtGeom)                 (ngeom x 1)   int*      geom_contype ;          // geom contact type                        (ngeom x 1)   int*      geom_conaffinity ;      // geom contact affinity                    (ngeom x 1)   int*      geom_condim ;           // contact dimensionality (1 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=966)
					EnumFieldNode(field_name=3,parent=623,current_idx=967)3 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=968)
					EnumFieldNode(field_name=4,parent=623,current_idx=969)4 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=970)
					EnumFieldNode(field_name=6),parent=623,current_idx=971)6)      (ngeom x 1)   int*      geom_bodyid ;           // id of geom's body                        (ngeom x 1)   int*      geom_dataid ;           // id of geom's mesh/hfield ;  -1: none       (ngeom x 1)   int*      geom_matid ;            // material id for rendering ;  -1: none      (ngeom x 1)   int*      geom_group ;            // group for visibility                     (ngeom x 1)   int*      geom_priority ;         // geom contact priority                    (ngeom x 1)   int*      geom_plugin ;           // plugin instance id ;  -1: not in use       (ngeom x 1)   mjtByte*  geom_sameframe ;        // same frame as body (mjtSameframe)        (ngeom x 1)   mjtNum*   geom_solmix ;           // mixing coef for solref/imp in geom pair  (ngeom x 1)   mjtNum*   geom_solref ;           // constraint solver reference: contact     (ngeom x mjNREF)   mjtNum*   geom_solimp ;           // constraint solver impedance: contact     (ngeom x mjNIMP)   mjtNum*   geom_size ;             // geom-specific size parameters            (ngeom x 3)   mjtNum*   geom_aabb ;             // bounding box ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=972)
					EnumFieldNode(field_name=(center,parent=623,current_idx=973)(center ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=974)
					EnumFieldNode(field_name=size),parent=623,current_idx=975)size)             (ngeom x 6)   mjtNum*   geom_rbound ;           // radius of bounding sphere                (ngeom x 1)   mjtNum*   geom_pos ;              // local position offset rel. to body       (ngeom x 3)   mjtNum*   geom_quat ;             // local orientation offset rel. to body    (ngeom x 4)   mjtNum*   geom_friction ;         // friction for (slide ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=976)
					EnumFieldNode(field_name=spin,parent=623,current_idx=977)spin ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=978)
					EnumFieldNode(field_name=roll),parent=623,current_idx=979)roll)         (ngeom x 3)   mjtNum*   geom_margin ;           // detect contact if dist<margin            (ngeom x 1)   mjtNum*   geom_gap ;              // include in solver if dist<margin-gap     (ngeom x 1)   mjtNum*   geom_fluid ;            // fluid interaction parameters             (ngeom x mjNFLUID)   mjtNum*   geom_user ;             // user data                                (ngeom x nuser_geom)   float*    geom_rgba ;             // rgba when material is omitted            (ngeom x 4)    // sites   int*      site_type ;             // geom type for rendering (mjtGeom)        (nsite x 1)   int*      site_bodyid ;           // id of site's body                        (nsite x 1)   int*      site_matid ;            // material id for rendering ;  -1: none      (nsite x 1)   int*      site_group ;            // group for visibility                     (nsite x 1)   mjtByte*  site_sameframe ;        // same frame as body (mjtSameframe)        (nsite x 1)   mjtNum*   site_size ;             // geom size for rendering                  (nsite x 3)   mjtNum*   site_pos ;              // local position offset rel. to body       (nsite x 3)   mjtNum*   site_quat ;             // local orientation offset rel. to body    (nsite x 4)   mjtNum*   site_user ;             // user data                                (nsite x nuser_site)   float*    site_rgba ;             // rgba when material is omitted            (nsite x 4)    // cameras   int*      cam_mode ;              // camera tracking mode (mjtCamLight)       (ncam x 1)   int*      cam_bodyid ;            // id of camera's body                      (ncam x 1)   int*      cam_targetbodyid ;      // id of targeted body ;  -1: none            (ncam x 1)   mjtNum*   cam_pos ;               // position rel. to body frame              (ncam x 3)   mjtNum*   cam_quat ;              // orientation rel. to body frame           (ncam x 4)   mjtNum*   cam_poscom0 ;           // global position rel. to sub-com in qpos0 (ncam x 3)   mjtNum*   cam_pos0 ;              // global position rel. to body in qpos0    (ncam x 3)   mjtNum*   cam_mat0 ;              // global orientation in qpos0              (ncam x 9)   int*      cam_orthographic ;      // orthographic camera ;  0: no ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=980)
					EnumFieldNode(field_name=1:,parent=623,current_idx=981)1: yes       (ncam x 1)   mjtNum*   cam_fovy ;              // y field-of-view (ortho ? len : deg)      (ncam x 1)   mjtNum*   cam_ipd ;               // inter-pupilary distance                  (ncam x 1)   int*      cam_resolution ;        // resolution: pixels [width ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=982)
					EnumFieldNode(field_name=height],parent=623,current_idx=983)height]       (ncam x 2)   float*    cam_sensorsize ;        // sensor size: length [width ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=984)
					EnumFieldNode(field_name=height],parent=623,current_idx=985)height]      (ncam x 2)   float*    cam_intrinsic ;         // [focal length ;  principal point]          (ncam x 4)   mjtNum*   cam_user ;              // user data                                (ncam x nuser_cam)    // lights   int*      light_mode ;            // light tracking mode (mjtCamLight)        (nlight x 1)   int*      light_bodyid ;          // id of light's body                       (nlight x 1)   int*      light_targetbodyid ;    // id of targeted body ;  -1: none            (nlight x 1)   mjtByte*  light_directional ;     // directional light                        (nlight x 1)   mjtByte*  light_castshadow ;      // does light cast shadows                  (nlight x 1)   float*    light_bulbradius ;      // light radius for soft shadows            (nlight x 1)   mjtByte*  light_active ;          // is light on                              (nlight x 1)   mjtNum*   light_pos ;             // position rel. to body frame              (nlight x 3)   mjtNum*   light_dir ;             // direction rel. to body frame             (nlight x 3)   mjtNum*   light_poscom0 ;         // global position rel. to sub-com in qpos0 (nlight x 3)   mjtNum*   light_pos0 ;            // global position rel. to body in qpos0    (nlight x 3)   mjtNum*   light_dir0 ;            // global direction in qpos0                (nlight x 3)   float*    light_attenuation ;     // OpenGL attenuation (quadratic model)     (nlight x 3)   float*    light_cutoff ;          // OpenGL cutoff                            (nlight x 1)   float*    light_exponent ;        // OpenGL exponent                          (nlight x 1)   float*    light_ambient ;         // ambient rgb (alpha=1)                    (nlight x 3)   float*    light_diffuse ;         // diffuse rgb (alpha=1)                    (nlight x 3)   float*    light_specular ;        // specular rgb (alpha=1)                   (nlight x 3)    // flexes: contact properties   int*      flex_contype ;          // flex contact type                        (nflex x 1)   int*      flex_conaffinity ;      // flex contact affinity                    (nflex x 1)   int*      flex_condim ;           // contact dimensionality (1 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=986)
					EnumFieldNode(field_name=3,parent=623,current_idx=987)3 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=988)
					EnumFieldNode(field_name=4,parent=623,current_idx=989)4 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=990)
					EnumFieldNode(field_name=6),parent=623,current_idx=991)6)      (nflex x 1)   int*      flex_priority ;         // flex contact priority                    (nflex x 1)   mjtNum*   flex_solmix ;           // mix coef for solref/imp in contact pair  (nflex x 1)   mjtNum*   flex_solref ;           // constraint solver reference: contact     (nflex x mjNREF)   mjtNum*   flex_solimp ;           // constraint solver impedance: contact     (nflex x mjNIMP)   mjtNum*   flex_friction ;         // friction for (slide ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=992)
					EnumFieldNode(field_name=spin,parent=623,current_idx=993)spin ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=994)
					EnumFieldNode(field_name=roll),parent=623,current_idx=995)roll)         (nflex x 3)   mjtNum*   flex_margin ;           // detect contact if dist<margin            (nflex x 1)   mjtNum*   flex_gap ;              // include in solver if dist<margin-gap     (nflex x 1)   mjtByte*  flex_internal ;         // internal flex collision enabled          (nflex x 1)   int*      flex_selfcollide ;      // self collision mode (mjtFlexSelf)        (nflex x 1)   int*      flex_activelayers ;     // number of active element layers ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=996)
					EnumFieldNode(field_name=3D,parent=623,current_idx=997)3D only (nflex x 1)    // flexes: other properties   int*      flex_dim ;              // 1: lines ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=998)
					EnumFieldNode(field_name=2:,parent=623,current_idx=999)2: triangles ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1000)
					EnumFieldNode(field_name=3:,parent=623,current_idx=1001)3: tetrahedra    (nflex x 1)   int*      flex_matid ;            // material id for rendering                (nflex x 1)   int*      flex_group ;            // group for visibility                     (nflex x 1)   int*      flex_vertadr ;          // first vertex address                     (nflex x 1)   int*      flex_vertnum ;          // number of vertices                       (nflex x 1)   int*      flex_edgeadr ;          // first edge address                       (nflex x 1)   int*      flex_edgenum ;          // number of edges                          (nflex x 1)   int*      flex_elemadr ;          // first element address                    (nflex x 1)   int*      flex_elemnum ;          // number of elements                       (nflex x 1)   int*      flex_elemdataadr ;      // first element vertex id address          (nflex x 1)   int*      flex_elemedgeadr ;      // first element edge id address            (nflex x 1)   int*      flex_shellnum ;         // number of shells                         (nflex x 1)   int*      flex_shelldataadr ;     // first shell data address                 (nflex x 1)   int*      flex_evpairadr ;        // first evpair address                     (nflex x 1)   int*      flex_evpairnum ;        // number of evpairs                        (nflex x 1)   int*      flex_texcoordadr ;      // address in flex_texcoord ;  -1: none       (nflex x 1)   int*      flex_vertbodyid ;       // vertex body ids                          (nflexvert x 1)   int*      flex_edge ;             // edge vertex ids (2 per edge)             (nflexedge x 2)   int*      flex_elem ;             // element vertex ids (dim+1 per elem)      (nflexelemdata x 1)   int*      flex_elemedge ;         // element edge ids                         (nflexelemedge x 1)   int*      flex_elemlayer ;        // element distance from surface ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1002)
					EnumFieldNode(field_name=3D,parent=623,current_idx=1003)3D only   (nflexelem x 1)   int*      flex_shell ;            // shell fragment vertex ids (dim per frag) (nflexshelldata x 1)   int*      flex_evpair ;           // (element ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1004)
					EnumFieldNode(field_name=vertex),parent=623,current_idx=1005)vertex) collision pairs        (nflexevpair x 2)   mjtNum*   flex_vert ;             // vertex positions in local body frames    (nflexvert x 3)   mjtNum*   flex_xvert0 ;           // Cartesian vertex positions in qpos0      (nflexvert x 3)   mjtNum*   flexedge_length0 ;      // edge lengths in qpos0                    (nflexedge x 1)   mjtNum*   flexedge_invweight0 ;   // edge inv. weight in qpos0                (nflexedge x 1)   mjtNum*   flex_radius ;           // radius around primitive element          (nflex x 1)   mjtNum*   flex_stiffness ;        // finite element stiffness matrix          (nflexelem x 21)   mjtNum*   flex_damping ;          // Rayleigh's damping coefficient           (nflex x 1)   mjtNum*   flex_edgestiffness ;    // edge stiffness                           (nflex x 1)   mjtNum*   flex_edgedamping ;      // edge damping                             (nflex x 1)   mjtByte*  flex_edgeequality ;     // is edge equality constraint defined      (nflex x 1)   mjtByte*  flex_rigid ;            // are all verices in the same body         (nflex x 1)   mjtByte*  flexedge_rigid ;        // are both edge vertices in same body      (nflexedge x 1)   mjtByte*  flex_centered ;         // are all vertex coordinates (0 ,
					EnumFieldNode(field_name=0,parent=623,current_idx=1006)0 ,
					EnumFieldNode(field_name=0),parent=623,current_idx=1007)0)       (nflex x 1)   mjtByte*  flex_flatskin ;         // render flex skin with flat shading       (nflex x 1)   int*      flex_bvhadr ;           // address of bvh root ;  -1: no bvh          (nflex x 1)   int*      flex_bvhnum ;           // number of bounding volumes               (nflex x 1)   float*    flex_rgba ;             // rgba when material is omitted            (nflex x 4)   float*    flex_texcoord ;         // vertex texture coordinates               (nflextexcoord x 2)    // meshes   int*      mesh_vertadr ;          // first vertex address                     (nmesh x 1)   int*      mesh_vertnum ;          // number of vertices                       (nmesh x 1)   int*      mesh_faceadr ;          // first face address                       (nmesh x 1)   int*      mesh_facenum ;          // number of faces                          (nmesh x 1)   int*      mesh_bvhadr ;           // address of bvh root                      (nmesh x 1)   int*      mesh_bvhnum ;           // number of bvh                            (nmesh x 1)   int*      mesh_normaladr ;        // first normal address                     (nmesh x 1)   int*      mesh_normalnum ;        // number of normals                        (nmesh x 1)   int*      mesh_texcoordadr ;      // texcoord data address ;  -1: no texcoord   (nmesh x 1)   int*      mesh_texcoordnum ;      // number of texcoord                       (nmesh x 1)   int*      mesh_graphadr ;         // graph data address ;  -1: no graph         (nmesh x 1)   float*    mesh_vert ;             // vertex positions for all meshes          (nmeshvert x 3)   float*    mesh_normal ;           // normals for all meshes                   (nmeshnormal x 3)   float*    mesh_texcoord ;         // vertex texcoords for all meshes          (nmeshtexcoord x 2)   int*      mesh_face ;             // vertex face data                         (nmeshface x 3)   int*      mesh_facenormal ;       // normal face data                         (nmeshface x 3)   int*      mesh_facetexcoord ;     // texture face data                        (nmeshface x 3)   int*      mesh_graph ;            // convex graph data                        (nmeshgraph x 1)   mjtNum*   mesh_scale ;            // scaling applied to asset vertices        (nmesh x 3)   mjtNum*   mesh_pos ;              // translation applied to asset vertices    (nmesh x 3)   mjtNum*   mesh_quat ;             // rotation applied to asset vertices       (nmesh x 4)   int*      mesh_pathadr ;          // address of asset path for mesh ;  -1: none (nmesh x 1)    // skins   int*      skin_matid ;            // skin material id ;  -1: none               (nskin x 1)   int*      skin_group ;            // group for visibility                     (nskin x 1)   float*    skin_rgba ;             // skin rgba                                (nskin x 4)   float*    skin_inflate ;          // inflate skin in normal direction         (nskin x 1)   int*      skin_vertadr ;          // first vertex address                     (nskin x 1)   int*      skin_vertnum ;          // number of vertices                       (nskin x 1)   int*      skin_texcoordadr ;      // texcoord data address ;  -1: no texcoord   (nskin x 1)   int*      skin_faceadr ;          // first face address                       (nskin x 1)   int*      skin_facenum ;          // number of faces                          (nskin x 1)   int*      skin_boneadr ;          // first bone in skin                       (nskin x 1)   int*      skin_bonenum ;          // number of bones in skin                  (nskin x 1)   float*    skin_vert ;             // vertex positions for all skin meshes     (nskinvert x 3)   float*    skin_texcoord ;         // vertex texcoords for all skin meshes     (nskintexvert x 2)   int*      skin_face ;             // triangle faces for all skin meshes       (nskinface x 3)   int*      skin_bonevertadr ;      // first vertex in each bone                (nskinbone x 1)   int*      skin_bonevertnum ;      // number of vertices in each bone          (nskinbone x 1)   float*    skin_bonebindpos ;      // bind pos of each bone                    (nskinbone x 3)   float*    skin_bonebindquat ;     // bind quat of each bone                   (nskinbone x 4)   int*      skin_bonebodyid ;       // body id of each bone                     (nskinbone x 1)   int*      skin_bonevertid ;       // mesh ids of vertices in each bone        (nskinbonevert x 1)   float*    skin_bonevertweight ;   // weights of vertices in each bone         (nskinbonevert x 1)   int*      skin_pathadr ;          // address of asset path for skin ;  -1: none (nskin x 1)    // height fields   mjtNum*   hfield_size ;           // (x ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1008)
					EnumFieldNode(field_name=y,parent=623,current_idx=1009)y ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1010)
					EnumFieldNode(field_name=z_top,parent=623,current_idx=1011)z_top ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1012)
					EnumFieldNode(field_name=z_bottom),parent=623,current_idx=1013)z_bottom)                  (nhfield x 4)   int*      hfield_nrow ;           // number of rows in grid                   (nhfield x 1)   int*      hfield_ncol ;           // number of columns in grid                (nhfield x 1)   int*      hfield_adr ;            // address in hfield_data                   (nhfield x 1)   float*    hfield_data ;           // elevation data                           (nhfielddata x 1)   int*      hfield_pathadr ;        // address of hfield asset path ;  -1: none   (nhfield x 1)    // textures   int*      tex_type ;              // texture type (mjtTexture)                (ntex x 1)   int*      tex_height ;            // number of rows in texture image          (ntex x 1)   int*      tex_width ;             // number of columns in texture image       (ntex x 1)   int*      tex_nchannel ;          // number of channels in texture image      (ntex x 1)   int*      tex_adr ;               // start address in tex_data                (ntex x 1)   mjtByte*  tex_data ;              // pixel values                             (ntexdata x 1)   int*      tex_pathadr ;           // address of texture asset path ;  -1: none  (ntex x 1)    // materials   int*      mat_texid ;             // indices of textures ;  -1: none            (nmat x mjNTEXROLE)   mjtByte*  mat_texuniform ;        // make texture cube uniform                (nmat x 1)   float*    mat_texrepeat ;         // texture repetition for 2d mapping        (nmat x 2)   float*    mat_emission ;          // emission (x rgb)                         (nmat x 1)   float*    mat_specular ;          // specular (x white)                       (nmat x 1)   float*    mat_shininess ;         // shininess coef                           (nmat x 1)   float*    mat_reflectance ;       // reflectance (0: disable)                 (nmat x 1)   float*    mat_metallic ;          // metallic coef                            (nmat x 1)   float*    mat_roughness ;         // roughness coef                           (nmat x 1)   float*    mat_rgba ;              // rgba                                     (nmat x 4)    // predefined geom pairs for collision detection ;  has precedence over exclude   int*      pair_dim ;              // contact dimensionality                   (npair x 1)   int*      pair_geom1 ;            // id of geom1                              (npair x 1)   int*      pair_geom2 ;            // id of geom2                              (npair x 1)   int*      pair_signature ;        // body1 << 16 + body2                      (npair x 1)   mjtNum*   pair_solref ;           // solver reference: contact normal         (npair x mjNREF)   mjtNum*   pair_solreffriction ;   // solver reference: contact friction       (npair x mjNREF)   mjtNum*   pair_solimp ;           // solver impedance: contact                (npair x mjNIMP)   mjtNum*   pair_margin ;           // detect contact if dist<margin            (npair x 1)   mjtNum*   pair_gap ;              // include in solver if dist<margin-gap     (npair x 1)   mjtNum*   pair_friction ;         // tangent1 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1014)
					EnumFieldNode(field_name=2,parent=623,current_idx=1015)2 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1016)
					EnumFieldNode(field_name=spin,parent=623,current_idx=1017)spin ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1018)
					EnumFieldNode(field_name=roll1,parent=623,current_idx=1019)roll1 ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1020)
					EnumFieldNode(field_name=2,parent=623,current_idx=1021)2              (npair x 5)    // excluded body pairs for collision detection   int*      exclude_signature ;     // body1 << 16 + body2                      (nexclude x 1)    // equality constraints   int*      eq_type ;               // constraint type (mjtEq)                  (neq x 1)   int*      eq_obj1id ;             // id of object 1                           (neq x 1)   int*      eq_obj2id ;             // id of object 2                           (neq x 1)   int*      eq_objtype ;            // type of both objects (mjtObj)            (neq x 1)   mjtByte*  eq_active0 ;            // initial enable/disable constraint state  (neq x 1)   mjtNum*   eq_solref ;             // constraint solver reference              (neq x mjNREF)   mjtNum*   eq_solimp ;             // constraint solver impedance              (neq x mjNIMP)   mjtNum*   eq_data ;               // numeric data for constraint              (neq x mjNEQDATA)    // tendons   int*      tendon_adr ;            // address of first object in tendon's path (ntendon x 1)   int*      tendon_num ;            // number of objects in tendon's path       (ntendon x 1)   int*      tendon_matid ;          // material id for rendering                (ntendon x 1)   int*      tendon_group ;          // group for visibility                     (ntendon x 1)   mjtByte*  tendon_limited ;        // does tendon have length limits           (ntendon x 1)   mjtNum*   tendon_width ;          // width for rendering                      (ntendon x 1)   mjtNum*   tendon_solref_lim ;     // constraint solver reference: limit       (ntendon x mjNREF)   mjtNum*   tendon_solimp_lim ;     // constraint solver impedance: limit       (ntendon x mjNIMP)   mjtNum*   tendon_solref_fri ;     // constraint solver reference: friction    (ntendon x mjNREF)   mjtNum*   tendon_solimp_fri ;     // constraint solver impedance: friction    (ntendon x mjNIMP)   mjtNum*   tendon_range ;          // tendon length limits                     (ntendon x 2)   mjtNum*   tendon_margin ;         // min distance for limit detection         (ntendon x 1)   mjtNum*   tendon_stiffness ;      // stiffness coefficient                    (ntendon x 1)   mjtNum*   tendon_damping ;        // damping coefficient                      (ntendon x 1)   mjtNum*   tendon_frictionloss ;   // loss due to friction                     (ntendon x 1)   mjtNum*   tendon_lengthspring ;   // spring resting length range              (ntendon x 2)   mjtNum*   tendon_length0 ;        // tendon length in qpos0                   (ntendon x 1)   mjtNum*   tendon_invweight0 ;     // inv. weight in qpos0                     (ntendon x 1)   mjtNum*   tendon_user ;           // user data                                (ntendon x nuser_tendon)   float*    tendon_rgba ;           // rgba when material is omitted            (ntendon x 4)    // list of all wrap objects in tendon paths   int*      wrap_type ;             // wrap object type (mjtWrap)               (nwrap x 1)   int*      wrap_objid ;            // object id: geom ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1022)
					EnumFieldNode(field_name=site,parent=623,current_idx=1023)site ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1024)
					EnumFieldNode(field_name=joint,parent=623,current_idx=1025)joint             (nwrap x 1)   mjtNum*   wrap_prm ;              // divisor ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1026)
					EnumFieldNode(field_name=joint,parent=623,current_idx=1027)joint coef ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1028)
					EnumFieldNode(field_name=or,parent=623,current_idx=1029)or site id          (nwrap x 1)    // actuators   int*      actuator_trntype ;      // transmission type (mjtTrn)               (nu x 1)   int*      actuator_dyntype ;      // dynamics type (mjtDyn)                   (nu x 1)   int*      actuator_gaintype ;     // gain type (mjtGain)                      (nu x 1)   int*      actuator_biastype ;     // bias type (mjtBias)                      (nu x 1)   int*      actuator_trnid ;        // transmission id: joint ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1030)
					EnumFieldNode(field_name=tendon,parent=623,current_idx=1031)tendon ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1032)
					EnumFieldNode(field_name=site,parent=623,current_idx=1033)site     (nu x 2)   int*      actuator_actadr ;       // first activation address ;  -1: stateless  (nu x 1)   int*      actuator_actnum ;       // number of activation variables           (nu x 1)   int*      actuator_group ;        // group for visibility                     (nu x 1)   mjtByte*  actuator_ctrllimited ;  // is control limited                       (nu x 1)   mjtByte*  actuator_forcelimited ; // is force limited                         (nu x 1)   mjtByte*  actuator_actlimited ;   // is activation limited                    (nu x 1)   mjtNum*   actuator_dynprm ;       // dynamics parameters                      (nu x mjNDYN)   mjtNum*   actuator_gainprm ;      // gain parameters                          (nu x mjNGAIN)   mjtNum*   actuator_biasprm ;      // bias parameters                          (nu x mjNBIAS)   mjtByte*  actuator_actearly ;     // step activation before force             (nu x 1)   mjtNum*   actuator_ctrlrange ;    // range of controls                        (nu x 2)   mjtNum*   actuator_forcerange ;   // range of forces                          (nu x 2)   mjtNum*   actuator_actrange ;     // range of activations                     (nu x 2)   mjtNum*   actuator_gear ;         // scale length and transmitted force       (nu x 6)   mjtNum*   actuator_cranklength ;  // crank length for slider-crank            (nu x 1)   mjtNum*   actuator_acc0 ;         // acceleration from unit force in qpos0    (nu x 1)   mjtNum*   actuator_length0 ;      // actuator length in qpos0                 (nu x 1)   mjtNum*   actuator_lengthrange ;  // feasible actuator length range           (nu x 2)   mjtNum*   actuator_user ;         // user data                                (nu x nuser_actuator)   int*      actuator_plugin ;       // plugin instance id ;  -1: not a plugin     (nu x 1)    // sensors   int*      sensor_type ;           // sensor type (mjtSensor)                  (nsensor x 1)   int*      sensor_datatype ;       // numeric data type (mjtDataType)          (nsensor x 1)   int*      sensor_needstage ;      // required compute stage (mjtStage)        (nsensor x 1)   int*      sensor_objtype ;        // type of sensorized object (mjtObj)       (nsensor x 1)   int*      sensor_objid ;          // id of sensorized object                  (nsensor x 1)   int*      sensor_reftype ;        // type of reference frame (mjtObj)         (nsensor x 1)   int*      sensor_refid ;          // id of reference frame ;  -1: global frame  (nsensor x 1)   int*      sensor_dim ;            // number of scalar outputs                 (nsensor x 1)   int*      sensor_adr ;            // address in sensor array                  (nsensor x 1)   mjtNum*   sensor_cutoff ;         // cutoff for real and positive ;  0: ignore  (nsensor x 1)   mjtNum*   sensor_noise ;          // noise standard deviation                 (nsensor x 1)   mjtNum*   sensor_user ;           // user data                                (nsensor x nuser_sensor)   int*      sensor_plugin ;         // plugin instance id ;  -1: not a plugin     (nsensor x 1)    // plugin instances   int*      plugin ;                // globally registered plugin slot number   (nplugin x 1)   int*      plugin_stateadr ;       // address in the plugin state array        (nplugin x 1)   int*      plugin_statenum ;       // number of states in the plugin instance  (nplugin x 1)   char*     plugin_attr ;           // config attributes of plugin instances    (npluginattr x 1)   int*      plugin_attradr ;        // address to each instance's config attrib (nplugin x 1)    // custom numeric fields   int*      numeric_adr ;           // address of field in numeric_data         (nnumeric x 1)   int*      numeric_size ;          // size of numeric field                    (nnumeric x 1)   mjtNum*   numeric_data ;          // array of all numeric fields              (nnumericdata x 1)    // custom text fields   int*      text_adr ;              // address of text in text_data             (ntext x 1)   int*      text_size ;             // size of text field (strlen+1)            (ntext x 1)   char*     text_data ;             // array of all text fields (0-terminated)  (ntextdata x 1)    // custom tuple fields   int*      tuple_adr ;             // address of text in text_data             (ntuple x 1)   int*      tuple_size ;            // number of objects in tuple               (ntuple x 1)   int*      tuple_objtype ;         // array of object types in all tuples      (ntupledata x 1)   int*      tuple_objid ;           // array of object ids in all tuples        (ntupledata x 1)   mjtNum*   tuple_objprm ;          // array of object params in all tuples     (ntupledata x 1)    // keyframes   mjtNum*   key_time ;              // key time                                 (nkey x 1)   mjtNum*   key_qpos ;              // key position                             (nkey x nq)   mjtNum*   key_qvel ;              // key velocity                             (nkey x nv)   mjtNum*   key_act ;               // key activation                           (nkey x na)   mjtNum*   key_mpos ;              // key mocap position                       (nkey x nmocap*3)   mjtNum*   key_mquat ;             // key mocap quaternion                     (nkey x nmocap*4)   mjtNum*   key_ctrl ;              // key control                              (nkey x nu)    // names   int*      name_bodyadr ;          // body name pointers                       (nbody x 1)   int*      name_jntadr ;           // joint name pointers                      (njnt x 1)   int*      name_geomadr ;          // geom name pointers                       (ngeom x 1)   int*      name_siteadr ;          // site name pointers                       (nsite x 1)   int*      name_camadr ;           // camera name pointers                     (ncam x 1)   int*      name_lightadr ;         // light name pointers                      (nlight x 1)   int*      name_flexadr ;          // flex name pointers                       (nflex x 1)   int*      name_meshadr ;          // mesh name pointers                       (nmesh x 1)   int*      name_skinadr ;          // skin name pointers                       (nskin x 1)   int*      name_hfieldadr ;        // hfield name pointers                     (nhfield x 1)   int*      name_texadr ;           // texture name pointers                    (ntex x 1)   int*      name_matadr ;           // material name pointers                   (nmat x 1)   int*      name_pairadr ;          // geom pair name pointers                  (npair x 1)   int*      name_excludeadr ;       // exclude name pointers                    (nexclude x 1)   int*      name_eqadr ;            // equality constraint name pointers        (neq x 1)   int*      name_tendonadr ;        // tendon name pointers                     (ntendon x 1)   int*      name_actuatoradr ;      // actuator name pointers                   (nu x 1)   int*      name_sensoradr ;        // sensor name pointers                     (nsensor x 1)   int*      name_numericadr ;       // numeric name pointers                    (nnumeric x 1)   int*      name_textadr ;          // text name pointers                       (ntext x 1)   int*      name_tupleadr ;         // tuple name pointers                      (ntuple x 1)   int*      name_keyadr ;           // keyframe name pointers                   (nkey x 1)   int*      name_pluginadr ;        // plugin instance name pointers            (nplugin x 1)   char*     names ;                 // names of all objects ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1034)
					EnumFieldNode(field_name=0-terminated,parent=623,current_idx=1035)0-terminated       (nnames x 1)   int*      names_map ;             // internal hash map of names               (nnames_map x 1)    // paths   char*     paths ;                 // paths to assets ,
					WhitespaceNode(parent=623,n_lines=1,current_idx=1036)
					EnumFieldNode(field_name=0-terminated,parent=623,current_idx=1037)0-terminated            (npaths x 1) } ;  typedef struct mjModel_ mjModel ;   #endif  // MUJOCO_MJMODEL_H_ 
		