Root(): text: /home/fastrl_mojo_user/fastrl_mojo/mujoco_mojo/mujoco/include/mujoco/mjmodel.h
	SingleLineComment(line_num=1) // Copyright 2021 DeepMind Technologies Limited 
	SingleLineComment(line_num=2) // 
	SingleLineComment(line_num=3) // Licensed under the Apache License, Version 2.0 (the "License"); 
	SingleLineComment(line_num=4) // you may not use this file except in compliance with the License. 
	SingleLineComment(line_num=5) // You may obtain a copy of the License at 
	SingleLineComment(line_num=6) // 
	SingleLineComment(line_num=7) //     http://www.apache.org/licenses/LICENSE-2.0 
	SingleLineComment(line_num=8) // 
	SingleLineComment(line_num=9) // Unless required by applicable law or agreed to in writing, software 
	SingleLineComment(line_num=10) // distributed under the License is distributed on an "AS IS" BASIS, 
	SingleLineComment(line_num=11) // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
	SingleLineComment(line_num=12) // See the License for the specific language governing permissions and 
	SingleLineComment(line_num=13) // limitations under the License. 
	BlankSpace(line_num=14)
	IfNDef(line_num=15) #ifndef MUJOCO_MJMODEL_H_ 
		Define(line_num=16) #define MUJOCO_MJMODEL_H_ 
		BlankSpace(line_num=17)
		Include(line_num=18) #include <stddef.h> 
		Include(line_num=19) #include <stdint.h> 
		BlankSpace(line_num=20)
		BlankSpace(line_num=21)
		Include(line_num=22) #include <mujoco/mjtnum.h> 
		BlankSpace(line_num=23)
		SingleLineComment(line_num=24) // global constants 
		Define(line_num=25) #define mjPI            3.14159265358979323846 
		Define(line_num=26) #define mjMAXVAL        1E+10     
		SingleLineComment(line_num=26) // maximum value in qpos, qvel, qacc 
		Define(line_num=27) #define mjMINMU         1E-5      
		SingleLineComment(line_num=27) // minimum friction coefficient 
		Define(line_num=28) #define mjMINIMP        0.0001    
		SingleLineComment(line_num=28) // minimum constraint impedance 
		Define(line_num=29) #define mjMAXIMP        0.9999    
		SingleLineComment(line_num=29) // maximum constraint impedance 
		Define(line_num=30) #define mjMAXCONPAIR    50        
		SingleLineComment(line_num=30) // maximum number of contacts per geom pair 
		Define(line_num=31) #define mjMAXTREEDEPTH  50        
		SingleLineComment(line_num=31) // maximum bounding volume hierarchy depth 
		BlankSpace(line_num=32)
		BlankSpace(line_num=33)
		SingleLineComment(line_num=34) //---------------------------------- sizes --------------------------------------------------------- 
		BlankSpace(line_num=35)
		Define(line_num=36) #define mjNEQDATA       11        
		SingleLineComment(line_num=36) // number of eq_data fields 
		Define(line_num=37) #define mjNDYN          10        
		SingleLineComment(line_num=37) // number of actuator dynamics parameters 
		Define(line_num=38) #define mjNGAIN         10        
		SingleLineComment(line_num=38) // number of actuator gain parameters 
		Define(line_num=39) #define mjNBIAS         10        
		SingleLineComment(line_num=39) // number of actuator bias parameters 
		Define(line_num=40) #define mjNFLUID        12        
		SingleLineComment(line_num=40) // number of fluid interaction parameters 
		Define(line_num=41) #define mjNREF          2         
		SingleLineComment(line_num=41) // number of solver reference parameters 
		Define(line_num=42) #define mjNIMP          5         
		SingleLineComment(line_num=42) // number of solver impedance parameters 
		Define(line_num=43) #define mjNSOLVER       200       
		SingleLineComment(line_num=43) // size of one mjData.solver array 
		Define(line_num=44) #define mjNISLAND       20        
		SingleLineComment(line_num=44) // number of mjData.solver arrays 
		BlankSpace(line_num=45)
		SingleLineComment(line_num=46) //---------------------------------- enum types (mjt) ---------------------------------------------- 
		BlankSpace(line_num=47)
		TypeDef(line_num=48) typedef enum mjtDisableBit_ {     // disable default feature bitflags   mjDSBL_CONSTRAINT   = 1<<0,     // entire constraint solver   mjDSBL_EQUALITY     = 1<<1,     // equality constraints   mjDSBL_FRICTIONLOSS = 1<<2,     // joint and tendon frictionloss constraints   mjDSBL_LIMIT        = 1<<3,     // joint and tendon limit constraints   mjDSBL_CONTACT      = 1<<4,     // contact constraints   mjDSBL_PASSIVE      = 1<<5,     // passive forces   mjDSBL_GRAVITY      = 1<<6,     // gravitational forces   mjDSBL_CLAMPCTRL    = 1<<7,     // clamp control to specified range   mjDSBL_WARMSTART    = 1<<8,     // warmstart constraint solver   mjDSBL_FILTERPARENT = 1<<9,     // remove collisions with parent body   mjDSBL_ACTUATION    = 1<<10,    // apply actuation forces   mjDSBL_REFSAFE      = 1<<11,    // integrator safety: make ref[0]>=2*timestep   mjDSBL_SENSOR       = 1<<12,    // sensors   mjDSBL_MIDPHASE     = 1<<13,    // mid-phase collision filtering   mjDSBL_EULERDAMP    = 1<<14,    // implicit integration of joint damping in Euler integrator   mjDSBL_AUTORESET    = 1<<15,    // automatic reset when numerical issues are detected    mjNDISABLE          = 16        // number of disable flags } mjtDisableBit; 
		BlankSpace(line_num=68)
		BlankSpace(line_num=69)
		TypeDef(line_num=70) typedef enum mjtEnableBit_ {      // enable optional feature bitflags   mjENBL_OVERRIDE     = 1<<0,     // override contact parameters   mjENBL_ENERGY       = 1<<1,     // energy computation   mjENBL_FWDINV       = 1<<2,     // record solver statistics   mjENBL_INVDISCRETE  = 1<<3,     // discrete-time inverse dynamics                                   // experimental features:   mjENBL_MULTICCD     = 1<<4,     // multi-point convex collision detection   mjENBL_ISLAND       = 1<<5,     // constraint island discovery   mjENBL_NATIVECCD    = 1<<6,     // native convex collision detection    mjNENABLE           = 7         // number of enable flags } mjtEnableBit; 
		BlankSpace(line_num=82)
		BlankSpace(line_num=83)
		TypeDef(line_num=84) typedef enum mjtJoint_ {          // type of degree of freedom   mjJNT_FREE          = 0,        // global position and orientation (quat)       (7)   mjJNT_BALL,                     // orientation (quat) relative to parent        (4)   mjJNT_SLIDE,                    // sliding distance along body-fixed axis       (1)   mjJNT_HINGE                     // rotation angle (rad) around body-fixed axis  (1) } mjtJoint; 
		BlankSpace(line_num=90)
		BlankSpace(line_num=91)
		TypeDef(line_num=92) typedef enum mjtGeom_ {           // type of geometric shape   // regular geom types   mjGEOM_PLANE        = 0,        // plane   mjGEOM_HFIELD,                  // height field   mjGEOM_SPHERE,                  // sphere   mjGEOM_CAPSULE,                 // capsule   mjGEOM_ELLIPSOID,               // ellipsoid   mjGEOM_CYLINDER,                // cylinder   mjGEOM_BOX,                     // box   mjGEOM_MESH,                    // mesh   mjGEOM_SDF,                     // signed distance field    mjNGEOMTYPES,                   // number of regular geom types    // rendering-only geom types: not used in mjModel, not counted in mjNGEOMTYPES   mjGEOM_ARROW        = 100,      // arrow   mjGEOM_ARROW1,                  // arrow without wedges   mjGEOM_ARROW2,                  // arrow in both directions   mjGEOM_LINE,                    // line   mjGEOM_LINEBOX,                 // box with line edges   mjGEOM_FLEX,                    // flex   mjGEOM_SKIN,                    // skin   mjGEOM_LABEL,                   // text label   mjGEOM_TRIANGLE,                // triangle    mjGEOM_NONE         = 1001      // missing geom type } mjtGeom; 
		BlankSpace(line_num=119)
		BlankSpace(line_num=120)
		TypeDef(line_num=121) typedef enum mjtCamLight_ {       // tracking mode for camera and light   mjCAMLIGHT_FIXED    = 0,        // pos and rot fixed in body   mjCAMLIGHT_TRACK,               // pos tracks body, rot fixed in global   mjCAMLIGHT_TRACKCOM,            // pos tracks subtree com, rot fixed in body   mjCAMLIGHT_TARGETBODY,          // pos fixed in body, rot tracks target body   mjCAMLIGHT_TARGETBODYCOM        // pos fixed in body, rot tracks target subtree com } mjtCamLight; 
		BlankSpace(line_num=128)
		BlankSpace(line_num=129)
		TypeDef(line_num=130) typedef enum mjtTexture_ {        // type of texture   mjTEXTURE_2D        = 0,        // 2d texture, suitable for planes and hfields   mjTEXTURE_CUBE,                 // cube texture, suitable for all other geom types   mjTEXTURE_SKYBOX                // cube texture used as skybox } mjtTexture; 
		BlankSpace(line_num=135)
		BlankSpace(line_num=136)
		TypeDef(line_num=137) typedef enum mjtTextureRole_ {    // role of texture map in rendering   mjTEXROLE_USER      = 0,        // unspecified   mjTEXROLE_RGB,                  // base color (albedo)   mjTEXROLE_OCCLUSION,            // ambient occlusion   mjTEXROLE_ROUGHNESS,            // roughness   mjTEXROLE_METALLIC,             // metallic   mjTEXROLE_NORMAL,               // normal (bump) map   mjTEXROLE_OPACITY,              // transperancy   mjTEXROLE_EMISSIVE,             // light emission   mjTEXROLE_RGBA,                 // base color, opacity   mjTEXROLE_ORM,                  // occlusion, roughness, metallic   mjNTEXROLE } mjtTextureRole; 
		BlankSpace(line_num=150)
		BlankSpace(line_num=151)
		TypeDef(line_num=152) typedef enum mjtIntegrator_ {     // integrator mode   mjINT_EULER         = 0,        // semi-implicit Euler   mjINT_RK4,                      // 4th-order Runge Kutta   mjINT_IMPLICIT,                 // implicit in velocity   mjINT_IMPLICITFAST              // implicit in velocity, no rne derivative } mjtIntegrator; 
		BlankSpace(line_num=158)
		BlankSpace(line_num=159)
		TypeDef(line_num=160) typedef enum mjtCone_ {           // type of friction cone   mjCONE_PYRAMIDAL     = 0,       // pyramidal   mjCONE_ELLIPTIC                 // elliptic } mjtCone; 
		BlankSpace(line_num=164)
		BlankSpace(line_num=165)
		TypeDef(line_num=166) typedef enum mjtJacobian_ {       // type of constraint Jacobian   mjJAC_DENSE          = 0,       // dense   mjJAC_SPARSE,                   // sparse   mjJAC_AUTO                      // dense if nv<60, sparse otherwise } mjtJacobian; 
		BlankSpace(line_num=171)
		BlankSpace(line_num=172)
		TypeDef(line_num=173) typedef enum mjtSolver_ {         // constraint solver algorithm   mjSOL_PGS            = 0,       // PGS    (dual)   mjSOL_CG,                       // CG     (primal)   mjSOL_NEWTON                    // Newton (primal) } mjtSolver; 
		BlankSpace(line_num=178)
		BlankSpace(line_num=179)
		TypeDef(line_num=180) typedef enum mjtEq_ {             // type of equality constraint   mjEQ_CONNECT        = 0,        // connect two bodies at a point (ball joint)   mjEQ_WELD,                      // fix relative position and orientation of two bodies   mjEQ_JOINT,                     // couple the values of two scalar joints with cubic   mjEQ_TENDON,                    // couple the lengths of two tendons with cubic   mjEQ_FLEX,                      // fix all edge lengths of a flex   mjEQ_DISTANCE                   // unsupported, will cause an error if used } mjtEq; 
		BlankSpace(line_num=188)
		BlankSpace(line_num=189)
		TypeDef(line_num=190) typedef enum mjtWrap_ {           // type of tendon wrap object   mjWRAP_NONE         = 0,        // null object   mjWRAP_JOINT,                   // constant moment arm   mjWRAP_PULLEY,                  // pulley used to split tendon   mjWRAP_SITE,                    // pass through site   mjWRAP_SPHERE,                  // wrap around sphere   mjWRAP_CYLINDER                 // wrap around (infinite) cylinder } mjtWrap; 
		BlankSpace(line_num=198)
		BlankSpace(line_num=199)
		TypeDef(line_num=200) typedef enum mjtTrn_ {            // type of actuator transmission   mjTRN_JOINT         = 0,        // force on joint   mjTRN_JOINTINPARENT,            // force on joint, expressed in parent frame   mjTRN_SLIDERCRANK,              // force via slider-crank linkage   mjTRN_TENDON,                   // force on tendon   mjTRN_SITE,                     // force on site   mjTRN_BODY,                     // adhesion force on a body's geoms    mjTRN_UNDEFINED     = 1000      // undefined transmission type } mjtTrn; 
		BlankSpace(line_num=210)
		BlankSpace(line_num=211)
		TypeDef(line_num=212) typedef enum mjtDyn_ {            // type of actuator dynamics   mjDYN_NONE          = 0,        // no internal dynamics; 
		PlaceHolder() ctrl
		PlaceHolder() specifies
		PlaceHolder() force
		BlankSpace(line_num=214)
		PlaceHolder() mjDYN_INTEGRATOR,
		BlankSpace(line_num=214)
		SingleLineComment(line_num=214) // integrator: da/dt = u 
		BlankSpace(line_num=215)
		PlaceHolder() mjDYN_FILTER,
		BlankSpace(line_num=215)
		SingleLineComment(line_num=215) // linear filter: da/dt = (u-a) / tau 
		BlankSpace(line_num=216)
		PlaceHolder() mjDYN_FILTEREXACT,
		BlankSpace(line_num=216)
		SingleLineComment(line_num=216) // linear filter: da/dt = (u-a) / tau, with exact integration 
		BlankSpace(line_num=217)
		PlaceHolder() mjDYN_MUSCLE,
		BlankSpace(line_num=217)
		SingleLineComment(line_num=217) // piece-wise linear filter with two time constants 
		BlankSpace(line_num=218)
		PlaceHolder() mjDYN_USER
		BlankSpace(line_num=218)
		SingleLineComment(line_num=218) // user-defined dynamics type 
		PlaceHolder() }
		PlaceHolder() mjtDyn;
		BlankSpace(line_num=220)
		BlankSpace(line_num=221)
		TypeDef(line_num=222) typedef enum mjtGain_ {           // type of actuator gain   mjGAIN_FIXED        = 0,        // fixed gain   mjGAIN_AFFINE,                  // const + kp*length + kv*velocity   mjGAIN_MUSCLE,                  // muscle FLV curve computed by mju_muscleGain()   mjGAIN_USER                     // user-defined gain type } mjtGain; 
		BlankSpace(line_num=228)
		BlankSpace(line_num=229)
		TypeDef(line_num=230) typedef enum mjtBias_ {           // type of actuator bias   mjBIAS_NONE         = 0,        // no bias   mjBIAS_AFFINE,                  // const + kp*length + kv*velocity   mjBIAS_MUSCLE,                  // muscle passive force computed by mju_muscleBias()   mjBIAS_USER                     // user-defined bias type } mjtBias; 
		BlankSpace(line_num=236)
		BlankSpace(line_num=237)
		TypeDef(line_num=238) typedef enum mjtObj_ {            // type of MujoCo object   mjOBJ_UNKNOWN       = 0,        // unknown object type   mjOBJ_BODY,                     // body   mjOBJ_XBODY,                    // body, used to access regular frame instead of i-frame   mjOBJ_JOINT,                    // joint   mjOBJ_DOF,                      // dof   mjOBJ_GEOM,                     // geom   mjOBJ_SITE,                     // site   mjOBJ_CAMERA,                   // camera   mjOBJ_LIGHT,                    // light   mjOBJ_FLEX,                     // flex   mjOBJ_MESH,                     // mesh   mjOBJ_SKIN,                     // skin   mjOBJ_HFIELD,                   // heightfield   mjOBJ_TEXTURE,                  // texture   mjOBJ_MATERIAL,                 // material for rendering   mjOBJ_PAIR,                     // geom pair to include   mjOBJ_EXCLUDE,                  // body pair to exclude   mjOBJ_EQUALITY,                 // equality constraint   mjOBJ_TENDON,                   // tendon   mjOBJ_ACTUATOR,                 // actuator   mjOBJ_SENSOR,                   // sensor   mjOBJ_NUMERIC,                  // numeric   mjOBJ_TEXT,                     // text   mjOBJ_TUPLE,                    // tuple   mjOBJ_KEY,                      // keyframe   mjOBJ_PLUGIN,                   // plugin instance    mjNOBJECT,                      // number of object types    // meta elements, do not appear in mjModel   mjOBJ_FRAME         = 100       // frame } mjtObj; 
		BlankSpace(line_num=271)
		BlankSpace(line_num=272)
		TypeDef(line_num=273) typedef enum mjtConstraint_ {     // type of constraint   mjCNSTR_EQUALITY    = 0,        // equality constraint   mjCNSTR_FRICTION_DOF,           // dof friction   mjCNSTR_FRICTION_TENDON,        // tendon friction   mjCNSTR_LIMIT_JOINT,            // joint limit   mjCNSTR_LIMIT_TENDON,           // tendon limit   mjCNSTR_CONTACT_FRICTIONLESS,   // frictionless contact   mjCNSTR_CONTACT_PYRAMIDAL,      // frictional contact, pyramidal friction cone   mjCNSTR_CONTACT_ELLIPTIC        // frictional contact, elliptic friction cone } mjtConstraint; 
		BlankSpace(line_num=283)
		BlankSpace(line_num=284)
		TypeDef(line_num=285) typedef enum mjtConstraintState_ {  // constraint state   mjCNSTRSTATE_SATISFIED = 0,       // constraint satisfied, zero cost (limit, contact)   mjCNSTRSTATE_QUADRATIC,           // quadratic cost (equality, friction, limit, contact)   mjCNSTRSTATE_LINEARNEG,           // linear cost, negative side (friction)   mjCNSTRSTATE_LINEARPOS,           // linear cost, positive side (friction)   mjCNSTRSTATE_CONE                 // squared distance to cone cost (elliptic contact) } mjtConstraintState; 
		BlankSpace(line_num=292)
		BlankSpace(line_num=293)
		TypeDef(line_num=294) typedef enum mjtSensor_ {         // type of sensor   // common robotic sensors, attached to a site   mjSENS_TOUCH        = 0,        // scalar contact normal forces summed over sensor zone   mjSENS_ACCELEROMETER,           // 3D linear acceleration, in local frame   mjSENS_VELOCIMETER,             // 3D linear velocity, in local frame   mjSENS_GYRO,                    // 3D angular velocity, in local frame   mjSENS_FORCE,                   // 3D force between site's body and its parent body   mjSENS_TORQUE,                  // 3D torque between site's body and its parent body   mjSENS_MAGNETOMETER,            // 3D magnetometer   mjSENS_RANGEFINDER,             // scalar distance to nearest geom or site along z-axis   mjSENS_CAMPROJECTION,           // pixel coordinates of a site in the camera image    // sensors related to scalar joints, tendons, actuators   mjSENS_JOINTPOS,                // scalar joint position (hinge and slide only)   mjSENS_JOINTVEL,                // scalar joint velocity (hinge and slide only)   mjSENS_TENDONPOS,               // scalar tendon position   mjSENS_TENDONVEL,               // scalar tendon velocity   mjSENS_ACTUATORPOS,             // scalar actuator position   mjSENS_ACTUATORVEL,             // scalar actuator velocity   mjSENS_ACTUATORFRC,             // scalar actuator force   mjSENS_JOINTACTFRC,             // scalar actuator force, measured at the joint    // sensors related to ball joints   mjSENS_BALLQUAT,                // 4D ball joint quaternion   mjSENS_BALLANGVEL,              // 3D ball joint angular velocity    // joint and tendon limit sensors, in constraint space   mjSENS_JOINTLIMITPOS,           // joint limit distance-margin   mjSENS_JOINTLIMITVEL,           // joint limit velocity   mjSENS_JOINTLIMITFRC,           // joint limit force   mjSENS_TENDONLIMITPOS,          // tendon limit distance-margin   mjSENS_TENDONLIMITVEL,          // tendon limit velocity   mjSENS_TENDONLIMITFRC,          // tendon limit force    // sensors attached to an object with spatial frame: (x)body, geom, site, camera   mjSENS_FRAMEPOS,                // 3D position   mjSENS_FRAMEQUAT,               // 4D unit quaternion orientation   mjSENS_FRAMEXAXIS,              // 3D unit vector: x-axis of object's frame   mjSENS_FRAMEYAXIS,              // 3D unit vector: y-axis of object's frame   mjSENS_FRAMEZAXIS,              // 3D unit vector: z-axis of object's frame   mjSENS_FRAMELINVEL,             // 3D linear velocity   mjSENS_FRAMEANGVEL,             // 3D angular velocity   mjSENS_FRAMELINACC,             // 3D linear acceleration   mjSENS_FRAMEANGACC,             // 3D angular acceleration    // sensors related to kinematic subtrees; 
		PlaceHolder() attached
		PlaceHolder() to
		PlaceHolder() a
		PlaceHolder() body
		PlaceHolder() (which
		PlaceHolder() is
		PlaceHolder() the
		PlaceHolder() subtree
		PlaceHolder() root)
		BlankSpace(line_num=340)
		PlaceHolder() mjSENS_SUBTREECOM,
		BlankSpace(line_num=340)
		SingleLineComment(line_num=340) // 3D center of mass of subtree 
		BlankSpace(line_num=341)
		PlaceHolder() mjSENS_SUBTREELINVEL,
		BlankSpace(line_num=341)
		SingleLineComment(line_num=341) // 3D linear velocity of subtree 
		BlankSpace(line_num=342)
		PlaceHolder() mjSENS_SUBTREEANGMOM,
		BlankSpace(line_num=342)
		SingleLineComment(line_num=342) // 3D angular momentum of subtree 
		BlankSpace(line_num=343)
		BlankSpace(line_num=344)
		SingleLineComment(line_num=344) // sensors for geometric distance; attached to geoms or bodies 
		BlankSpace(line_num=345)
		PlaceHolder() mjSENS_GEOMDIST,
		BlankSpace(line_num=345)
		SingleLineComment(line_num=345) // signed distance between two geoms 
		BlankSpace(line_num=346)
		PlaceHolder() mjSENS_GEOMNORMAL,
		BlankSpace(line_num=346)
		SingleLineComment(line_num=346) // normal direction between two geoms 
		BlankSpace(line_num=347)
		PlaceHolder() mjSENS_GEOMFROMTO,
		BlankSpace(line_num=347)
		SingleLineComment(line_num=347) // segment between two geoms 
		BlankSpace(line_num=348)
		BlankSpace(line_num=349)
		SingleLineComment(line_num=349) // global sensors 
		BlankSpace(line_num=350)
		PlaceHolder() mjSENS_CLOCK,
		BlankSpace(line_num=350)
		SingleLineComment(line_num=350) // simulation time 
		BlankSpace(line_num=351)
		BlankSpace(line_num=352)
		SingleLineComment(line_num=352) // plugin-controlled sensors 
		BlankSpace(line_num=353)
		PlaceHolder() mjSENS_PLUGIN,
		BlankSpace(line_num=353)
		SingleLineComment(line_num=353) // plugin-controlled 
		BlankSpace(line_num=354)
		BlankSpace(line_num=355)
		SingleLineComment(line_num=355) // user-defined sensor 
		BlankSpace(line_num=356)
		PlaceHolder() mjSENS_USER
		BlankSpace(line_num=356)
		SingleLineComment(line_num=356) // sensor data provided by mjcb_sensor callback 
		PlaceHolder() }
		PlaceHolder() mjtSensor;
		BlankSpace(line_num=358)
		BlankSpace(line_num=359)
		TypeDef(line_num=360) typedef enum mjtStage_ {          // computation stage   mjSTAGE_NONE        = 0,        // no computations   mjSTAGE_POS,                    // position-dependent computations   mjSTAGE_VEL,                    // velocity-dependent computations   mjSTAGE_ACC                     // acceleration/force-dependent computations } mjtStage; 
		BlankSpace(line_num=366)
		BlankSpace(line_num=367)
		TypeDef(line_num=368) typedef enum mjtDataType_ {       // data type for sensors   mjDATATYPE_REAL     = 0,        // real values, no constraints   mjDATATYPE_POSITIVE,            // positive values; 
		PlaceHolder() 0
		PlaceHolder() or
		PlaceHolder() negative:
		PlaceHolder() inactive
		BlankSpace(line_num=371)
		PlaceHolder() mjDATATYPE_AXIS,
		BlankSpace(line_num=371)
		SingleLineComment(line_num=371) // 3D unit vector 
		BlankSpace(line_num=372)
		PlaceHolder() mjDATATYPE_QUATERNION
		BlankSpace(line_num=372)
		SingleLineComment(line_num=372) // unit quaternion 
		PlaceHolder() }
		PlaceHolder() mjtDataType;
		BlankSpace(line_num=374)
		BlankSpace(line_num=375)
		TypeDef(line_num=376) typedef enum mjtSameFrame_ {      // frame alignment of bodies with their children   mjSAMEFRAME_NONE    = 0,        // no alignment   mjSAMEFRAME_BODY,               // frame is same as body frame   mjSAMEFRAME_INERTIA,            // frame is same as inertial frame   mjSAMEFRAME_BODYROT,            // frame orientation is same as body orientation   mjSAMEFRAME_INERTIAROT          // frame orientation is same as inertia orientation } mjtSameFrame; 
		BlankSpace(line_num=383)
		BlankSpace(line_num=384)
		TypeDef(line_num=385) typedef enum mjtLRMode_ {         // mode for actuator length range computation   mjLRMODE_NONE   = 0,            // do not process any actuators   mjLRMODE_MUSCLE,                // process muscle actuators   mjLRMODE_MUSCLEUSER,            // process muscle and user actuators   mjLRMODE_ALL                    // process all actuators } mjtLRMode; 
		BlankSpace(line_num=391)
		BlankSpace(line_num=392)
		TypeDef(line_num=393) typedef enum mjtFlexSelf_ {       // mode for flex selfcollide   mjFLEXSELF_NONE   = 0,          // no self-collisions   mjFLEXSELF_NARROW,              // skip midphase, go directly to narrowphase   mjFLEXSELF_BVH,                 // use BVH in midphase (if midphase enabled)   mjFLEXSELF_SAP,                 // use SAP in midphase   mjFLEXSELF_AUTO                 // choose between BVH and SAP automatically } mjtFlexSelf; 
		BlankSpace(line_num=400)
		BlankSpace(line_num=401)
		SingleLineComment(line_num=402) //---------------------------------- mjLROpt ------------------------------------------------------- 
		BlankSpace(line_num=403)
		PlaceHolder() struct
		PlaceHolder() mjLROpt_
		PlaceHolder() {
		BlankSpace(line_num=404)
		SingleLineComment(line_num=404) // options for mj_setLengthRange() 
		BlankSpace(line_num=405)
		SingleLineComment(line_num=405) // flags 
		BlankSpace(line_num=406)
		PlaceHolder() int
		PlaceHolder() mode;
		BlankSpace(line_num=406)
		SingleLineComment(line_num=406) // which actuators to process (mjtLRMode) 
		BlankSpace(line_num=407)
		PlaceHolder() int
		PlaceHolder() useexisting;
		BlankSpace(line_num=407)
		SingleLineComment(line_num=407) // use existing length range if available 
		BlankSpace(line_num=408)
		PlaceHolder() int
		PlaceHolder() uselimit;
		BlankSpace(line_num=408)
		SingleLineComment(line_num=408) // use joint and tendon limits if available 
		BlankSpace(line_num=409)
		BlankSpace(line_num=410)
		SingleLineComment(line_num=410) // algorithm parameters 
		BlankSpace(line_num=411)
		PlaceHolder() mjtNum
		PlaceHolder() accel;
		BlankSpace(line_num=411)
		SingleLineComment(line_num=411) // target acceleration used to compute force 
		BlankSpace(line_num=412)
		PlaceHolder() mjtNum
		PlaceHolder() maxforce;
		BlankSpace(line_num=412)
		SingleLineComment(line_num=412) // maximum force; 0: no limit 
		BlankSpace(line_num=413)
		PlaceHolder() mjtNum
		PlaceHolder() timeconst;
		BlankSpace(line_num=413)
		SingleLineComment(line_num=413) // time constant for velocity reduction; min 0.01 
		BlankSpace(line_num=414)
		PlaceHolder() mjtNum
		PlaceHolder() timestep;
		BlankSpace(line_num=414)
		SingleLineComment(line_num=414) // simulation timestep; 0: use mjOption.timestep 
		BlankSpace(line_num=415)
		PlaceHolder() mjtNum
		PlaceHolder() inttotal;
		BlankSpace(line_num=415)
		SingleLineComment(line_num=415) // total simulation time interval 
		BlankSpace(line_num=416)
		PlaceHolder() mjtNum
		PlaceHolder() interval;
		BlankSpace(line_num=416)
		SingleLineComment(line_num=416) // evaluation time interval (at the end) 
		BlankSpace(line_num=417)
		PlaceHolder() mjtNum
		PlaceHolder() tolrange;
		BlankSpace(line_num=417)
		SingleLineComment(line_num=417) // convergence tolerance (relative to range) 
		PlaceHolder() };
		TypeDef(line_num=419) typedef struct mjLROpt_ mjLROpt; 
		BlankSpace(line_num=420)
		BlankSpace(line_num=421)
		SingleLineComment(line_num=422) //---------------------------------- mjVFS --------------------------------------------------------- 
		BlankSpace(line_num=423)
		PlaceHolder() struct
		PlaceHolder() mjVFS_
		PlaceHolder() {
		BlankSpace(line_num=424)
		SingleLineComment(line_num=424) // virtual file system for loading from memory 
		BlankSpace(line_num=425)
		PlaceHolder() void*
		PlaceHolder() impl_;
		BlankSpace(line_num=425)
		SingleLineComment(line_num=425) // internal pointer to VFS memory 
		PlaceHolder() };
		TypeDef(line_num=427) typedef struct mjVFS_ mjVFS; 
		BlankSpace(line_num=428)
		SingleLineComment(line_num=429) //---------------------------------- mjOption ------------------------------------------------------ 
		BlankSpace(line_num=430)
		PlaceHolder() struct
		PlaceHolder() mjOption_
		PlaceHolder() {
		BlankSpace(line_num=431)
		SingleLineComment(line_num=431) // physics options 
		BlankSpace(line_num=432)
		SingleLineComment(line_num=432) // timing parameters 
		BlankSpace(line_num=433)
		PlaceHolder() mjtNum
		PlaceHolder() timestep;
		BlankSpace(line_num=433)
		SingleLineComment(line_num=433) // timestep 
		BlankSpace(line_num=434)
		PlaceHolder() mjtNum
		PlaceHolder() apirate;
		BlankSpace(line_num=434)
		SingleLineComment(line_num=434) // update rate for remote API (Hz) 
		BlankSpace(line_num=435)
		BlankSpace(line_num=436)
		SingleLineComment(line_num=436) // solver parameters 
		BlankSpace(line_num=437)
		PlaceHolder() mjtNum
		PlaceHolder() impratio;
		BlankSpace(line_num=437)
		SingleLineComment(line_num=437) // ratio of friction-to-normal contact impedance 
		BlankSpace(line_num=438)
		PlaceHolder() mjtNum
		PlaceHolder() tolerance;
		BlankSpace(line_num=438)
		SingleLineComment(line_num=438) // main solver tolerance 
		BlankSpace(line_num=439)
		PlaceHolder() mjtNum
		PlaceHolder() ls_tolerance;
		BlankSpace(line_num=439)
		SingleLineComment(line_num=439) // CG/Newton linesearch tolerance 
		BlankSpace(line_num=440)
		PlaceHolder() mjtNum
		PlaceHolder() noslip_tolerance;
		BlankSpace(line_num=440)
		SingleLineComment(line_num=440) // noslip solver tolerance 
		BlankSpace(line_num=441)
		PlaceHolder() mjtNum
		PlaceHolder() ccd_tolerance;
		BlankSpace(line_num=441)
		SingleLineComment(line_num=441) // convex collision solver tolerance 
		BlankSpace(line_num=442)
		BlankSpace(line_num=443)
		SingleLineComment(line_num=443) // physical constants 
		BlankSpace(line_num=444)
		PlaceHolder() mjtNum
		PlaceHolder() gravity[3];
		BlankSpace(line_num=444)
		SingleLineComment(line_num=444) // gravitational acceleration 
		BlankSpace(line_num=445)
		PlaceHolder() mjtNum
		PlaceHolder() wind[3];
		BlankSpace(line_num=445)
		SingleLineComment(line_num=445) // wind (for lift, drag and viscosity) 
		BlankSpace(line_num=446)
		PlaceHolder() mjtNum
		PlaceHolder() magnetic[3];
		BlankSpace(line_num=446)
		SingleLineComment(line_num=446) // global magnetic flux 
		BlankSpace(line_num=447)
		PlaceHolder() mjtNum
		PlaceHolder() density;
		BlankSpace(line_num=447)
		SingleLineComment(line_num=447) // density of medium 
		BlankSpace(line_num=448)
		PlaceHolder() mjtNum
		PlaceHolder() viscosity;
		BlankSpace(line_num=448)
		SingleLineComment(line_num=448) // viscosity of medium 
		BlankSpace(line_num=449)
		BlankSpace(line_num=450)
		SingleLineComment(line_num=450) // override contact solver parameters (if enabled) 
		BlankSpace(line_num=451)
		PlaceHolder() mjtNum
		PlaceHolder() o_margin;
		BlankSpace(line_num=451)
		SingleLineComment(line_num=451) // margin 
		BlankSpace(line_num=452)
		PlaceHolder() mjtNum
		PlaceHolder() o_solref[mjNREF];
		BlankSpace(line_num=452)
		SingleLineComment(line_num=452) // solref 
		BlankSpace(line_num=453)
		PlaceHolder() mjtNum
		PlaceHolder() o_solimp[mjNIMP];
		BlankSpace(line_num=453)
		SingleLineComment(line_num=453) // solimp 
		BlankSpace(line_num=454)
		PlaceHolder() mjtNum
		PlaceHolder() o_friction[5];
		BlankSpace(line_num=454)
		SingleLineComment(line_num=454) // friction 
		BlankSpace(line_num=455)
		BlankSpace(line_num=456)
		SingleLineComment(line_num=456) // discrete settings 
		BlankSpace(line_num=457)
		PlaceHolder() int
		PlaceHolder() integrator;
		BlankSpace(line_num=457)
		SingleLineComment(line_num=457) // integration mode (mjtIntegrator) 
		BlankSpace(line_num=458)
		PlaceHolder() int
		PlaceHolder() cone;
		BlankSpace(line_num=458)
		SingleLineComment(line_num=458) // type of friction cone (mjtCone) 
		BlankSpace(line_num=459)
		PlaceHolder() int
		PlaceHolder() jacobian;
		BlankSpace(line_num=459)
		SingleLineComment(line_num=459) // type of Jacobian (mjtJacobian) 
		BlankSpace(line_num=460)
		PlaceHolder() int
		PlaceHolder() solver;
		BlankSpace(line_num=460)
		SingleLineComment(line_num=460) // solver algorithm (mjtSolver) 
		BlankSpace(line_num=461)
		PlaceHolder() int
		PlaceHolder() iterations;
		BlankSpace(line_num=461)
		SingleLineComment(line_num=461) // maximum number of main solver iterations 
		BlankSpace(line_num=462)
		PlaceHolder() int
		PlaceHolder() ls_iterations;
		BlankSpace(line_num=462)
		SingleLineComment(line_num=462) // maximum number of CG/Newton linesearch iterations 
		BlankSpace(line_num=463)
		PlaceHolder() int
		PlaceHolder() noslip_iterations;
		BlankSpace(line_num=463)
		SingleLineComment(line_num=463) // maximum number of noslip solver iterations 
		BlankSpace(line_num=464)
		PlaceHolder() int
		PlaceHolder() ccd_iterations;
		BlankSpace(line_num=464)
		SingleLineComment(line_num=464) // maximum number of convex collision solver iterations 
		BlankSpace(line_num=465)
		PlaceHolder() int
		PlaceHolder() disableflags;
		BlankSpace(line_num=465)
		SingleLineComment(line_num=465) // bit flags for disabling standard features 
		BlankSpace(line_num=466)
		PlaceHolder() int
		PlaceHolder() enableflags;
		BlankSpace(line_num=466)
		SingleLineComment(line_num=466) // bit flags for enabling optional features 
		BlankSpace(line_num=467)
		PlaceHolder() int
		PlaceHolder() disableactuator;
		BlankSpace(line_num=467)
		SingleLineComment(line_num=467) // bit flags for disabling actuators by group id 
		BlankSpace(line_num=468)
		BlankSpace(line_num=469)
		SingleLineComment(line_num=469) // sdf collision settings 
		BlankSpace(line_num=470)
		PlaceHolder() int
		PlaceHolder() sdf_initpoints;
		BlankSpace(line_num=470)
		SingleLineComment(line_num=470) // number of starting points for gradient descent 
		BlankSpace(line_num=471)
		PlaceHolder() int
		PlaceHolder() sdf_iterations;
		BlankSpace(line_num=471)
		SingleLineComment(line_num=471) // max number of iterations for gradient descent 
		PlaceHolder() };
		TypeDef(line_num=473) typedef struct mjOption_ mjOption; 
		BlankSpace(line_num=474)
		BlankSpace(line_num=475)
		SingleLineComment(line_num=476) //---------------------------------- mjVisual ------------------------------------------------------ 
		BlankSpace(line_num=477)
		PlaceHolder() struct
		PlaceHolder() mjVisual_
		PlaceHolder() {
		BlankSpace(line_num=478)
		SingleLineComment(line_num=478) // visualization options 
		BlankSpace(line_num=479)
		PlaceHolder() struct
		PlaceHolder() {
		BlankSpace(line_num=479)
		SingleLineComment(line_num=479) // global parameters 
		BlankSpace(line_num=480)
		PlaceHolder() int
		PlaceHolder() orthographic;
		BlankSpace(line_num=480)
		SingleLineComment(line_num=480) // is the free camera orthographic (0: no, 1: yes) 
		BlankSpace(line_num=481)
		PlaceHolder() float
		PlaceHolder() fovy;
		BlankSpace(line_num=481)
		SingleLineComment(line_num=481) // y field-of-view of free camera (orthographic ? length : degree) 
		BlankSpace(line_num=482)
		PlaceHolder() float
		PlaceHolder() ipd;
		BlankSpace(line_num=482)
		SingleLineComment(line_num=482) // inter-pupilary distance for free camera 
		BlankSpace(line_num=483)
		PlaceHolder() float
		PlaceHolder() azimuth;
		BlankSpace(line_num=483)
		SingleLineComment(line_num=483) // initial azimuth of free camera (degrees) 
		BlankSpace(line_num=484)
		PlaceHolder() float
		PlaceHolder() elevation;
		BlankSpace(line_num=484)
		SingleLineComment(line_num=484) // initial elevation of free camera (degrees) 
		BlankSpace(line_num=485)
		PlaceHolder() float
		PlaceHolder() linewidth;
		BlankSpace(line_num=485)
		SingleLineComment(line_num=485) // line width for wireframe and ray rendering 
		BlankSpace(line_num=486)
		PlaceHolder() float
		PlaceHolder() glow;
		BlankSpace(line_num=486)
		SingleLineComment(line_num=486) // glow coefficient for selected body 
		BlankSpace(line_num=487)
		PlaceHolder() float
		PlaceHolder() realtime;
		BlankSpace(line_num=487)
		SingleLineComment(line_num=487) // initial real-time factor (1: real time) 
		BlankSpace(line_num=488)
		PlaceHolder() int
		BlankSpace(line_num=488)
		PlaceHolder() offwidth;
		BlankSpace(line_num=488)
		SingleLineComment(line_num=488) // width of offscreen buffer 
		BlankSpace(line_num=489)
		PlaceHolder() int
		BlankSpace(line_num=489)
		PlaceHolder() offheight;
		BlankSpace(line_num=489)
		SingleLineComment(line_num=489) // height of offscreen buffer 
		BlankSpace(line_num=490)
		PlaceHolder() int
		BlankSpace(line_num=490)
		PlaceHolder() ellipsoidinertia;
		BlankSpace(line_num=490)
		SingleLineComment(line_num=490) // geom for inertia visualization (0: box, 1: ellipsoid) 
		BlankSpace(line_num=491)
		PlaceHolder() int
		BlankSpace(line_num=491)
		PlaceHolder() bvactive;
		BlankSpace(line_num=491)
		SingleLineComment(line_num=491) // visualize active bounding volumes (0: no, 1: yes) 
		BlankSpace(line_num=492)
		PlaceHolder() }
		PlaceHolder() global;
		BlankSpace(line_num=493)
		BlankSpace(line_num=494)
		PlaceHolder() struct
		PlaceHolder() {
		BlankSpace(line_num=494)
		SingleLineComment(line_num=494) // rendering quality 
		BlankSpace(line_num=495)
		PlaceHolder() int
		BlankSpace(line_num=495)
		PlaceHolder() shadowsize;
		BlankSpace(line_num=495)
		SingleLineComment(line_num=495) // size of shadowmap texture 
		BlankSpace(line_num=496)
		PlaceHolder() int
		BlankSpace(line_num=496)
		PlaceHolder() offsamples;
		BlankSpace(line_num=496)
		SingleLineComment(line_num=496) // number of multisamples for offscreen rendering 
		BlankSpace(line_num=497)
		PlaceHolder() int
		BlankSpace(line_num=497)
		PlaceHolder() numslices;
		BlankSpace(line_num=497)
		SingleLineComment(line_num=497) // number of slices for builtin geom drawing 
		BlankSpace(line_num=498)
		PlaceHolder() int
		BlankSpace(line_num=498)
		PlaceHolder() numstacks;
		BlankSpace(line_num=498)
		SingleLineComment(line_num=498) // number of stacks for builtin geom drawing 
		BlankSpace(line_num=499)
		PlaceHolder() int
		BlankSpace(line_num=499)
		PlaceHolder() numquads;
		BlankSpace(line_num=499)
		SingleLineComment(line_num=499) // number of quads for box rendering 
		BlankSpace(line_num=500)
		PlaceHolder() }
		PlaceHolder() quality;
		BlankSpace(line_num=501)
		BlankSpace(line_num=502)
		PlaceHolder() struct
		PlaceHolder() {
		BlankSpace(line_num=502)
		SingleLineComment(line_num=502) // head light 
		BlankSpace(line_num=503)
		PlaceHolder() float
		PlaceHolder() ambient[3];
		BlankSpace(line_num=503)
		SingleLineComment(line_num=503) // ambient rgb (alpha=1) 
		BlankSpace(line_num=504)
		PlaceHolder() float
		PlaceHolder() diffuse[3];
		BlankSpace(line_num=504)
		SingleLineComment(line_num=504) // diffuse rgb (alpha=1) 
		BlankSpace(line_num=505)
		PlaceHolder() float
		PlaceHolder() specular[3];
		BlankSpace(line_num=505)
		SingleLineComment(line_num=505) // specular rgb (alpha=1) 
		BlankSpace(line_num=506)
		PlaceHolder() int
		BlankSpace(line_num=506)
		PlaceHolder() active;
		BlankSpace(line_num=506)
		SingleLineComment(line_num=506) // is headlight active 
		BlankSpace(line_num=507)
		PlaceHolder() }
		PlaceHolder() headlight;
		BlankSpace(line_num=508)
		BlankSpace(line_num=509)
		PlaceHolder() struct
		PlaceHolder() {
		BlankSpace(line_num=509)
		SingleLineComment(line_num=509) // mapping 
		BlankSpace(line_num=510)
		PlaceHolder() float
		PlaceHolder() stiffness;
		BlankSpace(line_num=510)
		SingleLineComment(line_num=510) // mouse perturbation stiffness (space->force) 
		BlankSpace(line_num=511)
		PlaceHolder() float
		PlaceHolder() stiffnessrot;
		BlankSpace(line_num=511)
		SingleLineComment(line_num=511) // mouse perturbation stiffness (space->torque) 
		BlankSpace(line_num=512)
		PlaceHolder() float
		PlaceHolder() force;
		BlankSpace(line_num=512)
		SingleLineComment(line_num=512) // from force units to space units 
		BlankSpace(line_num=513)
		PlaceHolder() float
		PlaceHolder() torque;
		BlankSpace(line_num=513)
		SingleLineComment(line_num=513) // from torque units to space units 
		BlankSpace(line_num=514)
		PlaceHolder() float
		PlaceHolder() alpha;
		BlankSpace(line_num=514)
		SingleLineComment(line_num=514) // scale geom alphas when transparency is enabled 
		BlankSpace(line_num=515)
		PlaceHolder() float
		PlaceHolder() fogstart;
		BlankSpace(line_num=515)
		SingleLineComment(line_num=515) // OpenGL fog starts at fogstart * mjModel.stat.extent 
		BlankSpace(line_num=516)
		PlaceHolder() float
		PlaceHolder() fogend;
		BlankSpace(line_num=516)
		SingleLineComment(line_num=516) // OpenGL fog ends at fogend * mjModel.stat.extent 
		BlankSpace(line_num=517)
		PlaceHolder() float
		PlaceHolder() znear;
		BlankSpace(line_num=517)
		SingleLineComment(line_num=517) // near clipping plane = znear * mjModel.stat.extent 
		BlankSpace(line_num=518)
		PlaceHolder() float
		PlaceHolder() zfar;
		BlankSpace(line_num=518)
		SingleLineComment(line_num=518) // far clipping plane = zfar * mjModel.stat.extent 
		BlankSpace(line_num=519)
		PlaceHolder() float
		PlaceHolder() haze;
		BlankSpace(line_num=519)
		SingleLineComment(line_num=519) // haze ratio 
		BlankSpace(line_num=520)
		PlaceHolder() float
		PlaceHolder() shadowclip;
		BlankSpace(line_num=520)
		SingleLineComment(line_num=520) // directional light: shadowclip * mjModel.stat.extent 
		BlankSpace(line_num=521)
		PlaceHolder() float
		PlaceHolder() shadowscale;
		BlankSpace(line_num=521)
		SingleLineComment(line_num=521) // spot light: shadowscale * light.cutoff 
		BlankSpace(line_num=522)
		PlaceHolder() float
		PlaceHolder() actuatortendon;
		BlankSpace(line_num=522)
		SingleLineComment(line_num=522) // scale tendon width 
		BlankSpace(line_num=523)
		PlaceHolder() }
		PlaceHolder() map;
		BlankSpace(line_num=524)
		BlankSpace(line_num=525)
		PlaceHolder() struct
		PlaceHolder() {
		BlankSpace(line_num=525)
		SingleLineComment(line_num=525) // scale of decor elements relative to mean body size 
		BlankSpace(line_num=526)
		PlaceHolder() float
		PlaceHolder() forcewidth;
		BlankSpace(line_num=526)
		SingleLineComment(line_num=526) // width of force arrow 
		BlankSpace(line_num=527)
		PlaceHolder() float
		PlaceHolder() contactwidth;
		BlankSpace(line_num=527)
		SingleLineComment(line_num=527) // contact width 
		BlankSpace(line_num=528)
		PlaceHolder() float
		PlaceHolder() contactheight;
		BlankSpace(line_num=528)
		SingleLineComment(line_num=528) // contact height 
		BlankSpace(line_num=529)
		PlaceHolder() float
		PlaceHolder() connect;
		BlankSpace(line_num=529)
		SingleLineComment(line_num=529) // autoconnect capsule width 
		BlankSpace(line_num=530)
		PlaceHolder() float
		PlaceHolder() com;
		BlankSpace(line_num=530)
		SingleLineComment(line_num=530) // com radius 
		BlankSpace(line_num=531)
		PlaceHolder() float
		PlaceHolder() camera;
		BlankSpace(line_num=531)
		SingleLineComment(line_num=531) // camera object 
		BlankSpace(line_num=532)
		PlaceHolder() float
		PlaceHolder() light;
		BlankSpace(line_num=532)
		SingleLineComment(line_num=532) // light object 
		BlankSpace(line_num=533)
		PlaceHolder() float
		PlaceHolder() selectpoint;
		BlankSpace(line_num=533)
		SingleLineComment(line_num=533) // selection point 
		BlankSpace(line_num=534)
		PlaceHolder() float
		PlaceHolder() jointlength;
		BlankSpace(line_num=534)
		SingleLineComment(line_num=534) // joint length 
		BlankSpace(line_num=535)
		PlaceHolder() float
		PlaceHolder() jointwidth;
		BlankSpace(line_num=535)
		SingleLineComment(line_num=535) // joint width 
		BlankSpace(line_num=536)
		PlaceHolder() float
		PlaceHolder() actuatorlength;
		BlankSpace(line_num=536)
		SingleLineComment(line_num=536) // actuator length 
		BlankSpace(line_num=537)
		PlaceHolder() float
		PlaceHolder() actuatorwidth;
		BlankSpace(line_num=537)
		SingleLineComment(line_num=537) // actuator width 
		BlankSpace(line_num=538)
		PlaceHolder() float
		PlaceHolder() framelength;
		BlankSpace(line_num=538)
		SingleLineComment(line_num=538) // bodyframe axis length 
		BlankSpace(line_num=539)
		PlaceHolder() float
		PlaceHolder() framewidth;
		BlankSpace(line_num=539)
		SingleLineComment(line_num=539) // bodyframe axis width 
		BlankSpace(line_num=540)
		PlaceHolder() float
		PlaceHolder() constraint;
		BlankSpace(line_num=540)
		SingleLineComment(line_num=540) // constraint width 
		BlankSpace(line_num=541)
		PlaceHolder() float
		PlaceHolder() slidercrank;
		BlankSpace(line_num=541)
		SingleLineComment(line_num=541) // slidercrank width 
		BlankSpace(line_num=542)
		PlaceHolder() float
		PlaceHolder() frustum;
		BlankSpace(line_num=542)
		SingleLineComment(line_num=542) // frustum zfar plane 
		BlankSpace(line_num=543)
		PlaceHolder() }
		PlaceHolder() scale;
		BlankSpace(line_num=544)
		BlankSpace(line_num=545)
		PlaceHolder() struct
		PlaceHolder() {
		BlankSpace(line_num=545)
		SingleLineComment(line_num=545) // color of decor elements 
		BlankSpace(line_num=546)
		PlaceHolder() float
		PlaceHolder() fog[4];
		BlankSpace(line_num=546)
		SingleLineComment(line_num=546) // fog 
		BlankSpace(line_num=547)
		PlaceHolder() float
		PlaceHolder() haze[4];
		BlankSpace(line_num=547)
		SingleLineComment(line_num=547) // haze 
		BlankSpace(line_num=548)
		PlaceHolder() float
		PlaceHolder() force[4];
		BlankSpace(line_num=548)
		SingleLineComment(line_num=548) // external force 
		BlankSpace(line_num=549)
		PlaceHolder() float
		PlaceHolder() inertia[4];
		BlankSpace(line_num=549)
		SingleLineComment(line_num=549) // inertia box 
		BlankSpace(line_num=550)
		PlaceHolder() float
		PlaceHolder() joint[4];
		BlankSpace(line_num=550)
		SingleLineComment(line_num=550) // joint 
		BlankSpace(line_num=551)
		PlaceHolder() float
		PlaceHolder() actuator[4];
		BlankSpace(line_num=551)
		SingleLineComment(line_num=551) // actuator, neutral 
		BlankSpace(line_num=552)
		PlaceHolder() float
		PlaceHolder() actuatornegative[4];
		BlankSpace(line_num=552)
		SingleLineComment(line_num=552) // actuator, negative limit 
		BlankSpace(line_num=553)
		PlaceHolder() float
		PlaceHolder() actuatorpositive[4];
		BlankSpace(line_num=553)
		SingleLineComment(line_num=553) // actuator, positive limit 
		BlankSpace(line_num=554)
		PlaceHolder() float
		PlaceHolder() com[4];
		BlankSpace(line_num=554)
		SingleLineComment(line_num=554) // center of mass 
		BlankSpace(line_num=555)
		PlaceHolder() float
		PlaceHolder() camera[4];
		BlankSpace(line_num=555)
		SingleLineComment(line_num=555) // camera object 
		BlankSpace(line_num=556)
		PlaceHolder() float
		PlaceHolder() light[4];
		BlankSpace(line_num=556)
		SingleLineComment(line_num=556) // light object 
		BlankSpace(line_num=557)
		PlaceHolder() float
		PlaceHolder() selectpoint[4];
		BlankSpace(line_num=557)
		SingleLineComment(line_num=557) // selection point 
		BlankSpace(line_num=558)
		PlaceHolder() float
		PlaceHolder() connect[4];
		BlankSpace(line_num=558)
		SingleLineComment(line_num=558) // auto connect 
		BlankSpace(line_num=559)
		PlaceHolder() float
		PlaceHolder() contactpoint[4];
		BlankSpace(line_num=559)
		SingleLineComment(line_num=559) // contact point 
		BlankSpace(line_num=560)
		PlaceHolder() float
		PlaceHolder() contactforce[4];
		BlankSpace(line_num=560)
		SingleLineComment(line_num=560) // contact force 
		BlankSpace(line_num=561)
		PlaceHolder() float
		PlaceHolder() contactfriction[4];
		BlankSpace(line_num=561)
		SingleLineComment(line_num=561) // contact friction force 
		BlankSpace(line_num=562)
		PlaceHolder() float
		PlaceHolder() contacttorque[4];
		BlankSpace(line_num=562)
		SingleLineComment(line_num=562) // contact torque 
		BlankSpace(line_num=563)
		PlaceHolder() float
		PlaceHolder() contactgap[4];
		BlankSpace(line_num=563)
		SingleLineComment(line_num=563) // contact point in gap 
		BlankSpace(line_num=564)
		PlaceHolder() float
		PlaceHolder() rangefinder[4];
		BlankSpace(line_num=564)
		SingleLineComment(line_num=564) // rangefinder ray 
		BlankSpace(line_num=565)
		PlaceHolder() float
		PlaceHolder() constraint[4];
		BlankSpace(line_num=565)
		SingleLineComment(line_num=565) // constraint 
		BlankSpace(line_num=566)
		PlaceHolder() float
		PlaceHolder() slidercrank[4];
		BlankSpace(line_num=566)
		SingleLineComment(line_num=566) // slidercrank 
		BlankSpace(line_num=567)
		PlaceHolder() float
		PlaceHolder() crankbroken[4];
		BlankSpace(line_num=567)
		SingleLineComment(line_num=567) // used when crank must be stretched/broken 
		BlankSpace(line_num=568)
		PlaceHolder() float
		PlaceHolder() frustum[4];
		BlankSpace(line_num=568)
		SingleLineComment(line_num=568) // camera frustum 
		BlankSpace(line_num=569)
		PlaceHolder() float
		PlaceHolder() bv[4];
		BlankSpace(line_num=569)
		SingleLineComment(line_num=569) // bounding volume 
		BlankSpace(line_num=570)
		PlaceHolder() float
		PlaceHolder() bvactive[4];
		BlankSpace(line_num=570)
		SingleLineComment(line_num=570) // active bounding volume 
		BlankSpace(line_num=571)
		PlaceHolder() }
		PlaceHolder() rgba;
		PlaceHolder() };
		TypeDef(line_num=573) typedef struct mjVisual_ mjVisual; 
		BlankSpace(line_num=574)
		BlankSpace(line_num=575)
		SingleLineComment(line_num=576) //---------------------------------- mjStatistic --------------------------------------------------- 
		BlankSpace(line_num=577)
		PlaceHolder() struct
		PlaceHolder() mjStatistic_
		PlaceHolder() {
		BlankSpace(line_num=578)
		SingleLineComment(line_num=578) // model statistics (in qpos0) 
		BlankSpace(line_num=579)
		PlaceHolder() mjtNum
		PlaceHolder() meaninertia;
		BlankSpace(line_num=579)
		SingleLineComment(line_num=579) // mean diagonal inertia 
		BlankSpace(line_num=580)
		PlaceHolder() mjtNum
		PlaceHolder() meanmass;
		BlankSpace(line_num=580)
		SingleLineComment(line_num=580) // mean body mass 
		BlankSpace(line_num=581)
		PlaceHolder() mjtNum
		PlaceHolder() meansize;
		BlankSpace(line_num=581)
		SingleLineComment(line_num=581) // mean body size 
		BlankSpace(line_num=582)
		PlaceHolder() mjtNum
		PlaceHolder() extent;
		BlankSpace(line_num=582)
		SingleLineComment(line_num=582) // spatial extent 
		BlankSpace(line_num=583)
		PlaceHolder() mjtNum
		PlaceHolder() center[3];
		BlankSpace(line_num=583)
		SingleLineComment(line_num=583) // center of model 
		PlaceHolder() };
		TypeDef(line_num=585) typedef struct mjStatistic_ mjStatistic; 
		BlankSpace(line_num=586)
		BlankSpace(line_num=587)
		SingleLineComment(line_num=588) //---------------------------------- mjModel ------------------------------------------------------- 
		BlankSpace(line_num=589)
		PlaceHolder() struct
		PlaceHolder() mjModel_
		PlaceHolder() {
		BlankSpace(line_num=591)
		SingleLineComment(line_num=591) // ------------------------------- sizes 
		BlankSpace(line_num=592)
		BlankSpace(line_num=593)
		SingleLineComment(line_num=593) // sizes needed at mjModel construction 
		BlankSpace(line_num=594)
		PlaceHolder() int
		PlaceHolder() nq;
		BlankSpace(line_num=594)
		SingleLineComment(line_num=594) // number of generalized coordinates = dim(qpos) 
		BlankSpace(line_num=595)
		PlaceHolder() int
		PlaceHolder() nv;
		BlankSpace(line_num=595)
		SingleLineComment(line_num=595) // number of degrees of freedom = dim(qvel) 
		BlankSpace(line_num=596)
		PlaceHolder() int
		PlaceHolder() nu;
		BlankSpace(line_num=596)
		SingleLineComment(line_num=596) // number of actuators/controls = dim(ctrl) 
		BlankSpace(line_num=597)
		PlaceHolder() int
		PlaceHolder() na;
		BlankSpace(line_num=597)
		SingleLineComment(line_num=597) // number of activation states = dim(act) 
		BlankSpace(line_num=598)
		PlaceHolder() int
		PlaceHolder() nbody;
		BlankSpace(line_num=598)
		SingleLineComment(line_num=598) // number of bodies 
		BlankSpace(line_num=599)
		PlaceHolder() int
		PlaceHolder() nbvh;
		BlankSpace(line_num=599)
		SingleLineComment(line_num=599) // number of total bounding volumes in all bodies 
		BlankSpace(line_num=600)
		PlaceHolder() int
		PlaceHolder() nbvhstatic;
		BlankSpace(line_num=600)
		SingleLineComment(line_num=600) // number of static bounding volumes (aabb stored in mjModel) 
		BlankSpace(line_num=601)
		PlaceHolder() int
		PlaceHolder() nbvhdynamic;
		BlankSpace(line_num=601)
		SingleLineComment(line_num=601) // number of dynamic bounding volumes (aabb stored in mjData) 
		BlankSpace(line_num=602)
		PlaceHolder() int
		PlaceHolder() njnt;
		BlankSpace(line_num=602)
		SingleLineComment(line_num=602) // number of joints 
		BlankSpace(line_num=603)
		PlaceHolder() int
		PlaceHolder() ngeom;
		BlankSpace(line_num=603)
		SingleLineComment(line_num=603) // number of geoms 
		BlankSpace(line_num=604)
		PlaceHolder() int
		PlaceHolder() nsite;
		BlankSpace(line_num=604)
		SingleLineComment(line_num=604) // number of sites 
		BlankSpace(line_num=605)
		PlaceHolder() int
		PlaceHolder() ncam;
		BlankSpace(line_num=605)
		SingleLineComment(line_num=605) // number of cameras 
		BlankSpace(line_num=606)
		PlaceHolder() int
		PlaceHolder() nlight;
		BlankSpace(line_num=606)
		SingleLineComment(line_num=606) // number of lights 
		BlankSpace(line_num=607)
		PlaceHolder() int
		PlaceHolder() nflex;
		BlankSpace(line_num=607)
		SingleLineComment(line_num=607) // number of flexes 
		BlankSpace(line_num=608)
		PlaceHolder() int
		PlaceHolder() nflexvert;
		BlankSpace(line_num=608)
		SingleLineComment(line_num=608) // number of vertices in all flexes 
		BlankSpace(line_num=609)
		PlaceHolder() int
		PlaceHolder() nflexedge;
		BlankSpace(line_num=609)
		SingleLineComment(line_num=609) // number of edges in all flexes 
		BlankSpace(line_num=610)
		PlaceHolder() int
		PlaceHolder() nflexelem;
		BlankSpace(line_num=610)
		SingleLineComment(line_num=610) // number of elements in all flexes 
		BlankSpace(line_num=611)
		PlaceHolder() int
		PlaceHolder() nflexelemdata;
		BlankSpace(line_num=611)
		SingleLineComment(line_num=611) // number of element vertex ids in all flexes 
		BlankSpace(line_num=612)
		PlaceHolder() int
		PlaceHolder() nflexelemedge;
		BlankSpace(line_num=612)
		SingleLineComment(line_num=612) // number of element edge ids in all flexes 
		BlankSpace(line_num=613)
		PlaceHolder() int
		PlaceHolder() nflexshelldata;
		BlankSpace(line_num=613)
		SingleLineComment(line_num=613) // number of shell fragment vertex ids in all flexes 
		BlankSpace(line_num=614)
		PlaceHolder() int
		PlaceHolder() nflexevpair;
		BlankSpace(line_num=614)
		SingleLineComment(line_num=614) // number of element-vertex pairs in all flexes 
		BlankSpace(line_num=615)
		PlaceHolder() int
		PlaceHolder() nflextexcoord;
		BlankSpace(line_num=615)
		SingleLineComment(line_num=615) // number of vertices with texture coordinates 
		BlankSpace(line_num=616)
		PlaceHolder() int
		PlaceHolder() nmesh;
		BlankSpace(line_num=616)
		SingleLineComment(line_num=616) // number of meshes 
		BlankSpace(line_num=617)
		PlaceHolder() int
		PlaceHolder() nmeshvert;
		BlankSpace(line_num=617)
		SingleLineComment(line_num=617) // number of vertices in all meshes 
		BlankSpace(line_num=618)
		PlaceHolder() int
		PlaceHolder() nmeshnormal;
		BlankSpace(line_num=618)
		SingleLineComment(line_num=618) // number of normals in all meshes 
		BlankSpace(line_num=619)
		PlaceHolder() int
		PlaceHolder() nmeshtexcoord;
		BlankSpace(line_num=619)
		SingleLineComment(line_num=619) // number of texcoords in all meshes 
		BlankSpace(line_num=620)
		PlaceHolder() int
		PlaceHolder() nmeshface;
		BlankSpace(line_num=620)
		SingleLineComment(line_num=620) // number of triangular faces in all meshes 
		BlankSpace(line_num=621)
		PlaceHolder() int
		PlaceHolder() nmeshgraph;
		BlankSpace(line_num=621)
		SingleLineComment(line_num=621) // number of ints in mesh auxiliary data 
		BlankSpace(line_num=622)
		PlaceHolder() int
		PlaceHolder() nskin;
		BlankSpace(line_num=622)
		SingleLineComment(line_num=622) // number of skins 
		BlankSpace(line_num=623)
		PlaceHolder() int
		PlaceHolder() nskinvert;
		BlankSpace(line_num=623)
		SingleLineComment(line_num=623) // number of vertices in all skins 
		BlankSpace(line_num=624)
		PlaceHolder() int
		PlaceHolder() nskintexvert;
		BlankSpace(line_num=624)
		SingleLineComment(line_num=624) // number of vertiex with texcoords in all skins 
		BlankSpace(line_num=625)
		PlaceHolder() int
		PlaceHolder() nskinface;
		BlankSpace(line_num=625)
		SingleLineComment(line_num=625) // number of triangular faces in all skins 
		BlankSpace(line_num=626)
		PlaceHolder() int
		PlaceHolder() nskinbone;
		BlankSpace(line_num=626)
		SingleLineComment(line_num=626) // number of bones in all skins 
		BlankSpace(line_num=627)
		PlaceHolder() int
		PlaceHolder() nskinbonevert;
		BlankSpace(line_num=627)
		SingleLineComment(line_num=627) // number of vertices in all skin bones 
		BlankSpace(line_num=628)
		PlaceHolder() int
		PlaceHolder() nhfield;
		BlankSpace(line_num=628)
		SingleLineComment(line_num=628) // number of heightfields 
		BlankSpace(line_num=629)
		PlaceHolder() int
		PlaceHolder() nhfielddata;
		BlankSpace(line_num=629)
		SingleLineComment(line_num=629) // number of data points in all heightfields 
		BlankSpace(line_num=630)
		PlaceHolder() int
		PlaceHolder() ntex;
		BlankSpace(line_num=630)
		SingleLineComment(line_num=630) // number of textures 
		BlankSpace(line_num=631)
		PlaceHolder() int
		PlaceHolder() ntexdata;
		BlankSpace(line_num=631)
		SingleLineComment(line_num=631) // number of bytes in texture rgb data 
		BlankSpace(line_num=632)
		PlaceHolder() int
		PlaceHolder() nmat;
		BlankSpace(line_num=632)
		SingleLineComment(line_num=632) // number of materials 
		BlankSpace(line_num=633)
		PlaceHolder() int
		PlaceHolder() npair;
		BlankSpace(line_num=633)
		SingleLineComment(line_num=633) // number of predefined geom pairs 
		BlankSpace(line_num=634)
		PlaceHolder() int
		PlaceHolder() nexclude;
		BlankSpace(line_num=634)
		SingleLineComment(line_num=634) // number of excluded geom pairs 
		BlankSpace(line_num=635)
		PlaceHolder() int
		PlaceHolder() neq;
		BlankSpace(line_num=635)
		SingleLineComment(line_num=635) // number of equality constraints 
		BlankSpace(line_num=636)
		PlaceHolder() int
		PlaceHolder() ntendon;
		BlankSpace(line_num=636)
		SingleLineComment(line_num=636) // number of tendons 
		BlankSpace(line_num=637)
		PlaceHolder() int
		PlaceHolder() nwrap;
		BlankSpace(line_num=637)
		SingleLineComment(line_num=637) // number of wrap objects in all tendon paths 
		BlankSpace(line_num=638)
		PlaceHolder() int
		PlaceHolder() nsensor;
		BlankSpace(line_num=638)
		SingleLineComment(line_num=638) // number of sensors 
		BlankSpace(line_num=639)
		PlaceHolder() int
		PlaceHolder() nnumeric;
		BlankSpace(line_num=639)
		SingleLineComment(line_num=639) // number of numeric custom fields 
		BlankSpace(line_num=640)
		PlaceHolder() int
		PlaceHolder() nnumericdata;
		BlankSpace(line_num=640)
		SingleLineComment(line_num=640) // number of mjtNums in all numeric fields 
		BlankSpace(line_num=641)
		PlaceHolder() int
		PlaceHolder() ntext;
		BlankSpace(line_num=641)
		SingleLineComment(line_num=641) // number of text custom fields 
		BlankSpace(line_num=642)
		PlaceHolder() int
		PlaceHolder() ntextdata;
		BlankSpace(line_num=642)
		SingleLineComment(line_num=642) // number of mjtBytes in all text fields 
		BlankSpace(line_num=643)
		PlaceHolder() int
		PlaceHolder() ntuple;
		BlankSpace(line_num=643)
		SingleLineComment(line_num=643) // number of tuple custom fields 
		BlankSpace(line_num=644)
		PlaceHolder() int
		PlaceHolder() ntupledata;
		BlankSpace(line_num=644)
		SingleLineComment(line_num=644) // number of objects in all tuple fields 
		BlankSpace(line_num=645)
		PlaceHolder() int
		PlaceHolder() nkey;
		BlankSpace(line_num=645)
		SingleLineComment(line_num=645) // number of keyframes 
		BlankSpace(line_num=646)
		PlaceHolder() int
		PlaceHolder() nmocap;
		BlankSpace(line_num=646)
		SingleLineComment(line_num=646) // number of mocap bodies 
		BlankSpace(line_num=647)
		PlaceHolder() int
		PlaceHolder() nplugin;
		BlankSpace(line_num=647)
		SingleLineComment(line_num=647) // number of plugin instances 
		BlankSpace(line_num=648)
		PlaceHolder() int
		PlaceHolder() npluginattr;
		BlankSpace(line_num=648)
		SingleLineComment(line_num=648) // number of chars in all plugin config attributes 
		BlankSpace(line_num=649)
		PlaceHolder() int
		PlaceHolder() nuser_body;
		BlankSpace(line_num=649)
		SingleLineComment(line_num=649) // number of mjtNums in body_user 
		BlankSpace(line_num=650)
		PlaceHolder() int
		PlaceHolder() nuser_jnt;
		BlankSpace(line_num=650)
		SingleLineComment(line_num=650) // number of mjtNums in jnt_user 
		BlankSpace(line_num=651)
		PlaceHolder() int
		PlaceHolder() nuser_geom;
		BlankSpace(line_num=651)
		SingleLineComment(line_num=651) // number of mjtNums in geom_user 
		BlankSpace(line_num=652)
		PlaceHolder() int
		PlaceHolder() nuser_site;
		BlankSpace(line_num=652)
		SingleLineComment(line_num=652) // number of mjtNums in site_user 
		BlankSpace(line_num=653)
		PlaceHolder() int
		PlaceHolder() nuser_cam;
		BlankSpace(line_num=653)
		SingleLineComment(line_num=653) // number of mjtNums in cam_user 
		BlankSpace(line_num=654)
		PlaceHolder() int
		PlaceHolder() nuser_tendon;
		BlankSpace(line_num=654)
		SingleLineComment(line_num=654) // number of mjtNums in tendon_user 
		BlankSpace(line_num=655)
		PlaceHolder() int
		PlaceHolder() nuser_actuator;
		BlankSpace(line_num=655)
		SingleLineComment(line_num=655) // number of mjtNums in actuator_user 
		BlankSpace(line_num=656)
		PlaceHolder() int
		PlaceHolder() nuser_sensor;
		BlankSpace(line_num=656)
		SingleLineComment(line_num=656) // number of mjtNums in sensor_user 
		BlankSpace(line_num=657)
		PlaceHolder() int
		PlaceHolder() nnames;
		BlankSpace(line_num=657)
		SingleLineComment(line_num=657) // number of chars in all names 
		BlankSpace(line_num=658)
		PlaceHolder() int
		PlaceHolder() nnames_map;
		BlankSpace(line_num=658)
		SingleLineComment(line_num=658) // number of slots in the names hash map 
		BlankSpace(line_num=659)
		PlaceHolder() int
		PlaceHolder() npaths;
		BlankSpace(line_num=659)
		SingleLineComment(line_num=659) // number of chars in all paths 
		BlankSpace(line_num=660)
		BlankSpace(line_num=661)
		SingleLineComment(line_num=661) // sizes set after mjModel construction (only affect mjData) 
		BlankSpace(line_num=662)
		PlaceHolder() int
		PlaceHolder() nM;
		BlankSpace(line_num=662)
		SingleLineComment(line_num=662) // number of non-zeros in sparse inertia matrix 
		BlankSpace(line_num=663)
		PlaceHolder() int
		PlaceHolder() nB;
		BlankSpace(line_num=663)
		SingleLineComment(line_num=663) // number of non-zeros in sparse body-dof matrix 
		BlankSpace(line_num=664)
		PlaceHolder() int
		PlaceHolder() nC;
		BlankSpace(line_num=664)
		SingleLineComment(line_num=664) // number of non-zeros in sparse reduced dof-dof matrix 
		BlankSpace(line_num=665)
		PlaceHolder() int
		PlaceHolder() nD;
		BlankSpace(line_num=665)
		SingleLineComment(line_num=665) // number of non-zeros in sparse dof-dof matrix 
		BlankSpace(line_num=666)
		PlaceHolder() int
		PlaceHolder() ntree;
		BlankSpace(line_num=666)
		SingleLineComment(line_num=666) // number of kinematic trees under world body 
		BlankSpace(line_num=667)
		PlaceHolder() int
		PlaceHolder() ngravcomp;
		BlankSpace(line_num=667)
		SingleLineComment(line_num=667) // number of bodies with nonzero gravcomp 
		BlankSpace(line_num=668)
		PlaceHolder() int
		PlaceHolder() nemax;
		BlankSpace(line_num=668)
		SingleLineComment(line_num=668) // number of potential equality-constraint rows 
		BlankSpace(line_num=669)
		PlaceHolder() int
		PlaceHolder() njmax;
		BlankSpace(line_num=669)
		SingleLineComment(line_num=669) // number of available rows in constraint Jacobian 
		BlankSpace(line_num=670)
		PlaceHolder() int
		PlaceHolder() nconmax;
		BlankSpace(line_num=670)
		SingleLineComment(line_num=670) // number of potential contacts in contact list 
		BlankSpace(line_num=671)
		PlaceHolder() int
		PlaceHolder() nuserdata;
		BlankSpace(line_num=671)
		SingleLineComment(line_num=671) // number of mjtNums reserved for the user 
		BlankSpace(line_num=672)
		PlaceHolder() int
		PlaceHolder() nsensordata;
		BlankSpace(line_num=672)
		SingleLineComment(line_num=672) // number of mjtNums in sensor data vector 
		BlankSpace(line_num=673)
		PlaceHolder() int
		PlaceHolder() npluginstate;
		BlankSpace(line_num=673)
		SingleLineComment(line_num=673) // number of mjtNums in plugin state vector 
		BlankSpace(line_num=674)
		BlankSpace(line_num=675)
		PlaceHolder() size_t
		PlaceHolder() narena;
		BlankSpace(line_num=675)
		SingleLineComment(line_num=675) // number of bytes in the mjData arena (inclusive of stack) 
		BlankSpace(line_num=676)
		PlaceHolder() size_t
		PlaceHolder() nbuffer;
		BlankSpace(line_num=676)
		SingleLineComment(line_num=676) // number of bytes in buffer 
		BlankSpace(line_num=677)
		BlankSpace(line_num=678)
		SingleLineComment(line_num=678) // ------------------------------- options and statistics 
		BlankSpace(line_num=679)
		BlankSpace(line_num=680)
		PlaceHolder() mjOption
		PlaceHolder() opt;
		BlankSpace(line_num=680)
		SingleLineComment(line_num=680) // physics options 
		BlankSpace(line_num=681)
		PlaceHolder() mjVisual
		PlaceHolder() vis;
		BlankSpace(line_num=681)
		SingleLineComment(line_num=681) // visualization options 
		BlankSpace(line_num=682)
		PlaceHolder() mjStatistic
		PlaceHolder() stat;
		BlankSpace(line_num=682)
		SingleLineComment(line_num=682) // model statistics 
		BlankSpace(line_num=683)
		BlankSpace(line_num=684)
		SingleLineComment(line_num=684) // ------------------------------- buffers 
		BlankSpace(line_num=685)
		BlankSpace(line_num=686)
		SingleLineComment(line_num=686) // main buffer 
		BlankSpace(line_num=687)
		PlaceHolder() void*
		BlankSpace(line_num=687)
		PlaceHolder() buffer;
		BlankSpace(line_num=687)
		SingleLineComment(line_num=687) // main buffer; all pointers point in it    (nbuffer) 
		BlankSpace(line_num=688)
		BlankSpace(line_num=689)
		SingleLineComment(line_num=689) // default generalized coordinates 
		BlankSpace(line_num=690)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=690)
		PlaceHolder() qpos0;
		BlankSpace(line_num=690)
		SingleLineComment(line_num=690) // qpos values at default pose              (nq x 1) 
		BlankSpace(line_num=691)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=691)
		PlaceHolder() qpos_spring;
		BlankSpace(line_num=691)
		SingleLineComment(line_num=691) // reference pose for springs               (nq x 1) 
		BlankSpace(line_num=692)
		BlankSpace(line_num=693)
		SingleLineComment(line_num=693) // bodies 
		BlankSpace(line_num=694)
		PlaceHolder() int*
		BlankSpace(line_num=694)
		PlaceHolder() body_parentid;
		BlankSpace(line_num=694)
		SingleLineComment(line_num=694) // id of body's parent                      (nbody x 1) 
		BlankSpace(line_num=695)
		PlaceHolder() int*
		BlankSpace(line_num=695)
		PlaceHolder() body_rootid;
		BlankSpace(line_num=695)
		SingleLineComment(line_num=695) // id of root above body                    (nbody x 1) 
		BlankSpace(line_num=696)
		PlaceHolder() int*
		BlankSpace(line_num=696)
		PlaceHolder() body_weldid;
		BlankSpace(line_num=696)
		SingleLineComment(line_num=696) // id of body that this body is welded to   (nbody x 1) 
		BlankSpace(line_num=697)
		PlaceHolder() int*
		BlankSpace(line_num=697)
		PlaceHolder() body_mocapid;
		BlankSpace(line_num=697)
		SingleLineComment(line_num=697) // id of mocap data; -1: none               (nbody x 1) 
		BlankSpace(line_num=698)
		PlaceHolder() int*
		BlankSpace(line_num=698)
		PlaceHolder() body_jntnum;
		BlankSpace(line_num=698)
		SingleLineComment(line_num=698) // number of joints for this body           (nbody x 1) 
		BlankSpace(line_num=699)
		PlaceHolder() int*
		BlankSpace(line_num=699)
		PlaceHolder() body_jntadr;
		BlankSpace(line_num=699)
		SingleLineComment(line_num=699) // start addr of joints; -1: no joints      (nbody x 1) 
		BlankSpace(line_num=700)
		PlaceHolder() int*
		BlankSpace(line_num=700)
		PlaceHolder() body_dofnum;
		BlankSpace(line_num=700)
		SingleLineComment(line_num=700) // number of motion degrees of freedom      (nbody x 1) 
		BlankSpace(line_num=701)
		PlaceHolder() int*
		BlankSpace(line_num=701)
		PlaceHolder() body_dofadr;
		BlankSpace(line_num=701)
		SingleLineComment(line_num=701) // start addr of dofs; -1: no dofs          (nbody x 1) 
		BlankSpace(line_num=702)
		PlaceHolder() int*
		BlankSpace(line_num=702)
		PlaceHolder() body_treeid;
		BlankSpace(line_num=702)
		SingleLineComment(line_num=702) // id of body's kinematic tree; -1: static  (nbody x 1) 
		BlankSpace(line_num=703)
		PlaceHolder() int*
		BlankSpace(line_num=703)
		PlaceHolder() body_geomnum;
		BlankSpace(line_num=703)
		SingleLineComment(line_num=703) // number of geoms                          (nbody x 1) 
		BlankSpace(line_num=704)
		PlaceHolder() int*
		BlankSpace(line_num=704)
		PlaceHolder() body_geomadr;
		BlankSpace(line_num=704)
		SingleLineComment(line_num=704) // start addr of geoms; -1: no geoms        (nbody x 1) 
		BlankSpace(line_num=705)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=705)
		PlaceHolder() body_simple;
		BlankSpace(line_num=705)
		SingleLineComment(line_num=705) // 1: diag M; 2: diag M, sliders only       (nbody x 1) 
		BlankSpace(line_num=706)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=706)
		PlaceHolder() body_sameframe;
		BlankSpace(line_num=706)
		SingleLineComment(line_num=706) // same frame as inertia (mjtSameframe)     (nbody x 1) 
		BlankSpace(line_num=707)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=707)
		PlaceHolder() body_pos;
		BlankSpace(line_num=707)
		SingleLineComment(line_num=707) // position offset rel. to parent body      (nbody x 3) 
		BlankSpace(line_num=708)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=708)
		PlaceHolder() body_quat;
		BlankSpace(line_num=708)
		SingleLineComment(line_num=708) // orientation offset rel. to parent body   (nbody x 4) 
		BlankSpace(line_num=709)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=709)
		PlaceHolder() body_ipos;
		BlankSpace(line_num=709)
		SingleLineComment(line_num=709) // local position of center of mass         (nbody x 3) 
		BlankSpace(line_num=710)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=710)
		PlaceHolder() body_iquat;
		BlankSpace(line_num=710)
		SingleLineComment(line_num=710) // local orientation of inertia ellipsoid   (nbody x 4) 
		BlankSpace(line_num=711)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=711)
		PlaceHolder() body_mass;
		BlankSpace(line_num=711)
		SingleLineComment(line_num=711) // mass                                     (nbody x 1) 
		BlankSpace(line_num=712)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=712)
		PlaceHolder() body_subtreemass;
		BlankSpace(line_num=712)
		SingleLineComment(line_num=712) // mass of subtree starting at this body    (nbody x 1) 
		BlankSpace(line_num=713)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=713)
		PlaceHolder() body_inertia;
		BlankSpace(line_num=713)
		SingleLineComment(line_num=713) // diagonal inertia in ipos/iquat frame     (nbody x 3) 
		BlankSpace(line_num=714)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=714)
		PlaceHolder() body_invweight0;
		BlankSpace(line_num=714)
		SingleLineComment(line_num=714) // mean inv inert in qpos0 (trn, rot)       (nbody x 2) 
		BlankSpace(line_num=715)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=715)
		PlaceHolder() body_gravcomp;
		BlankSpace(line_num=715)
		SingleLineComment(line_num=715) // antigravity force, units of body weight  (nbody x 1) 
		BlankSpace(line_num=716)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=716)
		PlaceHolder() body_margin;
		BlankSpace(line_num=716)
		SingleLineComment(line_num=716) // MAX over all geom margins                (nbody x 1) 
		BlankSpace(line_num=717)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=717)
		PlaceHolder() body_user;
		BlankSpace(line_num=717)
		SingleLineComment(line_num=717) // user data                                (nbody x nuser_body) 
		BlankSpace(line_num=718)
		PlaceHolder() int*
		BlankSpace(line_num=718)
		PlaceHolder() body_plugin;
		BlankSpace(line_num=718)
		SingleLineComment(line_num=718) // plugin instance id; -1: not in use       (nbody x 1) 
		BlankSpace(line_num=719)
		PlaceHolder() int*
		BlankSpace(line_num=719)
		PlaceHolder() body_contype;
		BlankSpace(line_num=719)
		SingleLineComment(line_num=719) // OR over all geom contypes                (nbody x 1) 
		BlankSpace(line_num=720)
		PlaceHolder() int*
		BlankSpace(line_num=720)
		PlaceHolder() body_conaffinity;
		BlankSpace(line_num=720)
		SingleLineComment(line_num=720) // OR over all geom conaffinities           (nbody x 1) 
		BlankSpace(line_num=721)
		PlaceHolder() int*
		BlankSpace(line_num=721)
		PlaceHolder() body_bvhadr;
		BlankSpace(line_num=721)
		SingleLineComment(line_num=721) // address of bvh root                      (nbody x 1) 
		BlankSpace(line_num=722)
		PlaceHolder() int*
		BlankSpace(line_num=722)
		PlaceHolder() body_bvhnum;
		BlankSpace(line_num=722)
		SingleLineComment(line_num=722) // number of bounding volumes               (nbody x 1) 
		BlankSpace(line_num=723)
		BlankSpace(line_num=724)
		SingleLineComment(line_num=724) // bounding volume hierarchy 
		BlankSpace(line_num=725)
		PlaceHolder() int*
		BlankSpace(line_num=725)
		PlaceHolder() bvh_depth;
		BlankSpace(line_num=725)
		SingleLineComment(line_num=725) // depth in the bounding volume hierarchy   (nbvh x 1) 
		BlankSpace(line_num=726)
		PlaceHolder() int*
		BlankSpace(line_num=726)
		PlaceHolder() bvh_child;
		BlankSpace(line_num=726)
		SingleLineComment(line_num=726) // left and right children in tree          (nbvh x 2) 
		BlankSpace(line_num=727)
		PlaceHolder() int*
		BlankSpace(line_num=727)
		PlaceHolder() bvh_nodeid;
		BlankSpace(line_num=727)
		SingleLineComment(line_num=727) // geom or elem id of node; -1: non-leaf    (nbvh x 1) 
		BlankSpace(line_num=728)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=728)
		PlaceHolder() bvh_aabb;
		BlankSpace(line_num=728)
		SingleLineComment(line_num=728) // local bounding box (center, size)        (nbvhstatic x 6) 
		BlankSpace(line_num=729)
		BlankSpace(line_num=730)
		SingleLineComment(line_num=730) // joints 
		BlankSpace(line_num=731)
		PlaceHolder() int*
		BlankSpace(line_num=731)
		PlaceHolder() jnt_type;
		BlankSpace(line_num=731)
		SingleLineComment(line_num=731) // type of joint (mjtJoint)                 (njnt x 1) 
		BlankSpace(line_num=732)
		PlaceHolder() int*
		BlankSpace(line_num=732)
		PlaceHolder() jnt_qposadr;
		BlankSpace(line_num=732)
		SingleLineComment(line_num=732) // start addr in 'qpos' for joint's data    (njnt x 1) 
		BlankSpace(line_num=733)
		PlaceHolder() int*
		BlankSpace(line_num=733)
		PlaceHolder() jnt_dofadr;
		BlankSpace(line_num=733)
		SingleLineComment(line_num=733) // start addr in 'qvel' for joint's data    (njnt x 1) 
		BlankSpace(line_num=734)
		PlaceHolder() int*
		BlankSpace(line_num=734)
		PlaceHolder() jnt_bodyid;
		BlankSpace(line_num=734)
		SingleLineComment(line_num=734) // id of joint's body                       (njnt x 1) 
		BlankSpace(line_num=735)
		PlaceHolder() int*
		BlankSpace(line_num=735)
		PlaceHolder() jnt_group;
		BlankSpace(line_num=735)
		SingleLineComment(line_num=735) // group for visibility                     (njnt x 1) 
		BlankSpace(line_num=736)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=736)
		PlaceHolder() jnt_limited;
		BlankSpace(line_num=736)
		SingleLineComment(line_num=736) // does joint have limits                   (njnt x 1) 
		BlankSpace(line_num=737)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=737)
		PlaceHolder() jnt_actfrclimited;
		BlankSpace(line_num=737)
		SingleLineComment(line_num=737) // does joint have actuator force limits    (njnt x 1) 
		BlankSpace(line_num=738)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=738)
		PlaceHolder() jnt_actgravcomp;
		BlankSpace(line_num=738)
		SingleLineComment(line_num=738) // is gravcomp force applied via actuators  (njnt x 1) 
		BlankSpace(line_num=739)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=739)
		PlaceHolder() jnt_solref;
		BlankSpace(line_num=739)
		SingleLineComment(line_num=739) // constraint solver reference: limit       (njnt x mjNREF) 
		BlankSpace(line_num=740)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=740)
		PlaceHolder() jnt_solimp;
		BlankSpace(line_num=740)
		SingleLineComment(line_num=740) // constraint solver impedance: limit       (njnt x mjNIMP) 
		BlankSpace(line_num=741)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=741)
		PlaceHolder() jnt_pos;
		BlankSpace(line_num=741)
		SingleLineComment(line_num=741) // local anchor position                    (njnt x 3) 
		BlankSpace(line_num=742)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=742)
		PlaceHolder() jnt_axis;
		BlankSpace(line_num=742)
		SingleLineComment(line_num=742) // local joint axis                         (njnt x 3) 
		BlankSpace(line_num=743)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=743)
		PlaceHolder() jnt_stiffness;
		BlankSpace(line_num=743)
		SingleLineComment(line_num=743) // stiffness coefficient                    (njnt x 1) 
		BlankSpace(line_num=744)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=744)
		PlaceHolder() jnt_range;
		BlankSpace(line_num=744)
		SingleLineComment(line_num=744) // joint limits                             (njnt x 2) 
		BlankSpace(line_num=745)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=745)
		PlaceHolder() jnt_actfrcrange;
		BlankSpace(line_num=745)
		SingleLineComment(line_num=745) // range of total actuator force            (njnt x 2) 
		BlankSpace(line_num=746)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=746)
		PlaceHolder() jnt_margin;
		BlankSpace(line_num=746)
		SingleLineComment(line_num=746) // min distance for limit detection         (njnt x 1) 
		BlankSpace(line_num=747)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=747)
		PlaceHolder() jnt_user;
		BlankSpace(line_num=747)
		SingleLineComment(line_num=747) // user data                                (njnt x nuser_jnt) 
		BlankSpace(line_num=748)
		BlankSpace(line_num=749)
		SingleLineComment(line_num=749) // dofs 
		BlankSpace(line_num=750)
		PlaceHolder() int*
		BlankSpace(line_num=750)
		PlaceHolder() dof_bodyid;
		BlankSpace(line_num=750)
		SingleLineComment(line_num=750) // id of dof's body                         (nv x 1) 
		BlankSpace(line_num=751)
		PlaceHolder() int*
		BlankSpace(line_num=751)
		PlaceHolder() dof_jntid;
		BlankSpace(line_num=751)
		SingleLineComment(line_num=751) // id of dof's joint                        (nv x 1) 
		BlankSpace(line_num=752)
		PlaceHolder() int*
		BlankSpace(line_num=752)
		PlaceHolder() dof_parentid;
		BlankSpace(line_num=752)
		SingleLineComment(line_num=752) // id of dof's parent; -1: none             (nv x 1) 
		BlankSpace(line_num=753)
		PlaceHolder() int*
		BlankSpace(line_num=753)
		PlaceHolder() dof_treeid;
		BlankSpace(line_num=753)
		SingleLineComment(line_num=753) // id of dof's kinematic tree               (nv x 1) 
		BlankSpace(line_num=754)
		PlaceHolder() int*
		BlankSpace(line_num=754)
		PlaceHolder() dof_Madr;
		BlankSpace(line_num=754)
		SingleLineComment(line_num=754) // dof address in M-diagonal                (nv x 1) 
		BlankSpace(line_num=755)
		PlaceHolder() int*
		BlankSpace(line_num=755)
		PlaceHolder() dof_simplenum;
		BlankSpace(line_num=755)
		SingleLineComment(line_num=755) // number of consecutive simple dofs        (nv x 1) 
		BlankSpace(line_num=756)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=756)
		PlaceHolder() dof_solref;
		BlankSpace(line_num=756)
		SingleLineComment(line_num=756) // constraint solver reference:frictionloss (nv x mjNREF) 
		BlankSpace(line_num=757)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=757)
		PlaceHolder() dof_solimp;
		BlankSpace(line_num=757)
		SingleLineComment(line_num=757) // constraint solver impedance:frictionloss (nv x mjNIMP) 
		BlankSpace(line_num=758)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=758)
		PlaceHolder() dof_frictionloss;
		BlankSpace(line_num=758)
		SingleLineComment(line_num=758) // dof friction loss                        (nv x 1) 
		BlankSpace(line_num=759)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=759)
		PlaceHolder() dof_armature;
		BlankSpace(line_num=759)
		SingleLineComment(line_num=759) // dof armature inertia/mass                (nv x 1) 
		BlankSpace(line_num=760)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=760)
		PlaceHolder() dof_damping;
		BlankSpace(line_num=760)
		SingleLineComment(line_num=760) // damping coefficient                      (nv x 1) 
		BlankSpace(line_num=761)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=761)
		PlaceHolder() dof_invweight0;
		BlankSpace(line_num=761)
		SingleLineComment(line_num=761) // diag. inverse inertia in qpos0           (nv x 1) 
		BlankSpace(line_num=762)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=762)
		PlaceHolder() dof_M0;
		BlankSpace(line_num=762)
		SingleLineComment(line_num=762) // diag. inertia in qpos0                   (nv x 1) 
		BlankSpace(line_num=763)
		BlankSpace(line_num=764)
		SingleLineComment(line_num=764) // geoms 
		BlankSpace(line_num=765)
		PlaceHolder() int*
		BlankSpace(line_num=765)
		PlaceHolder() geom_type;
		BlankSpace(line_num=765)
		SingleLineComment(line_num=765) // geometric type (mjtGeom)                 (ngeom x 1) 
		BlankSpace(line_num=766)
		PlaceHolder() int*
		BlankSpace(line_num=766)
		PlaceHolder() geom_contype;
		BlankSpace(line_num=766)
		SingleLineComment(line_num=766) // geom contact type                        (ngeom x 1) 
		BlankSpace(line_num=767)
		PlaceHolder() int*
		BlankSpace(line_num=767)
		PlaceHolder() geom_conaffinity;
		BlankSpace(line_num=767)
		SingleLineComment(line_num=767) // geom contact affinity                    (ngeom x 1) 
		BlankSpace(line_num=768)
		PlaceHolder() int*
		BlankSpace(line_num=768)
		PlaceHolder() geom_condim;
		BlankSpace(line_num=768)
		SingleLineComment(line_num=768) // contact dimensionality (1, 3, 4, 6)      (ngeom x 1) 
		BlankSpace(line_num=769)
		PlaceHolder() int*
		BlankSpace(line_num=769)
		PlaceHolder() geom_bodyid;
		BlankSpace(line_num=769)
		SingleLineComment(line_num=769) // id of geom's body                        (ngeom x 1) 
		BlankSpace(line_num=770)
		PlaceHolder() int*
		BlankSpace(line_num=770)
		PlaceHolder() geom_dataid;
		BlankSpace(line_num=770)
		SingleLineComment(line_num=770) // id of geom's mesh/hfield; -1: none       (ngeom x 1) 
		BlankSpace(line_num=771)
		PlaceHolder() int*
		BlankSpace(line_num=771)
		PlaceHolder() geom_matid;
		BlankSpace(line_num=771)
		SingleLineComment(line_num=771) // material id for rendering; -1: none      (ngeom x 1) 
		BlankSpace(line_num=772)
		PlaceHolder() int*
		BlankSpace(line_num=772)
		PlaceHolder() geom_group;
		BlankSpace(line_num=772)
		SingleLineComment(line_num=772) // group for visibility                     (ngeom x 1) 
		BlankSpace(line_num=773)
		PlaceHolder() int*
		BlankSpace(line_num=773)
		PlaceHolder() geom_priority;
		BlankSpace(line_num=773)
		SingleLineComment(line_num=773) // geom contact priority                    (ngeom x 1) 
		BlankSpace(line_num=774)
		PlaceHolder() int*
		BlankSpace(line_num=774)
		PlaceHolder() geom_plugin;
		BlankSpace(line_num=774)
		SingleLineComment(line_num=774) // plugin instance id; -1: not in use       (ngeom x 1) 
		BlankSpace(line_num=775)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=775)
		PlaceHolder() geom_sameframe;
		BlankSpace(line_num=775)
		SingleLineComment(line_num=775) // same frame as body (mjtSameframe)        (ngeom x 1) 
		BlankSpace(line_num=776)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=776)
		PlaceHolder() geom_solmix;
		BlankSpace(line_num=776)
		SingleLineComment(line_num=776) // mixing coef for solref/imp in geom pair  (ngeom x 1) 
		BlankSpace(line_num=777)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=777)
		PlaceHolder() geom_solref;
		BlankSpace(line_num=777)
		SingleLineComment(line_num=777) // constraint solver reference: contact     (ngeom x mjNREF) 
		BlankSpace(line_num=778)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=778)
		PlaceHolder() geom_solimp;
		BlankSpace(line_num=778)
		SingleLineComment(line_num=778) // constraint solver impedance: contact     (ngeom x mjNIMP) 
		BlankSpace(line_num=779)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=779)
		PlaceHolder() geom_size;
		BlankSpace(line_num=779)
		SingleLineComment(line_num=779) // geom-specific size parameters            (ngeom x 3) 
		BlankSpace(line_num=780)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=780)
		PlaceHolder() geom_aabb;
		BlankSpace(line_num=780)
		SingleLineComment(line_num=780) // bounding box, (center, size)             (ngeom x 6) 
		BlankSpace(line_num=781)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=781)
		PlaceHolder() geom_rbound;
		BlankSpace(line_num=781)
		SingleLineComment(line_num=781) // radius of bounding sphere                (ngeom x 1) 
		BlankSpace(line_num=782)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=782)
		PlaceHolder() geom_pos;
		BlankSpace(line_num=782)
		SingleLineComment(line_num=782) // local position offset rel. to body       (ngeom x 3) 
		BlankSpace(line_num=783)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=783)
		PlaceHolder() geom_quat;
		BlankSpace(line_num=783)
		SingleLineComment(line_num=783) // local orientation offset rel. to body    (ngeom x 4) 
		BlankSpace(line_num=784)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=784)
		PlaceHolder() geom_friction;
		BlankSpace(line_num=784)
		SingleLineComment(line_num=784) // friction for (slide, spin, roll)         (ngeom x 3) 
		BlankSpace(line_num=785)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=785)
		PlaceHolder() geom_margin;
		BlankSpace(line_num=785)
		SingleLineComment(line_num=785) // detect contact if dist<margin            (ngeom x 1) 
		BlankSpace(line_num=786)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=786)
		PlaceHolder() geom_gap;
		BlankSpace(line_num=786)
		SingleLineComment(line_num=786) // include in solver if dist<margin-gap     (ngeom x 1) 
		BlankSpace(line_num=787)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=787)
		PlaceHolder() geom_fluid;
		BlankSpace(line_num=787)
		SingleLineComment(line_num=787) // fluid interaction parameters             (ngeom x mjNFLUID) 
		BlankSpace(line_num=788)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=788)
		PlaceHolder() geom_user;
		BlankSpace(line_num=788)
		SingleLineComment(line_num=788) // user data                                (ngeom x nuser_geom) 
		BlankSpace(line_num=789)
		PlaceHolder() float*
		BlankSpace(line_num=789)
		PlaceHolder() geom_rgba;
		BlankSpace(line_num=789)
		SingleLineComment(line_num=789) // rgba when material is omitted            (ngeom x 4) 
		BlankSpace(line_num=790)
		BlankSpace(line_num=791)
		SingleLineComment(line_num=791) // sites 
		BlankSpace(line_num=792)
		PlaceHolder() int*
		BlankSpace(line_num=792)
		PlaceHolder() site_type;
		BlankSpace(line_num=792)
		SingleLineComment(line_num=792) // geom type for rendering (mjtGeom)        (nsite x 1) 
		BlankSpace(line_num=793)
		PlaceHolder() int*
		BlankSpace(line_num=793)
		PlaceHolder() site_bodyid;
		BlankSpace(line_num=793)
		SingleLineComment(line_num=793) // id of site's body                        (nsite x 1) 
		BlankSpace(line_num=794)
		PlaceHolder() int*
		BlankSpace(line_num=794)
		PlaceHolder() site_matid;
		BlankSpace(line_num=794)
		SingleLineComment(line_num=794) // material id for rendering; -1: none      (nsite x 1) 
		BlankSpace(line_num=795)
		PlaceHolder() int*
		BlankSpace(line_num=795)
		PlaceHolder() site_group;
		BlankSpace(line_num=795)
		SingleLineComment(line_num=795) // group for visibility                     (nsite x 1) 
		BlankSpace(line_num=796)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=796)
		PlaceHolder() site_sameframe;
		BlankSpace(line_num=796)
		SingleLineComment(line_num=796) // same frame as body (mjtSameframe)        (nsite x 1) 
		BlankSpace(line_num=797)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=797)
		PlaceHolder() site_size;
		BlankSpace(line_num=797)
		SingleLineComment(line_num=797) // geom size for rendering                  (nsite x 3) 
		BlankSpace(line_num=798)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=798)
		PlaceHolder() site_pos;
		BlankSpace(line_num=798)
		SingleLineComment(line_num=798) // local position offset rel. to body       (nsite x 3) 
		BlankSpace(line_num=799)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=799)
		PlaceHolder() site_quat;
		BlankSpace(line_num=799)
		SingleLineComment(line_num=799) // local orientation offset rel. to body    (nsite x 4) 
		BlankSpace(line_num=800)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=800)
		PlaceHolder() site_user;
		BlankSpace(line_num=800)
		SingleLineComment(line_num=800) // user data                                (nsite x nuser_site) 
		BlankSpace(line_num=801)
		PlaceHolder() float*
		BlankSpace(line_num=801)
		PlaceHolder() site_rgba;
		BlankSpace(line_num=801)
		SingleLineComment(line_num=801) // rgba when material is omitted            (nsite x 4) 
		BlankSpace(line_num=802)
		BlankSpace(line_num=803)
		SingleLineComment(line_num=803) // cameras 
		BlankSpace(line_num=804)
		PlaceHolder() int*
		BlankSpace(line_num=804)
		PlaceHolder() cam_mode;
		BlankSpace(line_num=804)
		SingleLineComment(line_num=804) // camera tracking mode (mjtCamLight)       (ncam x 1) 
		BlankSpace(line_num=805)
		PlaceHolder() int*
		BlankSpace(line_num=805)
		PlaceHolder() cam_bodyid;
		BlankSpace(line_num=805)
		SingleLineComment(line_num=805) // id of camera's body                      (ncam x 1) 
		BlankSpace(line_num=806)
		PlaceHolder() int*
		BlankSpace(line_num=806)
		PlaceHolder() cam_targetbodyid;
		BlankSpace(line_num=806)
		SingleLineComment(line_num=806) // id of targeted body; -1: none            (ncam x 1) 
		BlankSpace(line_num=807)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=807)
		PlaceHolder() cam_pos;
		BlankSpace(line_num=807)
		SingleLineComment(line_num=807) // position rel. to body frame              (ncam x 3) 
		BlankSpace(line_num=808)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=808)
		PlaceHolder() cam_quat;
		BlankSpace(line_num=808)
		SingleLineComment(line_num=808) // orientation rel. to body frame           (ncam x 4) 
		BlankSpace(line_num=809)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=809)
		PlaceHolder() cam_poscom0;
		BlankSpace(line_num=809)
		SingleLineComment(line_num=809) // global position rel. to sub-com in qpos0 (ncam x 3) 
		BlankSpace(line_num=810)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=810)
		PlaceHolder() cam_pos0;
		BlankSpace(line_num=810)
		SingleLineComment(line_num=810) // global position rel. to body in qpos0    (ncam x 3) 
		BlankSpace(line_num=811)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=811)
		PlaceHolder() cam_mat0;
		BlankSpace(line_num=811)
		SingleLineComment(line_num=811) // global orientation in qpos0              (ncam x 9) 
		BlankSpace(line_num=812)
		PlaceHolder() int*
		BlankSpace(line_num=812)
		PlaceHolder() cam_orthographic;
		BlankSpace(line_num=812)
		SingleLineComment(line_num=812) // orthographic camera; 0: no, 1: yes       (ncam x 1) 
		BlankSpace(line_num=813)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=813)
		PlaceHolder() cam_fovy;
		BlankSpace(line_num=813)
		SingleLineComment(line_num=813) // y field-of-view (ortho ? len : deg)      (ncam x 1) 
		BlankSpace(line_num=814)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=814)
		PlaceHolder() cam_ipd;
		BlankSpace(line_num=814)
		SingleLineComment(line_num=814) // inter-pupilary distance                  (ncam x 1) 
		BlankSpace(line_num=815)
		PlaceHolder() int*
		BlankSpace(line_num=815)
		PlaceHolder() cam_resolution;
		BlankSpace(line_num=815)
		SingleLineComment(line_num=815) // resolution: pixels [width, height]       (ncam x 2) 
		BlankSpace(line_num=816)
		PlaceHolder() float*
		BlankSpace(line_num=816)
		PlaceHolder() cam_sensorsize;
		BlankSpace(line_num=816)
		SingleLineComment(line_num=816) // sensor size: length [width, height]      (ncam x 2) 
		BlankSpace(line_num=817)
		PlaceHolder() float*
		BlankSpace(line_num=817)
		PlaceHolder() cam_intrinsic;
		BlankSpace(line_num=817)
		SingleLineComment(line_num=817) // [focal length; principal point]          (ncam x 4) 
		BlankSpace(line_num=818)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=818)
		PlaceHolder() cam_user;
		BlankSpace(line_num=818)
		SingleLineComment(line_num=818) // user data                                (ncam x nuser_cam) 
		BlankSpace(line_num=819)
		BlankSpace(line_num=820)
		SingleLineComment(line_num=820) // lights 
		BlankSpace(line_num=821)
		PlaceHolder() int*
		BlankSpace(line_num=821)
		PlaceHolder() light_mode;
		BlankSpace(line_num=821)
		SingleLineComment(line_num=821) // light tracking mode (mjtCamLight)        (nlight x 1) 
		BlankSpace(line_num=822)
		PlaceHolder() int*
		BlankSpace(line_num=822)
		PlaceHolder() light_bodyid;
		BlankSpace(line_num=822)
		SingleLineComment(line_num=822) // id of light's body                       (nlight x 1) 
		BlankSpace(line_num=823)
		PlaceHolder() int*
		BlankSpace(line_num=823)
		PlaceHolder() light_targetbodyid;
		BlankSpace(line_num=823)
		SingleLineComment(line_num=823) // id of targeted body; -1: none            (nlight x 1) 
		BlankSpace(line_num=824)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=824)
		PlaceHolder() light_directional;
		BlankSpace(line_num=824)
		SingleLineComment(line_num=824) // directional light                        (nlight x 1) 
		BlankSpace(line_num=825)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=825)
		PlaceHolder() light_castshadow;
		BlankSpace(line_num=825)
		SingleLineComment(line_num=825) // does light cast shadows                  (nlight x 1) 
		BlankSpace(line_num=826)
		PlaceHolder() float*
		BlankSpace(line_num=826)
		PlaceHolder() light_bulbradius;
		BlankSpace(line_num=826)
		SingleLineComment(line_num=826) // light radius for soft shadows            (nlight x 1) 
		BlankSpace(line_num=827)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=827)
		PlaceHolder() light_active;
		BlankSpace(line_num=827)
		SingleLineComment(line_num=827) // is light on                              (nlight x 1) 
		BlankSpace(line_num=828)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=828)
		PlaceHolder() light_pos;
		BlankSpace(line_num=828)
		SingleLineComment(line_num=828) // position rel. to body frame              (nlight x 3) 
		BlankSpace(line_num=829)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=829)
		PlaceHolder() light_dir;
		BlankSpace(line_num=829)
		SingleLineComment(line_num=829) // direction rel. to body frame             (nlight x 3) 
		BlankSpace(line_num=830)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=830)
		PlaceHolder() light_poscom0;
		BlankSpace(line_num=830)
		SingleLineComment(line_num=830) // global position rel. to sub-com in qpos0 (nlight x 3) 
		BlankSpace(line_num=831)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=831)
		PlaceHolder() light_pos0;
		BlankSpace(line_num=831)
		SingleLineComment(line_num=831) // global position rel. to body in qpos0    (nlight x 3) 
		BlankSpace(line_num=832)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=832)
		PlaceHolder() light_dir0;
		BlankSpace(line_num=832)
		SingleLineComment(line_num=832) // global direction in qpos0                (nlight x 3) 
		BlankSpace(line_num=833)
		PlaceHolder() float*
		BlankSpace(line_num=833)
		PlaceHolder() light_attenuation;
		BlankSpace(line_num=833)
		SingleLineComment(line_num=833) // OpenGL attenuation (quadratic model)     (nlight x 3) 
		BlankSpace(line_num=834)
		PlaceHolder() float*
		BlankSpace(line_num=834)
		PlaceHolder() light_cutoff;
		BlankSpace(line_num=834)
		SingleLineComment(line_num=834) // OpenGL cutoff                            (nlight x 1) 
		BlankSpace(line_num=835)
		PlaceHolder() float*
		BlankSpace(line_num=835)
		PlaceHolder() light_exponent;
		BlankSpace(line_num=835)
		SingleLineComment(line_num=835) // OpenGL exponent                          (nlight x 1) 
		BlankSpace(line_num=836)
		PlaceHolder() float*
		BlankSpace(line_num=836)
		PlaceHolder() light_ambient;
		BlankSpace(line_num=836)
		SingleLineComment(line_num=836) // ambient rgb (alpha=1)                    (nlight x 3) 
		BlankSpace(line_num=837)
		PlaceHolder() float*
		BlankSpace(line_num=837)
		PlaceHolder() light_diffuse;
		BlankSpace(line_num=837)
		SingleLineComment(line_num=837) // diffuse rgb (alpha=1)                    (nlight x 3) 
		BlankSpace(line_num=838)
		PlaceHolder() float*
		BlankSpace(line_num=838)
		PlaceHolder() light_specular;
		BlankSpace(line_num=838)
		SingleLineComment(line_num=838) // specular rgb (alpha=1)                   (nlight x 3) 
		BlankSpace(line_num=839)
		BlankSpace(line_num=840)
		SingleLineComment(line_num=840) // flexes: contact properties 
		BlankSpace(line_num=841)
		PlaceHolder() int*
		BlankSpace(line_num=841)
		PlaceHolder() flex_contype;
		BlankSpace(line_num=841)
		SingleLineComment(line_num=841) // flex contact type                        (nflex x 1) 
		BlankSpace(line_num=842)
		PlaceHolder() int*
		BlankSpace(line_num=842)
		PlaceHolder() flex_conaffinity;
		BlankSpace(line_num=842)
		SingleLineComment(line_num=842) // flex contact affinity                    (nflex x 1) 
		BlankSpace(line_num=843)
		PlaceHolder() int*
		BlankSpace(line_num=843)
		PlaceHolder() flex_condim;
		BlankSpace(line_num=843)
		SingleLineComment(line_num=843) // contact dimensionality (1, 3, 4, 6)      (nflex x 1) 
		BlankSpace(line_num=844)
		PlaceHolder() int*
		BlankSpace(line_num=844)
		PlaceHolder() flex_priority;
		BlankSpace(line_num=844)
		SingleLineComment(line_num=844) // flex contact priority                    (nflex x 1) 
		BlankSpace(line_num=845)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=845)
		PlaceHolder() flex_solmix;
		BlankSpace(line_num=845)
		SingleLineComment(line_num=845) // mix coef for solref/imp in contact pair  (nflex x 1) 
		BlankSpace(line_num=846)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=846)
		PlaceHolder() flex_solref;
		BlankSpace(line_num=846)
		SingleLineComment(line_num=846) // constraint solver reference: contact     (nflex x mjNREF) 
		BlankSpace(line_num=847)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=847)
		PlaceHolder() flex_solimp;
		BlankSpace(line_num=847)
		SingleLineComment(line_num=847) // constraint solver impedance: contact     (nflex x mjNIMP) 
		BlankSpace(line_num=848)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=848)
		PlaceHolder() flex_friction;
		BlankSpace(line_num=848)
		SingleLineComment(line_num=848) // friction for (slide, spin, roll)         (nflex x 3) 
		BlankSpace(line_num=849)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=849)
		PlaceHolder() flex_margin;
		BlankSpace(line_num=849)
		SingleLineComment(line_num=849) // detect contact if dist<margin            (nflex x 1) 
		BlankSpace(line_num=850)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=850)
		PlaceHolder() flex_gap;
		BlankSpace(line_num=850)
		SingleLineComment(line_num=850) // include in solver if dist<margin-gap     (nflex x 1) 
		BlankSpace(line_num=851)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=851)
		PlaceHolder() flex_internal;
		BlankSpace(line_num=851)
		SingleLineComment(line_num=851) // internal flex collision enabled          (nflex x 1) 
		BlankSpace(line_num=852)
		PlaceHolder() int*
		BlankSpace(line_num=852)
		PlaceHolder() flex_selfcollide;
		BlankSpace(line_num=852)
		SingleLineComment(line_num=852) // self collision mode (mjtFlexSelf)        (nflex x 1) 
		BlankSpace(line_num=853)
		PlaceHolder() int*
		BlankSpace(line_num=853)
		PlaceHolder() flex_activelayers;
		BlankSpace(line_num=853)
		SingleLineComment(line_num=853) // number of active element layers, 3D only (nflex x 1) 
		BlankSpace(line_num=854)
		BlankSpace(line_num=855)
		SingleLineComment(line_num=855) // flexes: other properties 
		BlankSpace(line_num=856)
		PlaceHolder() int*
		BlankSpace(line_num=856)
		PlaceHolder() flex_dim;
		BlankSpace(line_num=856)
		SingleLineComment(line_num=856) // 1: lines, 2: triangles, 3: tetrahedra    (nflex x 1) 
		BlankSpace(line_num=857)
		PlaceHolder() int*
		BlankSpace(line_num=857)
		PlaceHolder() flex_matid;
		BlankSpace(line_num=857)
		SingleLineComment(line_num=857) // material id for rendering                (nflex x 1) 
		BlankSpace(line_num=858)
		PlaceHolder() int*
		BlankSpace(line_num=858)
		PlaceHolder() flex_group;
		BlankSpace(line_num=858)
		SingleLineComment(line_num=858) // group for visibility                     (nflex x 1) 
		BlankSpace(line_num=859)
		PlaceHolder() int*
		BlankSpace(line_num=859)
		PlaceHolder() flex_vertadr;
		BlankSpace(line_num=859)
		SingleLineComment(line_num=859) // first vertex address                     (nflex x 1) 
		BlankSpace(line_num=860)
		PlaceHolder() int*
		BlankSpace(line_num=860)
		PlaceHolder() flex_vertnum;
		BlankSpace(line_num=860)
		SingleLineComment(line_num=860) // number of vertices                       (nflex x 1) 
		BlankSpace(line_num=861)
		PlaceHolder() int*
		BlankSpace(line_num=861)
		PlaceHolder() flex_edgeadr;
		BlankSpace(line_num=861)
		SingleLineComment(line_num=861) // first edge address                       (nflex x 1) 
		BlankSpace(line_num=862)
		PlaceHolder() int*
		BlankSpace(line_num=862)
		PlaceHolder() flex_edgenum;
		BlankSpace(line_num=862)
		SingleLineComment(line_num=862) // number of edges                          (nflex x 1) 
		BlankSpace(line_num=863)
		PlaceHolder() int*
		BlankSpace(line_num=863)
		PlaceHolder() flex_elemadr;
		BlankSpace(line_num=863)
		SingleLineComment(line_num=863) // first element address                    (nflex x 1) 
		BlankSpace(line_num=864)
		PlaceHolder() int*
		BlankSpace(line_num=864)
		PlaceHolder() flex_elemnum;
		BlankSpace(line_num=864)
		SingleLineComment(line_num=864) // number of elements                       (nflex x 1) 
		BlankSpace(line_num=865)
		PlaceHolder() int*
		BlankSpace(line_num=865)
		PlaceHolder() flex_elemdataadr;
		BlankSpace(line_num=865)
		SingleLineComment(line_num=865) // first element vertex id address          (nflex x 1) 
		BlankSpace(line_num=866)
		PlaceHolder() int*
		BlankSpace(line_num=866)
		PlaceHolder() flex_elemedgeadr;
		BlankSpace(line_num=866)
		SingleLineComment(line_num=866) // first element edge id address            (nflex x 1) 
		BlankSpace(line_num=867)
		PlaceHolder() int*
		BlankSpace(line_num=867)
		PlaceHolder() flex_shellnum;
		BlankSpace(line_num=867)
		SingleLineComment(line_num=867) // number of shells                         (nflex x 1) 
		BlankSpace(line_num=868)
		PlaceHolder() int*
		BlankSpace(line_num=868)
		PlaceHolder() flex_shelldataadr;
		BlankSpace(line_num=868)
		SingleLineComment(line_num=868) // first shell data address                 (nflex x 1) 
		BlankSpace(line_num=869)
		PlaceHolder() int*
		BlankSpace(line_num=869)
		PlaceHolder() flex_evpairadr;
		BlankSpace(line_num=869)
		SingleLineComment(line_num=869) // first evpair address                     (nflex x 1) 
		BlankSpace(line_num=870)
		PlaceHolder() int*
		BlankSpace(line_num=870)
		PlaceHolder() flex_evpairnum;
		BlankSpace(line_num=870)
		SingleLineComment(line_num=870) // number of evpairs                        (nflex x 1) 
		BlankSpace(line_num=871)
		PlaceHolder() int*
		BlankSpace(line_num=871)
		PlaceHolder() flex_texcoordadr;
		BlankSpace(line_num=871)
		SingleLineComment(line_num=871) // address in flex_texcoord; -1: none       (nflex x 1) 
		BlankSpace(line_num=872)
		PlaceHolder() int*
		BlankSpace(line_num=872)
		PlaceHolder() flex_vertbodyid;
		BlankSpace(line_num=872)
		SingleLineComment(line_num=872) // vertex body ids                          (nflexvert x 1) 
		BlankSpace(line_num=873)
		PlaceHolder() int*
		BlankSpace(line_num=873)
		PlaceHolder() flex_edge;
		BlankSpace(line_num=873)
		SingleLineComment(line_num=873) // edge vertex ids (2 per edge)             (nflexedge x 2) 
		BlankSpace(line_num=874)
		PlaceHolder() int*
		BlankSpace(line_num=874)
		PlaceHolder() flex_elem;
		BlankSpace(line_num=874)
		SingleLineComment(line_num=874) // element vertex ids (dim+1 per elem)      (nflexelemdata x 1) 
		BlankSpace(line_num=875)
		PlaceHolder() int*
		BlankSpace(line_num=875)
		PlaceHolder() flex_elemedge;
		BlankSpace(line_num=875)
		SingleLineComment(line_num=875) // element edge ids                         (nflexelemedge x 1) 
		BlankSpace(line_num=876)
		PlaceHolder() int*
		BlankSpace(line_num=876)
		PlaceHolder() flex_elemlayer;
		BlankSpace(line_num=876)
		SingleLineComment(line_num=876) // element distance from surface, 3D only   (nflexelem x 1) 
		BlankSpace(line_num=877)
		PlaceHolder() int*
		BlankSpace(line_num=877)
		PlaceHolder() flex_shell;
		BlankSpace(line_num=877)
		SingleLineComment(line_num=877) // shell fragment vertex ids (dim per frag) (nflexshelldata x 1) 
		BlankSpace(line_num=878)
		PlaceHolder() int*
		BlankSpace(line_num=878)
		PlaceHolder() flex_evpair;
		BlankSpace(line_num=878)
		SingleLineComment(line_num=878) // (element, vertex) collision pairs        (nflexevpair x 2) 
		BlankSpace(line_num=879)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=879)
		PlaceHolder() flex_vert;
		BlankSpace(line_num=879)
		SingleLineComment(line_num=879) // vertex positions in local body frames    (nflexvert x 3) 
		BlankSpace(line_num=880)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=880)
		PlaceHolder() flex_xvert0;
		BlankSpace(line_num=880)
		SingleLineComment(line_num=880) // Cartesian vertex positions in qpos0      (nflexvert x 3) 
		BlankSpace(line_num=881)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=881)
		PlaceHolder() flexedge_length0;
		BlankSpace(line_num=881)
		SingleLineComment(line_num=881) // edge lengths in qpos0                    (nflexedge x 1) 
		BlankSpace(line_num=882)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=882)
		PlaceHolder() flexedge_invweight0;
		BlankSpace(line_num=882)
		SingleLineComment(line_num=882) // edge inv. weight in qpos0                (nflexedge x 1) 
		BlankSpace(line_num=883)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=883)
		PlaceHolder() flex_radius;
		BlankSpace(line_num=883)
		SingleLineComment(line_num=883) // radius around primitive element          (nflex x 1) 
		BlankSpace(line_num=884)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=884)
		PlaceHolder() flex_stiffness;
		BlankSpace(line_num=884)
		SingleLineComment(line_num=884) // finite element stiffness matrix          (nflexelem x 21) 
		BlankSpace(line_num=885)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=885)
		PlaceHolder() flex_damping;
		BlankSpace(line_num=885)
		SingleLineComment(line_num=885) // Rayleigh's damping coefficient           (nflex x 1) 
		BlankSpace(line_num=886)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=886)
		PlaceHolder() flex_edgestiffness;
		BlankSpace(line_num=886)
		SingleLineComment(line_num=886) // edge stiffness                           (nflex x 1) 
		BlankSpace(line_num=887)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=887)
		PlaceHolder() flex_edgedamping;
		BlankSpace(line_num=887)
		SingleLineComment(line_num=887) // edge damping                             (nflex x 1) 
		BlankSpace(line_num=888)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=888)
		PlaceHolder() flex_edgeequality;
		BlankSpace(line_num=888)
		SingleLineComment(line_num=888) // is edge equality constraint defined      (nflex x 1) 
		BlankSpace(line_num=889)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=889)
		PlaceHolder() flex_rigid;
		BlankSpace(line_num=889)
		SingleLineComment(line_num=889) // are all verices in the same body         (nflex x 1) 
		BlankSpace(line_num=890)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=890)
		PlaceHolder() flexedge_rigid;
		BlankSpace(line_num=890)
		SingleLineComment(line_num=890) // are both edge vertices in same body      (nflexedge x 1) 
		BlankSpace(line_num=891)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=891)
		PlaceHolder() flex_centered;
		BlankSpace(line_num=891)
		SingleLineComment(line_num=891) // are all vertex coordinates (0,0,0)       (nflex x 1) 
		BlankSpace(line_num=892)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=892)
		PlaceHolder() flex_flatskin;
		BlankSpace(line_num=892)
		SingleLineComment(line_num=892) // render flex skin with flat shading       (nflex x 1) 
		BlankSpace(line_num=893)
		PlaceHolder() int*
		BlankSpace(line_num=893)
		PlaceHolder() flex_bvhadr;
		BlankSpace(line_num=893)
		SingleLineComment(line_num=893) // address of bvh root; -1: no bvh          (nflex x 1) 
		BlankSpace(line_num=894)
		PlaceHolder() int*
		BlankSpace(line_num=894)
		PlaceHolder() flex_bvhnum;
		BlankSpace(line_num=894)
		SingleLineComment(line_num=894) // number of bounding volumes               (nflex x 1) 
		BlankSpace(line_num=895)
		PlaceHolder() float*
		BlankSpace(line_num=895)
		PlaceHolder() flex_rgba;
		BlankSpace(line_num=895)
		SingleLineComment(line_num=895) // rgba when material is omitted            (nflex x 4) 
		BlankSpace(line_num=896)
		PlaceHolder() float*
		BlankSpace(line_num=896)
		PlaceHolder() flex_texcoord;
		BlankSpace(line_num=896)
		SingleLineComment(line_num=896) // vertex texture coordinates               (nflextexcoord x 2) 
		BlankSpace(line_num=897)
		BlankSpace(line_num=898)
		SingleLineComment(line_num=898) // meshes 
		BlankSpace(line_num=899)
		PlaceHolder() int*
		BlankSpace(line_num=899)
		PlaceHolder() mesh_vertadr;
		BlankSpace(line_num=899)
		SingleLineComment(line_num=899) // first vertex address                     (nmesh x 1) 
		BlankSpace(line_num=900)
		PlaceHolder() int*
		BlankSpace(line_num=900)
		PlaceHolder() mesh_vertnum;
		BlankSpace(line_num=900)
		SingleLineComment(line_num=900) // number of vertices                       (nmesh x 1) 
		BlankSpace(line_num=901)
		PlaceHolder() int*
		BlankSpace(line_num=901)
		PlaceHolder() mesh_faceadr;
		BlankSpace(line_num=901)
		SingleLineComment(line_num=901) // first face address                       (nmesh x 1) 
		BlankSpace(line_num=902)
		PlaceHolder() int*
		BlankSpace(line_num=902)
		PlaceHolder() mesh_facenum;
		BlankSpace(line_num=902)
		SingleLineComment(line_num=902) // number of faces                          (nmesh x 1) 
		BlankSpace(line_num=903)
		PlaceHolder() int*
		BlankSpace(line_num=903)
		PlaceHolder() mesh_bvhadr;
		BlankSpace(line_num=903)
		SingleLineComment(line_num=903) // address of bvh root                      (nmesh x 1) 
		BlankSpace(line_num=904)
		PlaceHolder() int*
		BlankSpace(line_num=904)
		PlaceHolder() mesh_bvhnum;
		BlankSpace(line_num=904)
		SingleLineComment(line_num=904) // number of bvh                            (nmesh x 1) 
		BlankSpace(line_num=905)
		PlaceHolder() int*
		BlankSpace(line_num=905)
		PlaceHolder() mesh_normaladr;
		BlankSpace(line_num=905)
		SingleLineComment(line_num=905) // first normal address                     (nmesh x 1) 
		BlankSpace(line_num=906)
		PlaceHolder() int*
		BlankSpace(line_num=906)
		PlaceHolder() mesh_normalnum;
		BlankSpace(line_num=906)
		SingleLineComment(line_num=906) // number of normals                        (nmesh x 1) 
		BlankSpace(line_num=907)
		PlaceHolder() int*
		BlankSpace(line_num=907)
		PlaceHolder() mesh_texcoordadr;
		BlankSpace(line_num=907)
		SingleLineComment(line_num=907) // texcoord data address; -1: no texcoord   (nmesh x 1) 
		BlankSpace(line_num=908)
		PlaceHolder() int*
		BlankSpace(line_num=908)
		PlaceHolder() mesh_texcoordnum;
		BlankSpace(line_num=908)
		SingleLineComment(line_num=908) // number of texcoord                       (nmesh x 1) 
		BlankSpace(line_num=909)
		PlaceHolder() int*
		BlankSpace(line_num=909)
		PlaceHolder() mesh_graphadr;
		BlankSpace(line_num=909)
		SingleLineComment(line_num=909) // graph data address; -1: no graph         (nmesh x 1) 
		BlankSpace(line_num=910)
		PlaceHolder() float*
		BlankSpace(line_num=910)
		PlaceHolder() mesh_vert;
		BlankSpace(line_num=910)
		SingleLineComment(line_num=910) // vertex positions for all meshes          (nmeshvert x 3) 
		BlankSpace(line_num=911)
		PlaceHolder() float*
		BlankSpace(line_num=911)
		PlaceHolder() mesh_normal;
		BlankSpace(line_num=911)
		SingleLineComment(line_num=911) // normals for all meshes                   (nmeshnormal x 3) 
		BlankSpace(line_num=912)
		PlaceHolder() float*
		BlankSpace(line_num=912)
		PlaceHolder() mesh_texcoord;
		BlankSpace(line_num=912)
		SingleLineComment(line_num=912) // vertex texcoords for all meshes          (nmeshtexcoord x 2) 
		BlankSpace(line_num=913)
		PlaceHolder() int*
		BlankSpace(line_num=913)
		PlaceHolder() mesh_face;
		BlankSpace(line_num=913)
		SingleLineComment(line_num=913) // vertex face data                         (nmeshface x 3) 
		BlankSpace(line_num=914)
		PlaceHolder() int*
		BlankSpace(line_num=914)
		PlaceHolder() mesh_facenormal;
		BlankSpace(line_num=914)
		SingleLineComment(line_num=914) // normal face data                         (nmeshface x 3) 
		BlankSpace(line_num=915)
		PlaceHolder() int*
		BlankSpace(line_num=915)
		PlaceHolder() mesh_facetexcoord;
		BlankSpace(line_num=915)
		SingleLineComment(line_num=915) // texture face data                        (nmeshface x 3) 
		BlankSpace(line_num=916)
		PlaceHolder() int*
		BlankSpace(line_num=916)
		PlaceHolder() mesh_graph;
		BlankSpace(line_num=916)
		SingleLineComment(line_num=916) // convex graph data                        (nmeshgraph x 1) 
		BlankSpace(line_num=917)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=917)
		PlaceHolder() mesh_scale;
		BlankSpace(line_num=917)
		SingleLineComment(line_num=917) // scaling applied to asset vertices        (nmesh x 3) 
		BlankSpace(line_num=918)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=918)
		PlaceHolder() mesh_pos;
		BlankSpace(line_num=918)
		SingleLineComment(line_num=918) // translation applied to asset vertices    (nmesh x 3) 
		BlankSpace(line_num=919)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=919)
		PlaceHolder() mesh_quat;
		BlankSpace(line_num=919)
		SingleLineComment(line_num=919) // rotation applied to asset vertices       (nmesh x 4) 
		BlankSpace(line_num=920)
		PlaceHolder() int*
		BlankSpace(line_num=920)
		PlaceHolder() mesh_pathadr;
		BlankSpace(line_num=920)
		SingleLineComment(line_num=920) // address of asset path for mesh; -1: none (nmesh x 1) 
		BlankSpace(line_num=921)
		BlankSpace(line_num=922)
		SingleLineComment(line_num=922) // skins 
		BlankSpace(line_num=923)
		PlaceHolder() int*
		BlankSpace(line_num=923)
		PlaceHolder() skin_matid;
		BlankSpace(line_num=923)
		SingleLineComment(line_num=923) // skin material id; -1: none               (nskin x 1) 
		BlankSpace(line_num=924)
		PlaceHolder() int*
		BlankSpace(line_num=924)
		PlaceHolder() skin_group;
		BlankSpace(line_num=924)
		SingleLineComment(line_num=924) // group for visibility                     (nskin x 1) 
		BlankSpace(line_num=925)
		PlaceHolder() float*
		BlankSpace(line_num=925)
		PlaceHolder() skin_rgba;
		BlankSpace(line_num=925)
		SingleLineComment(line_num=925) // skin rgba                                (nskin x 4) 
		BlankSpace(line_num=926)
		PlaceHolder() float*
		BlankSpace(line_num=926)
		PlaceHolder() skin_inflate;
		BlankSpace(line_num=926)
		SingleLineComment(line_num=926) // inflate skin in normal direction         (nskin x 1) 
		BlankSpace(line_num=927)
		PlaceHolder() int*
		BlankSpace(line_num=927)
		PlaceHolder() skin_vertadr;
		BlankSpace(line_num=927)
		SingleLineComment(line_num=927) // first vertex address                     (nskin x 1) 
		BlankSpace(line_num=928)
		PlaceHolder() int*
		BlankSpace(line_num=928)
		PlaceHolder() skin_vertnum;
		BlankSpace(line_num=928)
		SingleLineComment(line_num=928) // number of vertices                       (nskin x 1) 
		BlankSpace(line_num=929)
		PlaceHolder() int*
		BlankSpace(line_num=929)
		PlaceHolder() skin_texcoordadr;
		BlankSpace(line_num=929)
		SingleLineComment(line_num=929) // texcoord data address; -1: no texcoord   (nskin x 1) 
		BlankSpace(line_num=930)
		PlaceHolder() int*
		BlankSpace(line_num=930)
		PlaceHolder() skin_faceadr;
		BlankSpace(line_num=930)
		SingleLineComment(line_num=930) // first face address                       (nskin x 1) 
		BlankSpace(line_num=931)
		PlaceHolder() int*
		BlankSpace(line_num=931)
		PlaceHolder() skin_facenum;
		BlankSpace(line_num=931)
		SingleLineComment(line_num=931) // number of faces                          (nskin x 1) 
		BlankSpace(line_num=932)
		PlaceHolder() int*
		BlankSpace(line_num=932)
		PlaceHolder() skin_boneadr;
		BlankSpace(line_num=932)
		SingleLineComment(line_num=932) // first bone in skin                       (nskin x 1) 
		BlankSpace(line_num=933)
		PlaceHolder() int*
		BlankSpace(line_num=933)
		PlaceHolder() skin_bonenum;
		BlankSpace(line_num=933)
		SingleLineComment(line_num=933) // number of bones in skin                  (nskin x 1) 
		BlankSpace(line_num=934)
		PlaceHolder() float*
		BlankSpace(line_num=934)
		PlaceHolder() skin_vert;
		BlankSpace(line_num=934)
		SingleLineComment(line_num=934) // vertex positions for all skin meshes     (nskinvert x 3) 
		BlankSpace(line_num=935)
		PlaceHolder() float*
		BlankSpace(line_num=935)
		PlaceHolder() skin_texcoord;
		BlankSpace(line_num=935)
		SingleLineComment(line_num=935) // vertex texcoords for all skin meshes     (nskintexvert x 2) 
		BlankSpace(line_num=936)
		PlaceHolder() int*
		BlankSpace(line_num=936)
		PlaceHolder() skin_face;
		BlankSpace(line_num=936)
		SingleLineComment(line_num=936) // triangle faces for all skin meshes       (nskinface x 3) 
		BlankSpace(line_num=937)
		PlaceHolder() int*
		BlankSpace(line_num=937)
		PlaceHolder() skin_bonevertadr;
		BlankSpace(line_num=937)
		SingleLineComment(line_num=937) // first vertex in each bone                (nskinbone x 1) 
		BlankSpace(line_num=938)
		PlaceHolder() int*
		BlankSpace(line_num=938)
		PlaceHolder() skin_bonevertnum;
		BlankSpace(line_num=938)
		SingleLineComment(line_num=938) // number of vertices in each bone          (nskinbone x 1) 
		BlankSpace(line_num=939)
		PlaceHolder() float*
		BlankSpace(line_num=939)
		PlaceHolder() skin_bonebindpos;
		BlankSpace(line_num=939)
		SingleLineComment(line_num=939) // bind pos of each bone                    (nskinbone x 3) 
		BlankSpace(line_num=940)
		PlaceHolder() float*
		BlankSpace(line_num=940)
		PlaceHolder() skin_bonebindquat;
		BlankSpace(line_num=940)
		SingleLineComment(line_num=940) // bind quat of each bone                   (nskinbone x 4) 
		BlankSpace(line_num=941)
		PlaceHolder() int*
		BlankSpace(line_num=941)
		PlaceHolder() skin_bonebodyid;
		BlankSpace(line_num=941)
		SingleLineComment(line_num=941) // body id of each bone                     (nskinbone x 1) 
		BlankSpace(line_num=942)
		PlaceHolder() int*
		BlankSpace(line_num=942)
		PlaceHolder() skin_bonevertid;
		BlankSpace(line_num=942)
		SingleLineComment(line_num=942) // mesh ids of vertices in each bone        (nskinbonevert x 1) 
		BlankSpace(line_num=943)
		PlaceHolder() float*
		BlankSpace(line_num=943)
		PlaceHolder() skin_bonevertweight;
		BlankSpace(line_num=943)
		SingleLineComment(line_num=943) // weights of vertices in each bone         (nskinbonevert x 1) 
		BlankSpace(line_num=944)
		PlaceHolder() int*
		BlankSpace(line_num=944)
		PlaceHolder() skin_pathadr;
		BlankSpace(line_num=944)
		SingleLineComment(line_num=944) // address of asset path for skin; -1: none (nskin x 1) 
		BlankSpace(line_num=945)
		BlankSpace(line_num=946)
		SingleLineComment(line_num=946) // height fields 
		BlankSpace(line_num=947)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=947)
		PlaceHolder() hfield_size;
		BlankSpace(line_num=947)
		SingleLineComment(line_num=947) // (x, y, z_top, z_bottom)                  (nhfield x 4) 
		BlankSpace(line_num=948)
		PlaceHolder() int*
		BlankSpace(line_num=948)
		PlaceHolder() hfield_nrow;
		BlankSpace(line_num=948)
		SingleLineComment(line_num=948) // number of rows in grid                   (nhfield x 1) 
		BlankSpace(line_num=949)
		PlaceHolder() int*
		BlankSpace(line_num=949)
		PlaceHolder() hfield_ncol;
		BlankSpace(line_num=949)
		SingleLineComment(line_num=949) // number of columns in grid                (nhfield x 1) 
		BlankSpace(line_num=950)
		PlaceHolder() int*
		BlankSpace(line_num=950)
		PlaceHolder() hfield_adr;
		BlankSpace(line_num=950)
		SingleLineComment(line_num=950) // address in hfield_data                   (nhfield x 1) 
		BlankSpace(line_num=951)
		PlaceHolder() float*
		BlankSpace(line_num=951)
		PlaceHolder() hfield_data;
		BlankSpace(line_num=951)
		SingleLineComment(line_num=951) // elevation data                           (nhfielddata x 1) 
		BlankSpace(line_num=952)
		PlaceHolder() int*
		BlankSpace(line_num=952)
		PlaceHolder() hfield_pathadr;
		BlankSpace(line_num=952)
		SingleLineComment(line_num=952) // address of hfield asset path; -1: none   (nhfield x 1) 
		BlankSpace(line_num=953)
		BlankSpace(line_num=954)
		SingleLineComment(line_num=954) // textures 
		BlankSpace(line_num=955)
		PlaceHolder() int*
		BlankSpace(line_num=955)
		PlaceHolder() tex_type;
		BlankSpace(line_num=955)
		SingleLineComment(line_num=955) // texture type (mjtTexture)                (ntex x 1) 
		BlankSpace(line_num=956)
		PlaceHolder() int*
		BlankSpace(line_num=956)
		PlaceHolder() tex_height;
		BlankSpace(line_num=956)
		SingleLineComment(line_num=956) // number of rows in texture image          (ntex x 1) 
		BlankSpace(line_num=957)
		PlaceHolder() int*
		BlankSpace(line_num=957)
		PlaceHolder() tex_width;
		BlankSpace(line_num=957)
		SingleLineComment(line_num=957) // number of columns in texture image       (ntex x 1) 
		BlankSpace(line_num=958)
		PlaceHolder() int*
		BlankSpace(line_num=958)
		PlaceHolder() tex_nchannel;
		BlankSpace(line_num=958)
		SingleLineComment(line_num=958) // number of channels in texture image      (ntex x 1) 
		BlankSpace(line_num=959)
		PlaceHolder() int*
		BlankSpace(line_num=959)
		PlaceHolder() tex_adr;
		BlankSpace(line_num=959)
		SingleLineComment(line_num=959) // start address in tex_data                (ntex x 1) 
		BlankSpace(line_num=960)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=960)
		PlaceHolder() tex_data;
		BlankSpace(line_num=960)
		SingleLineComment(line_num=960) // pixel values                             (ntexdata x 1) 
		BlankSpace(line_num=961)
		PlaceHolder() int*
		BlankSpace(line_num=961)
		PlaceHolder() tex_pathadr;
		BlankSpace(line_num=961)
		SingleLineComment(line_num=961) // address of texture asset path; -1: none  (ntex x 1) 
		BlankSpace(line_num=962)
		BlankSpace(line_num=963)
		SingleLineComment(line_num=963) // materials 
		BlankSpace(line_num=964)
		PlaceHolder() int*
		BlankSpace(line_num=964)
		PlaceHolder() mat_texid;
		BlankSpace(line_num=964)
		SingleLineComment(line_num=964) // indices of textures; -1: none            (nmat x mjNTEXROLE) 
		BlankSpace(line_num=965)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=965)
		PlaceHolder() mat_texuniform;
		BlankSpace(line_num=965)
		SingleLineComment(line_num=965) // make texture cube uniform                (nmat x 1) 
		BlankSpace(line_num=966)
		PlaceHolder() float*
		BlankSpace(line_num=966)
		PlaceHolder() mat_texrepeat;
		BlankSpace(line_num=966)
		SingleLineComment(line_num=966) // texture repetition for 2d mapping        (nmat x 2) 
		BlankSpace(line_num=967)
		PlaceHolder() float*
		BlankSpace(line_num=967)
		PlaceHolder() mat_emission;
		BlankSpace(line_num=967)
		SingleLineComment(line_num=967) // emission (x rgb)                         (nmat x 1) 
		BlankSpace(line_num=968)
		PlaceHolder() float*
		BlankSpace(line_num=968)
		PlaceHolder() mat_specular;
		BlankSpace(line_num=968)
		SingleLineComment(line_num=968) // specular (x white)                       (nmat x 1) 
		BlankSpace(line_num=969)
		PlaceHolder() float*
		BlankSpace(line_num=969)
		PlaceHolder() mat_shininess;
		BlankSpace(line_num=969)
		SingleLineComment(line_num=969) // shininess coef                           (nmat x 1) 
		BlankSpace(line_num=970)
		PlaceHolder() float*
		BlankSpace(line_num=970)
		PlaceHolder() mat_reflectance;
		BlankSpace(line_num=970)
		SingleLineComment(line_num=970) // reflectance (0: disable)                 (nmat x 1) 
		BlankSpace(line_num=971)
		PlaceHolder() float*
		BlankSpace(line_num=971)
		PlaceHolder() mat_metallic;
		BlankSpace(line_num=971)
		SingleLineComment(line_num=971) // metallic coef                            (nmat x 1) 
		BlankSpace(line_num=972)
		PlaceHolder() float*
		BlankSpace(line_num=972)
		PlaceHolder() mat_roughness;
		BlankSpace(line_num=972)
		SingleLineComment(line_num=972) // roughness coef                           (nmat x 1) 
		BlankSpace(line_num=973)
		PlaceHolder() float*
		BlankSpace(line_num=973)
		PlaceHolder() mat_rgba;
		BlankSpace(line_num=973)
		SingleLineComment(line_num=973) // rgba                                     (nmat x 4) 
		BlankSpace(line_num=974)
		BlankSpace(line_num=975)
		SingleLineComment(line_num=975) // predefined geom pairs for collision detection; has precedence over exclude 
		BlankSpace(line_num=976)
		PlaceHolder() int*
		BlankSpace(line_num=976)
		PlaceHolder() pair_dim;
		BlankSpace(line_num=976)
		SingleLineComment(line_num=976) // contact dimensionality                   (npair x 1) 
		BlankSpace(line_num=977)
		PlaceHolder() int*
		BlankSpace(line_num=977)
		PlaceHolder() pair_geom1;
		BlankSpace(line_num=977)
		SingleLineComment(line_num=977) // id of geom1                              (npair x 1) 
		BlankSpace(line_num=978)
		PlaceHolder() int*
		BlankSpace(line_num=978)
		PlaceHolder() pair_geom2;
		BlankSpace(line_num=978)
		SingleLineComment(line_num=978) // id of geom2                              (npair x 1) 
		BlankSpace(line_num=979)
		PlaceHolder() int*
		BlankSpace(line_num=979)
		PlaceHolder() pair_signature;
		BlankSpace(line_num=979)
		SingleLineComment(line_num=979) // body1 << 16 + body2                      (npair x 1) 
		BlankSpace(line_num=980)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=980)
		PlaceHolder() pair_solref;
		BlankSpace(line_num=980)
		SingleLineComment(line_num=980) // solver reference: contact normal         (npair x mjNREF) 
		BlankSpace(line_num=981)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=981)
		PlaceHolder() pair_solreffriction;
		BlankSpace(line_num=981)
		SingleLineComment(line_num=981) // solver reference: contact friction       (npair x mjNREF) 
		BlankSpace(line_num=982)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=982)
		PlaceHolder() pair_solimp;
		BlankSpace(line_num=982)
		SingleLineComment(line_num=982) // solver impedance: contact                (npair x mjNIMP) 
		BlankSpace(line_num=983)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=983)
		PlaceHolder() pair_margin;
		BlankSpace(line_num=983)
		SingleLineComment(line_num=983) // detect contact if dist<margin            (npair x 1) 
		BlankSpace(line_num=984)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=984)
		PlaceHolder() pair_gap;
		BlankSpace(line_num=984)
		SingleLineComment(line_num=984) // include in solver if dist<margin-gap     (npair x 1) 
		BlankSpace(line_num=985)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=985)
		PlaceHolder() pair_friction;
		BlankSpace(line_num=985)
		SingleLineComment(line_num=985) // tangent1, 2, spin, roll1, 2              (npair x 5) 
		BlankSpace(line_num=986)
		BlankSpace(line_num=987)
		SingleLineComment(line_num=987) // excluded body pairs for collision detection 
		BlankSpace(line_num=988)
		PlaceHolder() int*
		BlankSpace(line_num=988)
		PlaceHolder() exclude_signature;
		BlankSpace(line_num=988)
		SingleLineComment(line_num=988) // body1 << 16 + body2                      (nexclude x 1) 
		BlankSpace(line_num=989)
		BlankSpace(line_num=990)
		SingleLineComment(line_num=990) // equality constraints 
		BlankSpace(line_num=991)
		PlaceHolder() int*
		BlankSpace(line_num=991)
		PlaceHolder() eq_type;
		BlankSpace(line_num=991)
		SingleLineComment(line_num=991) // constraint type (mjtEq)                  (neq x 1) 
		BlankSpace(line_num=992)
		PlaceHolder() int*
		BlankSpace(line_num=992)
		PlaceHolder() eq_obj1id;
		BlankSpace(line_num=992)
		SingleLineComment(line_num=992) // id of object 1                           (neq x 1) 
		BlankSpace(line_num=993)
		PlaceHolder() int*
		BlankSpace(line_num=993)
		PlaceHolder() eq_obj2id;
		BlankSpace(line_num=993)
		SingleLineComment(line_num=993) // id of object 2                           (neq x 1) 
		BlankSpace(line_num=994)
		PlaceHolder() int*
		BlankSpace(line_num=994)
		PlaceHolder() eq_objtype;
		BlankSpace(line_num=994)
		SingleLineComment(line_num=994) // type of both objects (mjtObj)            (neq x 1) 
		BlankSpace(line_num=995)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=995)
		PlaceHolder() eq_active0;
		BlankSpace(line_num=995)
		SingleLineComment(line_num=995) // initial enable/disable constraint state  (neq x 1) 
		BlankSpace(line_num=996)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=996)
		PlaceHolder() eq_solref;
		BlankSpace(line_num=996)
		SingleLineComment(line_num=996) // constraint solver reference              (neq x mjNREF) 
		BlankSpace(line_num=997)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=997)
		PlaceHolder() eq_solimp;
		BlankSpace(line_num=997)
		SingleLineComment(line_num=997) // constraint solver impedance              (neq x mjNIMP) 
		BlankSpace(line_num=998)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=998)
		PlaceHolder() eq_data;
		BlankSpace(line_num=998)
		SingleLineComment(line_num=998) // numeric data for constraint              (neq x mjNEQDATA) 
		BlankSpace(line_num=999)
		BlankSpace(line_num=1000)
		SingleLineComment(line_num=1000) // tendons 
		BlankSpace(line_num=1001)
		PlaceHolder() int*
		BlankSpace(line_num=1001)
		PlaceHolder() tendon_adr;
		BlankSpace(line_num=1001)
		SingleLineComment(line_num=1001) // address of first object in tendon's path (ntendon x 1) 
		BlankSpace(line_num=1002)
		PlaceHolder() int*
		BlankSpace(line_num=1002)
		PlaceHolder() tendon_num;
		BlankSpace(line_num=1002)
		SingleLineComment(line_num=1002) // number of objects in tendon's path       (ntendon x 1) 
		BlankSpace(line_num=1003)
		PlaceHolder() int*
		BlankSpace(line_num=1003)
		PlaceHolder() tendon_matid;
		BlankSpace(line_num=1003)
		SingleLineComment(line_num=1003) // material id for rendering                (ntendon x 1) 
		BlankSpace(line_num=1004)
		PlaceHolder() int*
		BlankSpace(line_num=1004)
		PlaceHolder() tendon_group;
		BlankSpace(line_num=1004)
		SingleLineComment(line_num=1004) // group for visibility                     (ntendon x 1) 
		BlankSpace(line_num=1005)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=1005)
		PlaceHolder() tendon_limited;
		BlankSpace(line_num=1005)
		SingleLineComment(line_num=1005) // does tendon have length limits           (ntendon x 1) 
		BlankSpace(line_num=1006)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1006)
		PlaceHolder() tendon_width;
		BlankSpace(line_num=1006)
		SingleLineComment(line_num=1006) // width for rendering                      (ntendon x 1) 
		BlankSpace(line_num=1007)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1007)
		PlaceHolder() tendon_solref_lim;
		BlankSpace(line_num=1007)
		SingleLineComment(line_num=1007) // constraint solver reference: limit       (ntendon x mjNREF) 
		BlankSpace(line_num=1008)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1008)
		PlaceHolder() tendon_solimp_lim;
		BlankSpace(line_num=1008)
		SingleLineComment(line_num=1008) // constraint solver impedance: limit       (ntendon x mjNIMP) 
		BlankSpace(line_num=1009)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1009)
		PlaceHolder() tendon_solref_fri;
		BlankSpace(line_num=1009)
		SingleLineComment(line_num=1009) // constraint solver reference: friction    (ntendon x mjNREF) 
		BlankSpace(line_num=1010)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1010)
		PlaceHolder() tendon_solimp_fri;
		BlankSpace(line_num=1010)
		SingleLineComment(line_num=1010) // constraint solver impedance: friction    (ntendon x mjNIMP) 
		BlankSpace(line_num=1011)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1011)
		PlaceHolder() tendon_range;
		BlankSpace(line_num=1011)
		SingleLineComment(line_num=1011) // tendon length limits                     (ntendon x 2) 
		BlankSpace(line_num=1012)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1012)
		PlaceHolder() tendon_margin;
		BlankSpace(line_num=1012)
		SingleLineComment(line_num=1012) // min distance for limit detection         (ntendon x 1) 
		BlankSpace(line_num=1013)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1013)
		PlaceHolder() tendon_stiffness;
		BlankSpace(line_num=1013)
		SingleLineComment(line_num=1013) // stiffness coefficient                    (ntendon x 1) 
		BlankSpace(line_num=1014)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1014)
		PlaceHolder() tendon_damping;
		BlankSpace(line_num=1014)
		SingleLineComment(line_num=1014) // damping coefficient                      (ntendon x 1) 
		BlankSpace(line_num=1015)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1015)
		PlaceHolder() tendon_frictionloss;
		BlankSpace(line_num=1015)
		SingleLineComment(line_num=1015) // loss due to friction                     (ntendon x 1) 
		BlankSpace(line_num=1016)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1016)
		PlaceHolder() tendon_lengthspring;
		BlankSpace(line_num=1016)
		SingleLineComment(line_num=1016) // spring resting length range              (ntendon x 2) 
		BlankSpace(line_num=1017)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1017)
		PlaceHolder() tendon_length0;
		BlankSpace(line_num=1017)
		SingleLineComment(line_num=1017) // tendon length in qpos0                   (ntendon x 1) 
		BlankSpace(line_num=1018)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1018)
		PlaceHolder() tendon_invweight0;
		BlankSpace(line_num=1018)
		SingleLineComment(line_num=1018) // inv. weight in qpos0                     (ntendon x 1) 
		BlankSpace(line_num=1019)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1019)
		PlaceHolder() tendon_user;
		BlankSpace(line_num=1019)
		SingleLineComment(line_num=1019) // user data                                (ntendon x nuser_tendon) 
		BlankSpace(line_num=1020)
		PlaceHolder() float*
		BlankSpace(line_num=1020)
		PlaceHolder() tendon_rgba;
		BlankSpace(line_num=1020)
		SingleLineComment(line_num=1020) // rgba when material is omitted            (ntendon x 4) 
		BlankSpace(line_num=1021)
		BlankSpace(line_num=1022)
		SingleLineComment(line_num=1022) // list of all wrap objects in tendon paths 
		BlankSpace(line_num=1023)
		PlaceHolder() int*
		BlankSpace(line_num=1023)
		PlaceHolder() wrap_type;
		BlankSpace(line_num=1023)
		SingleLineComment(line_num=1023) // wrap object type (mjtWrap)               (nwrap x 1) 
		BlankSpace(line_num=1024)
		PlaceHolder() int*
		BlankSpace(line_num=1024)
		PlaceHolder() wrap_objid;
		BlankSpace(line_num=1024)
		SingleLineComment(line_num=1024) // object id: geom, site, joint             (nwrap x 1) 
		BlankSpace(line_num=1025)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1025)
		PlaceHolder() wrap_prm;
		BlankSpace(line_num=1025)
		SingleLineComment(line_num=1025) // divisor, joint coef, or site id          (nwrap x 1) 
		BlankSpace(line_num=1026)
		BlankSpace(line_num=1027)
		SingleLineComment(line_num=1027) // actuators 
		BlankSpace(line_num=1028)
		PlaceHolder() int*
		BlankSpace(line_num=1028)
		PlaceHolder() actuator_trntype;
		BlankSpace(line_num=1028)
		SingleLineComment(line_num=1028) // transmission type (mjtTrn)               (nu x 1) 
		BlankSpace(line_num=1029)
		PlaceHolder() int*
		BlankSpace(line_num=1029)
		PlaceHolder() actuator_dyntype;
		BlankSpace(line_num=1029)
		SingleLineComment(line_num=1029) // dynamics type (mjtDyn)                   (nu x 1) 
		BlankSpace(line_num=1030)
		PlaceHolder() int*
		BlankSpace(line_num=1030)
		PlaceHolder() actuator_gaintype;
		BlankSpace(line_num=1030)
		SingleLineComment(line_num=1030) // gain type (mjtGain)                      (nu x 1) 
		BlankSpace(line_num=1031)
		PlaceHolder() int*
		BlankSpace(line_num=1031)
		PlaceHolder() actuator_biastype;
		BlankSpace(line_num=1031)
		SingleLineComment(line_num=1031) // bias type (mjtBias)                      (nu x 1) 
		BlankSpace(line_num=1032)
		PlaceHolder() int*
		BlankSpace(line_num=1032)
		PlaceHolder() actuator_trnid;
		BlankSpace(line_num=1032)
		SingleLineComment(line_num=1032) // transmission id: joint, tendon, site     (nu x 2) 
		BlankSpace(line_num=1033)
		PlaceHolder() int*
		BlankSpace(line_num=1033)
		PlaceHolder() actuator_actadr;
		BlankSpace(line_num=1033)
		SingleLineComment(line_num=1033) // first activation address; -1: stateless  (nu x 1) 
		BlankSpace(line_num=1034)
		PlaceHolder() int*
		BlankSpace(line_num=1034)
		PlaceHolder() actuator_actnum;
		BlankSpace(line_num=1034)
		SingleLineComment(line_num=1034) // number of activation variables           (nu x 1) 
		BlankSpace(line_num=1035)
		PlaceHolder() int*
		BlankSpace(line_num=1035)
		PlaceHolder() actuator_group;
		BlankSpace(line_num=1035)
		SingleLineComment(line_num=1035) // group for visibility                     (nu x 1) 
		BlankSpace(line_num=1036)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=1036)
		PlaceHolder() actuator_ctrllimited;
		SingleLineComment(line_num=1036) // is control limited                       (nu x 1) 
		BlankSpace(line_num=1037)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=1037)
		PlaceHolder() actuator_forcelimited;//
		PlaceHolder() is
		PlaceHolder() force
		PlaceHolder() limited
		BlankSpace(line_num=1037)
		PlaceHolder() (nu
		PlaceHolder() x
		PlaceHolder() 1)
		BlankSpace(line_num=1038)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=1038)
		PlaceHolder() actuator_actlimited;
		BlankSpace(line_num=1038)
		SingleLineComment(line_num=1038) // is activation limited                    (nu x 1) 
		BlankSpace(line_num=1039)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1039)
		PlaceHolder() actuator_dynprm;
		BlankSpace(line_num=1039)
		SingleLineComment(line_num=1039) // dynamics parameters                      (nu x mjNDYN) 
		BlankSpace(line_num=1040)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1040)
		PlaceHolder() actuator_gainprm;
		BlankSpace(line_num=1040)
		SingleLineComment(line_num=1040) // gain parameters                          (nu x mjNGAIN) 
		BlankSpace(line_num=1041)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1041)
		PlaceHolder() actuator_biasprm;
		BlankSpace(line_num=1041)
		SingleLineComment(line_num=1041) // bias parameters                          (nu x mjNBIAS) 
		BlankSpace(line_num=1042)
		PlaceHolder() mjtByte*
		BlankSpace(line_num=1042)
		PlaceHolder() actuator_actearly;
		BlankSpace(line_num=1042)
		SingleLineComment(line_num=1042) // step activation before force             (nu x 1) 
		BlankSpace(line_num=1043)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1043)
		PlaceHolder() actuator_ctrlrange;
		BlankSpace(line_num=1043)
		SingleLineComment(line_num=1043) // range of controls                        (nu x 2) 
		BlankSpace(line_num=1044)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1044)
		PlaceHolder() actuator_forcerange;
		BlankSpace(line_num=1044)
		SingleLineComment(line_num=1044) // range of forces                          (nu x 2) 
		BlankSpace(line_num=1045)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1045)
		PlaceHolder() actuator_actrange;
		BlankSpace(line_num=1045)
		SingleLineComment(line_num=1045) // range of activations                     (nu x 2) 
		BlankSpace(line_num=1046)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1046)
		PlaceHolder() actuator_gear;
		BlankSpace(line_num=1046)
		SingleLineComment(line_num=1046) // scale length and transmitted force       (nu x 6) 
		BlankSpace(line_num=1047)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1047)
		PlaceHolder() actuator_cranklength;
		SingleLineComment(line_num=1047) // crank length for slider-crank            (nu x 1) 
		BlankSpace(line_num=1048)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1048)
		PlaceHolder() actuator_acc0;
		BlankSpace(line_num=1048)
		SingleLineComment(line_num=1048) // acceleration from unit force in qpos0    (nu x 1) 
		BlankSpace(line_num=1049)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1049)
		PlaceHolder() actuator_length0;
		BlankSpace(line_num=1049)
		SingleLineComment(line_num=1049) // actuator length in qpos0                 (nu x 1) 
		BlankSpace(line_num=1050)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1050)
		PlaceHolder() actuator_lengthrange;
		SingleLineComment(line_num=1050) // feasible actuator length range           (nu x 2) 
		BlankSpace(line_num=1051)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1051)
		PlaceHolder() actuator_user;
		BlankSpace(line_num=1051)
		SingleLineComment(line_num=1051) // user data                                (nu x nuser_actuator) 
		BlankSpace(line_num=1052)
		PlaceHolder() int*
		BlankSpace(line_num=1052)
		PlaceHolder() actuator_plugin;
		BlankSpace(line_num=1052)
		SingleLineComment(line_num=1052) // plugin instance id; -1: not a plugin     (nu x 1) 
		BlankSpace(line_num=1053)
		BlankSpace(line_num=1054)
		SingleLineComment(line_num=1054) // sensors 
		BlankSpace(line_num=1055)
		PlaceHolder() int*
		BlankSpace(line_num=1055)
		PlaceHolder() sensor_type;
		BlankSpace(line_num=1055)
		SingleLineComment(line_num=1055) // sensor type (mjtSensor)                  (nsensor x 1) 
		BlankSpace(line_num=1056)
		PlaceHolder() int*
		BlankSpace(line_num=1056)
		PlaceHolder() sensor_datatype;
		BlankSpace(line_num=1056)
		SingleLineComment(line_num=1056) // numeric data type (mjtDataType)          (nsensor x 1) 
		BlankSpace(line_num=1057)
		PlaceHolder() int*
		BlankSpace(line_num=1057)
		PlaceHolder() sensor_needstage;
		BlankSpace(line_num=1057)
		SingleLineComment(line_num=1057) // required compute stage (mjtStage)        (nsensor x 1) 
		BlankSpace(line_num=1058)
		PlaceHolder() int*
		BlankSpace(line_num=1058)
		PlaceHolder() sensor_objtype;
		BlankSpace(line_num=1058)
		SingleLineComment(line_num=1058) // type of sensorized object (mjtObj)       (nsensor x 1) 
		BlankSpace(line_num=1059)
		PlaceHolder() int*
		BlankSpace(line_num=1059)
		PlaceHolder() sensor_objid;
		BlankSpace(line_num=1059)
		SingleLineComment(line_num=1059) // id of sensorized object                  (nsensor x 1) 
		BlankSpace(line_num=1060)
		PlaceHolder() int*
		BlankSpace(line_num=1060)
		PlaceHolder() sensor_reftype;
		BlankSpace(line_num=1060)
		SingleLineComment(line_num=1060) // type of reference frame (mjtObj)         (nsensor x 1) 
		BlankSpace(line_num=1061)
		PlaceHolder() int*
		BlankSpace(line_num=1061)
		PlaceHolder() sensor_refid;
		BlankSpace(line_num=1061)
		SingleLineComment(line_num=1061) // id of reference frame; -1: global frame  (nsensor x 1) 
		BlankSpace(line_num=1062)
		PlaceHolder() int*
		BlankSpace(line_num=1062)
		PlaceHolder() sensor_dim;
		BlankSpace(line_num=1062)
		SingleLineComment(line_num=1062) // number of scalar outputs                 (nsensor x 1) 
		BlankSpace(line_num=1063)
		PlaceHolder() int*
		BlankSpace(line_num=1063)
		PlaceHolder() sensor_adr;
		BlankSpace(line_num=1063)
		SingleLineComment(line_num=1063) // address in sensor array                  (nsensor x 1) 
		BlankSpace(line_num=1064)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1064)
		PlaceHolder() sensor_cutoff;
		BlankSpace(line_num=1064)
		SingleLineComment(line_num=1064) // cutoff for real and positive; 0: ignore  (nsensor x 1) 
		BlankSpace(line_num=1065)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1065)
		PlaceHolder() sensor_noise;
		BlankSpace(line_num=1065)
		SingleLineComment(line_num=1065) // noise standard deviation                 (nsensor x 1) 
		BlankSpace(line_num=1066)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1066)
		PlaceHolder() sensor_user;
		BlankSpace(line_num=1066)
		SingleLineComment(line_num=1066) // user data                                (nsensor x nuser_sensor) 
		BlankSpace(line_num=1067)
		PlaceHolder() int*
		BlankSpace(line_num=1067)
		PlaceHolder() sensor_plugin;
		BlankSpace(line_num=1067)
		SingleLineComment(line_num=1067) // plugin instance id; -1: not a plugin     (nsensor x 1) 
		BlankSpace(line_num=1068)
		BlankSpace(line_num=1069)
		SingleLineComment(line_num=1069) // plugin instances 
		BlankSpace(line_num=1070)
		PlaceHolder() int*
		BlankSpace(line_num=1070)
		PlaceHolder() plugin;
		BlankSpace(line_num=1070)
		SingleLineComment(line_num=1070) // globally registered plugin slot number   (nplugin x 1) 
		BlankSpace(line_num=1071)
		PlaceHolder() int*
		BlankSpace(line_num=1071)
		PlaceHolder() plugin_stateadr;
		BlankSpace(line_num=1071)
		SingleLineComment(line_num=1071) // address in the plugin state array        (nplugin x 1) 
		BlankSpace(line_num=1072)
		PlaceHolder() int*
		BlankSpace(line_num=1072)
		PlaceHolder() plugin_statenum;
		BlankSpace(line_num=1072)
		SingleLineComment(line_num=1072) // number of states in the plugin instance  (nplugin x 1) 
		BlankSpace(line_num=1073)
		PlaceHolder() char*
		BlankSpace(line_num=1073)
		PlaceHolder() plugin_attr;
		BlankSpace(line_num=1073)
		SingleLineComment(line_num=1073) // config attributes of plugin instances    (npluginattr x 1) 
		BlankSpace(line_num=1074)
		PlaceHolder() int*
		BlankSpace(line_num=1074)
		PlaceHolder() plugin_attradr;
		BlankSpace(line_num=1074)
		SingleLineComment(line_num=1074) // address to each instance's config attrib (nplugin x 1) 
		BlankSpace(line_num=1075)
		BlankSpace(line_num=1076)
		SingleLineComment(line_num=1076) // custom numeric fields 
		BlankSpace(line_num=1077)
		PlaceHolder() int*
		BlankSpace(line_num=1077)
		PlaceHolder() numeric_adr;
		BlankSpace(line_num=1077)
		SingleLineComment(line_num=1077) // address of field in numeric_data         (nnumeric x 1) 
		BlankSpace(line_num=1078)
		PlaceHolder() int*
		BlankSpace(line_num=1078)
		PlaceHolder() numeric_size;
		BlankSpace(line_num=1078)
		SingleLineComment(line_num=1078) // size of numeric field                    (nnumeric x 1) 
		BlankSpace(line_num=1079)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1079)
		PlaceHolder() numeric_data;
		BlankSpace(line_num=1079)
		SingleLineComment(line_num=1079) // array of all numeric fields              (nnumericdata x 1) 
		BlankSpace(line_num=1080)
		BlankSpace(line_num=1081)
		SingleLineComment(line_num=1081) // custom text fields 
		BlankSpace(line_num=1082)
		PlaceHolder() int*
		BlankSpace(line_num=1082)
		PlaceHolder() text_adr;
		BlankSpace(line_num=1082)
		SingleLineComment(line_num=1082) // address of text in text_data             (ntext x 1) 
		BlankSpace(line_num=1083)
		PlaceHolder() int*
		BlankSpace(line_num=1083)
		PlaceHolder() text_size;
		BlankSpace(line_num=1083)
		SingleLineComment(line_num=1083) // size of text field (strlen+1)            (ntext x 1) 
		BlankSpace(line_num=1084)
		PlaceHolder() char*
		BlankSpace(line_num=1084)
		PlaceHolder() text_data;
		BlankSpace(line_num=1084)
		SingleLineComment(line_num=1084) // array of all text fields (0-terminated)  (ntextdata x 1) 
		BlankSpace(line_num=1085)
		BlankSpace(line_num=1086)
		SingleLineComment(line_num=1086) // custom tuple fields 
		BlankSpace(line_num=1087)
		PlaceHolder() int*
		BlankSpace(line_num=1087)
		PlaceHolder() tuple_adr;
		BlankSpace(line_num=1087)
		SingleLineComment(line_num=1087) // address of text in text_data             (ntuple x 1) 
		BlankSpace(line_num=1088)
		PlaceHolder() int*
		BlankSpace(line_num=1088)
		PlaceHolder() tuple_size;
		BlankSpace(line_num=1088)
		SingleLineComment(line_num=1088) // number of objects in tuple               (ntuple x 1) 
		BlankSpace(line_num=1089)
		PlaceHolder() int*
		BlankSpace(line_num=1089)
		PlaceHolder() tuple_objtype;
		BlankSpace(line_num=1089)
		SingleLineComment(line_num=1089) // array of object types in all tuples      (ntupledata x 1) 
		BlankSpace(line_num=1090)
		PlaceHolder() int*
		BlankSpace(line_num=1090)
		PlaceHolder() tuple_objid;
		BlankSpace(line_num=1090)
		SingleLineComment(line_num=1090) // array of object ids in all tuples        (ntupledata x 1) 
		BlankSpace(line_num=1091)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1091)
		PlaceHolder() tuple_objprm;
		BlankSpace(line_num=1091)
		SingleLineComment(line_num=1091) // array of object params in all tuples     (ntupledata x 1) 
		BlankSpace(line_num=1092)
		BlankSpace(line_num=1093)
		SingleLineComment(line_num=1093) // keyframes 
		BlankSpace(line_num=1094)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1094)
		PlaceHolder() key_time;
		BlankSpace(line_num=1094)
		SingleLineComment(line_num=1094) // key time                                 (nkey x 1) 
		BlankSpace(line_num=1095)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1095)
		PlaceHolder() key_qpos;
		BlankSpace(line_num=1095)
		SingleLineComment(line_num=1095) // key position                             (nkey x nq) 
		BlankSpace(line_num=1096)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1096)
		PlaceHolder() key_qvel;
		BlankSpace(line_num=1096)
		SingleLineComment(line_num=1096) // key velocity                             (nkey x nv) 
		BlankSpace(line_num=1097)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1097)
		PlaceHolder() key_act;
		BlankSpace(line_num=1097)
		SingleLineComment(line_num=1097) // key activation                           (nkey x na) 
		BlankSpace(line_num=1098)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1098)
		PlaceHolder() key_mpos;
		BlankSpace(line_num=1098)
		SingleLineComment(line_num=1098) // key mocap position                       (nkey x nmocap*3) 
		BlankSpace(line_num=1099)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1099)
		PlaceHolder() key_mquat;
		BlankSpace(line_num=1099)
		SingleLineComment(line_num=1099) // key mocap quaternion                     (nkey x nmocap*4) 
		BlankSpace(line_num=1100)
		PlaceHolder() mjtNum*
		BlankSpace(line_num=1100)
		PlaceHolder() key_ctrl;
		BlankSpace(line_num=1100)
		SingleLineComment(line_num=1100) // key control                              (nkey x nu) 
		BlankSpace(line_num=1101)
		BlankSpace(line_num=1102)
		SingleLineComment(line_num=1102) // names 
		BlankSpace(line_num=1103)
		PlaceHolder() int*
		BlankSpace(line_num=1103)
		PlaceHolder() name_bodyadr;
		BlankSpace(line_num=1103)
		SingleLineComment(line_num=1103) // body name pointers                       (nbody x 1) 
		BlankSpace(line_num=1104)
		PlaceHolder() int*
		BlankSpace(line_num=1104)
		PlaceHolder() name_jntadr;
		BlankSpace(line_num=1104)
		SingleLineComment(line_num=1104) // joint name pointers                      (njnt x 1) 
		BlankSpace(line_num=1105)
		PlaceHolder() int*
		BlankSpace(line_num=1105)
		PlaceHolder() name_geomadr;
		BlankSpace(line_num=1105)
		SingleLineComment(line_num=1105) // geom name pointers                       (ngeom x 1) 
		BlankSpace(line_num=1106)
		PlaceHolder() int*
		BlankSpace(line_num=1106)
		PlaceHolder() name_siteadr;
		BlankSpace(line_num=1106)
		SingleLineComment(line_num=1106) // site name pointers                       (nsite x 1) 
		BlankSpace(line_num=1107)
		PlaceHolder() int*
		BlankSpace(line_num=1107)
		PlaceHolder() name_camadr;
		BlankSpace(line_num=1107)
		SingleLineComment(line_num=1107) // camera name pointers                     (ncam x 1) 
		BlankSpace(line_num=1108)
		PlaceHolder() int*
		BlankSpace(line_num=1108)
		PlaceHolder() name_lightadr;
		BlankSpace(line_num=1108)
		SingleLineComment(line_num=1108) // light name pointers                      (nlight x 1) 
		BlankSpace(line_num=1109)
		PlaceHolder() int*
		BlankSpace(line_num=1109)
		PlaceHolder() name_flexadr;
		BlankSpace(line_num=1109)
		SingleLineComment(line_num=1109) // flex name pointers                       (nflex x 1) 
		BlankSpace(line_num=1110)
		PlaceHolder() int*
		BlankSpace(line_num=1110)
		PlaceHolder() name_meshadr;
		BlankSpace(line_num=1110)
		SingleLineComment(line_num=1110) // mesh name pointers                       (nmesh x 1) 
		BlankSpace(line_num=1111)
		PlaceHolder() int*
		BlankSpace(line_num=1111)
		PlaceHolder() name_skinadr;
		BlankSpace(line_num=1111)
		SingleLineComment(line_num=1111) // skin name pointers                       (nskin x 1) 
		BlankSpace(line_num=1112)
		PlaceHolder() int*
		BlankSpace(line_num=1112)
		PlaceHolder() name_hfieldadr;
		BlankSpace(line_num=1112)
		SingleLineComment(line_num=1112) // hfield name pointers                     (nhfield x 1) 
		BlankSpace(line_num=1113)
		PlaceHolder() int*
		BlankSpace(line_num=1113)
		PlaceHolder() name_texadr;
		BlankSpace(line_num=1113)
		SingleLineComment(line_num=1113) // texture name pointers                    (ntex x 1) 
		BlankSpace(line_num=1114)
		PlaceHolder() int*
		BlankSpace(line_num=1114)
		PlaceHolder() name_matadr;
		BlankSpace(line_num=1114)
		SingleLineComment(line_num=1114) // material name pointers                   (nmat x 1) 
		BlankSpace(line_num=1115)
		PlaceHolder() int*
		BlankSpace(line_num=1115)
		PlaceHolder() name_pairadr;
		BlankSpace(line_num=1115)
		SingleLineComment(line_num=1115) // geom pair name pointers                  (npair x 1) 
		BlankSpace(line_num=1116)
		PlaceHolder() int*
		BlankSpace(line_num=1116)
		PlaceHolder() name_excludeadr;
		BlankSpace(line_num=1116)
		SingleLineComment(line_num=1116) // exclude name pointers                    (nexclude x 1) 
		BlankSpace(line_num=1117)
		PlaceHolder() int*
		BlankSpace(line_num=1117)
		PlaceHolder() name_eqadr;
		BlankSpace(line_num=1117)
		SingleLineComment(line_num=1117) // equality constraint name pointers        (neq x 1) 
		BlankSpace(line_num=1118)
		PlaceHolder() int*
		BlankSpace(line_num=1118)
		PlaceHolder() name_tendonadr;
		BlankSpace(line_num=1118)
		SingleLineComment(line_num=1118) // tendon name pointers                     (ntendon x 1) 
		BlankSpace(line_num=1119)
		PlaceHolder() int*
		BlankSpace(line_num=1119)
		PlaceHolder() name_actuatoradr;
		BlankSpace(line_num=1119)
		SingleLineComment(line_num=1119) // actuator name pointers                   (nu x 1) 
		BlankSpace(line_num=1120)
		PlaceHolder() int*
		BlankSpace(line_num=1120)
		PlaceHolder() name_sensoradr;
		BlankSpace(line_num=1120)
		SingleLineComment(line_num=1120) // sensor name pointers                     (nsensor x 1) 
		BlankSpace(line_num=1121)
		PlaceHolder() int*
		BlankSpace(line_num=1121)
		PlaceHolder() name_numericadr;
		BlankSpace(line_num=1121)
		SingleLineComment(line_num=1121) // numeric name pointers                    (nnumeric x 1) 
		BlankSpace(line_num=1122)
		PlaceHolder() int*
		BlankSpace(line_num=1122)
		PlaceHolder() name_textadr;
		BlankSpace(line_num=1122)
		SingleLineComment(line_num=1122) // text name pointers                       (ntext x 1) 
		BlankSpace(line_num=1123)
		PlaceHolder() int*
		BlankSpace(line_num=1123)
		PlaceHolder() name_tupleadr;
		BlankSpace(line_num=1123)
		SingleLineComment(line_num=1123) // tuple name pointers                      (ntuple x 1) 
		BlankSpace(line_num=1124)
		PlaceHolder() int*
		BlankSpace(line_num=1124)
		PlaceHolder() name_keyadr;
		BlankSpace(line_num=1124)
		SingleLineComment(line_num=1124) // keyframe name pointers                   (nkey x 1) 
		BlankSpace(line_num=1125)
		PlaceHolder() int*
		BlankSpace(line_num=1125)
		PlaceHolder() name_pluginadr;
		BlankSpace(line_num=1125)
		SingleLineComment(line_num=1125) // plugin instance name pointers            (nplugin x 1) 
		BlankSpace(line_num=1126)
		PlaceHolder() char*
		BlankSpace(line_num=1126)
		PlaceHolder() names;
		BlankSpace(line_num=1126)
		SingleLineComment(line_num=1126) // names of all objects, 0-terminated       (nnames x 1) 
		BlankSpace(line_num=1127)
		PlaceHolder() int*
		BlankSpace(line_num=1127)
		PlaceHolder() names_map;
		BlankSpace(line_num=1127)
		SingleLineComment(line_num=1127) // internal hash map of names               (nnames_map x 1) 
		BlankSpace(line_num=1128)
		BlankSpace(line_num=1129)
		SingleLineComment(line_num=1129) // paths 
		BlankSpace(line_num=1130)
		PlaceHolder() char*
		BlankSpace(line_num=1130)
		PlaceHolder() paths;
		BlankSpace(line_num=1130)
		SingleLineComment(line_num=1130) // paths to assets, 0-terminated            (npaths x 1) 
		PlaceHolder() };
		TypeDef(line_num=1132) typedef struct mjModel_ mjModel; 
		BlankSpace(line_num=1133)
	EndIf(line_num=1134) #endif
	BlankSpace(line_num=1134)
	SingleLineComment(line_num=1134) // MUJOCO_MJMODEL_H_ 
	BlankSpace(line_num=1135)