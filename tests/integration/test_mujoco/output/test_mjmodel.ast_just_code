// Copyright 2021 DeepMind Technologies Limited<C_BINDER_MOJO_NEWLINE>//<C_BINDER_MOJO_NEWLINE>// Licensed under the Apache License ,  Version 2.0  ( the "License" )  ; <C_BINDER_MOJO_NEWLINE>// you may not use this file except in compliance with the License.<C_BINDER_MOJO_NEWLINE>// You may obtain a copy of the License at<C_BINDER_MOJO_NEWLINE>//<C_BINDER_MOJO_NEWLINE>//     http://www.apache.org/licenses/LICENSE-2.0<C_BINDER_MOJO_NEWLINE>//<C_BINDER_MOJO_NEWLINE>// Unless required by applicable law or agreed to in writing ,  software<C_BINDER_MOJO_NEWLINE>// distributed under the License is distributed on an "AS IS" BASIS , <C_BINDER_MOJO_NEWLINE>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND ,  either express or implied.<C_BINDER_MOJO_NEWLINE>// See the License for the specific language governing permissions and<C_BINDER_MOJO_NEWLINE>// limitations under the License.<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>#ifndef MUJOCO_MJMODEL_H_<C_BINDER_MOJO_NEWLINE>#define MUJOCO_MJMODEL_H_<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>#include <stddef.h><C_BINDER_MOJO_NEWLINE>#include <stdint.h><C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>#include <mujoco/mjtnum.h><C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>// global constants<C_BINDER_MOJO_NEWLINE>#define mjPI3.14159265358979323846 <C_BINDER_MOJO_NEWLINE>#define mjMAXVAL1E+10     // maximum value in qpos ,  qvel ,  qacc <C_BINDER_MOJO_NEWLINE>#define mjMINMU1E-5      // minimum friction coefficient <C_BINDER_MOJO_NEWLINE>#define mjMINIMP0.0001    // minimum constraint impedance <C_BINDER_MOJO_NEWLINE>#define mjMAXIMP0.9999    // maximum constraint impedance <C_BINDER_MOJO_NEWLINE>#define mjMAXCONPAIR50        // maximum number of contacts per geom pair <C_BINDER_MOJO_NEWLINE>#define mjMAXTREEDEPTH50        // maximum bounding volume hierarchy depth <C_BINDER_MOJO_NEWLINE><C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>//---------------------------------- sizes ---------------------------------------------------------<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>#define mjNEQDATA11        // number of eq_data fields <C_BINDER_MOJO_NEWLINE>#define mjNDYN10        // number of actuator dynamics parameters <C_BINDER_MOJO_NEWLINE>#define mjNGAIN10        // number of actuator gain parameters <C_BINDER_MOJO_NEWLINE>#define mjNBIAS10        // number of actuator bias parameters <C_BINDER_MOJO_NEWLINE>#define mjNFLUID12        // number of fluid interaction parameters <C_BINDER_MOJO_NEWLINE>#define mjNREF2         // number of solver reference parameters <C_BINDER_MOJO_NEWLINE>#define mjNIMP5         // number of solver impedance parameters <C_BINDER_MOJO_NEWLINE>#define mjNSOLVER200       // size of one mjData.solver array <C_BINDER_MOJO_NEWLINE>#define mjNISLAND20        // number of mjData.solver arrays <C_BINDER_MOJO_NEWLINE><C_BINDER_MOJO_NEWLINE>//---------------------------------- enum types  ( mjt )  ----------------------------------------------<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtDisableBit_{ <C_BINDER_MOJO_NEWLINE>// disable default feature bitflagsmjDSBL_CONSTRAINT    =  1<<0 ,// entire constraint solvermjDSBL_EQUALITY      =  1<<1 ,// equality constraintsmjDSBL_FRICTIONLOSS  =  1<<2 ,// joint and tendon frictionloss constraintsmjDSBL_LIMIT         =  1<<3 ,// joint and tendon limit constraintsmjDSBL_CONTACT       =  1<<4 ,// contact constraintsmjDSBL_PASSIVE       =  1<<5 ,// passive forcesmjDSBL_GRAVITY       =  1<<6 ,// gravitational forcesmjDSBL_CLAMPCTRL     =  1<<7 ,// clamp control to specified rangemjDSBL_WARMSTART     =  1<<8 ,// warmstart constraint solvermjDSBL_FILTERPARENT  =  1<<9 ,// remove collisions with parent bodymjDSBL_ACTUATION     =  1<<10 ,// apply actuation forcesmjDSBL_REFSAFE       =  1<<11 ,// integrator safety: make ref[0]> = 2*timestepmjDSBL_SENSOR        =  1<<12 ,// sensorsmjDSBL_MIDPHASE      =  1<<13 ,// mid-phase collision filteringmjDSBL_EULERDAMP     =  1<<14 ,// implicit integration of joint damping in Euler integratormjDSBL_AUTORESET     =  1<<15 ,// automatic reset when numerical issues are detectedmjNDISABLE           =  16       // number of disable flags<C_BINDER_MOJO_NEWLINE>}mjtDisableBit<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtEnableBit_{ <C_BINDER_MOJO_NEWLINE>// enable optional feature bitflagsmjENBL_OVERRIDE      =  1<<0 ,// override contact parametersmjENBL_ENERGY        =  1<<1 ,// energy computationmjENBL_FWDINV        =  1<<2 ,// record solver statisticsmjENBL_INVDISCRETE   =  1<<3 ,// discrete-time inverse dynamics// experimental features:mjENBL_MULTICCD      =  1<<4 ,// multi-point convex collision detectionmjENBL_ISLAND        =  1<<5 ,// constraint island discoverymjENBL_NATIVECCD     =  1<<6 ,// native convex collision detectionmjNENABLE            =  7        // number of enable flags<C_BINDER_MOJO_NEWLINE>}mjtEnableBit<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtJoint_{ <C_BINDER_MOJO_NEWLINE>// type of degree of freedommjJNT_FREE           =  0 ,// global position and orientation  ( quat )         ( 7 ) mjJNT_BALL ,// orientation  ( quat )  relative to parent         ( 4 ) mjJNT_SLIDE ,// sliding distance along body-fixed axis        ( 1 ) mjJNT_HINGE                    // rotation angle  ( rad )  around body-fixed axis   ( 1 ) <C_BINDER_MOJO_NEWLINE>}mjtJoint<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtGeom_{ <C_BINDER_MOJO_NEWLINE>// type of geometric shape// regular geom typesmjGEOM_PLANE         =  0 ,// planemjGEOM_HFIELD ,// height fieldmjGEOM_SPHERE ,// spheremjGEOM_CAPSULE ,// capsulemjGEOM_ELLIPSOID ,// ellipsoidmjGEOM_CYLINDER ,// cylindermjGEOM_BOX ,// boxmjGEOM_MESH ,// meshmjGEOM_SDF ,// signed distance fieldmjNGEOMTYPES ,// number of regular geom types// rendering-only geom types: not used in mjModel ,  not counted in mjNGEOMTYPESmjGEOM_ARROW         =  100 ,// arrowmjGEOM_ARROW1 ,// arrow without wedgesmjGEOM_ARROW2 ,// arrow in both directionsmjGEOM_LINE ,// linemjGEOM_LINEBOX ,// box with line edgesmjGEOM_FLEX ,// flexmjGEOM_SKIN ,// skinmjGEOM_LABEL ,// text labelmjGEOM_TRIANGLE ,// trianglemjGEOM_NONE          =  1001     // missing geom type<C_BINDER_MOJO_NEWLINE>}mjtGeom<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtCamLight_{ <C_BINDER_MOJO_NEWLINE>// tracking mode for camera and lightmjCAMLIGHT_FIXED     =  0 ,// pos and rot fixed in bodymjCAMLIGHT_TRACK ,// pos tracks body ,  rot fixed in globalmjCAMLIGHT_TRACKCOM ,// pos tracks subtree com ,  rot fixed in bodymjCAMLIGHT_TARGETBODY ,// pos fixed in body ,  rot tracks target bodymjCAMLIGHT_TARGETBODYCOM       // pos fixed in body ,  rot tracks target subtree com<C_BINDER_MOJO_NEWLINE>}mjtCamLight<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtTexture_{ <C_BINDER_MOJO_NEWLINE>// type of texturemjTEXTURE_2D         =  0 ,// 2d texture ,  suitable for planes and hfieldsmjTEXTURE_CUBE ,// cube texture ,  suitable for all other geom typesmjTEXTURE_SKYBOX               // cube texture used as skybox<C_BINDER_MOJO_NEWLINE>}mjtTexture<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtTextureRole_{ <C_BINDER_MOJO_NEWLINE>// role of texture map in renderingmjTEXROLE_USER       =  0 ,// unspecifiedmjTEXROLE_RGB ,// base color  ( albedo ) mjTEXROLE_OCCLUSION ,// ambient occlusionmjTEXROLE_ROUGHNESS ,// roughnessmjTEXROLE_METALLIC ,// metallicmjTEXROLE_NORMAL ,// normal  ( bump )  mapmjTEXROLE_OPACITY ,// transperancymjTEXROLE_EMISSIVE ,// light emissionmjTEXROLE_RGBA ,// base color ,  opacitymjTEXROLE_ORM ,// occlusion ,  roughness ,  metallicmjNTEXROLE <C_BINDER_MOJO_NEWLINE><C_BINDER_MOJO_NEWLINE>}mjtTextureRole<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtIntegrator_{ <C_BINDER_MOJO_NEWLINE>// integrator modemjINT_EULER          =  0 ,// semi-implicit EulermjINT_RK4 ,// 4th-order Runge KuttamjINT_IMPLICIT ,// implicit in velocitymjINT_IMPLICITFAST             // implicit in velocity ,  no rne derivative<C_BINDER_MOJO_NEWLINE>}mjtIntegrator<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtCone_{ <C_BINDER_MOJO_NEWLINE>// type of friction conemjCONE_PYRAMIDAL      =  0 ,// pyramidalmjCONE_ELLIPTIC                // elliptic<C_BINDER_MOJO_NEWLINE>}mjtCone<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtJacobian_{ <C_BINDER_MOJO_NEWLINE>// type of constraint JacobianmjJAC_DENSE           =  0 ,// densemjJAC_SPARSE ,// sparsemjJAC_AUTO                     // dense if nv<60 ,  sparse otherwise<C_BINDER_MOJO_NEWLINE>}mjtJacobian<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtSolver_{ <C_BINDER_MOJO_NEWLINE>// constraint solver algorithmmjSOL_PGS             =  0 ,// PGS     ( dual ) mjSOL_CG ,// CG      ( primal ) mjSOL_NEWTON                   // Newton  ( primal ) <C_BINDER_MOJO_NEWLINE>}mjtSolver<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtEq_{ <C_BINDER_MOJO_NEWLINE>// type of equality constraintmjEQ_CONNECT         =  0 ,// connect two bodies at a point  ( ball joint ) mjEQ_WELD ,// fix relative position and orientation of two bodiesmjEQ_JOINT ,// couple the values of two scalar joints with cubicmjEQ_TENDON ,// couple the lengths of two tendons with cubicmjEQ_FLEX ,// fix all edge lengths of a flexmjEQ_DISTANCE                  // unsupported ,  will cause an error if used<C_BINDER_MOJO_NEWLINE>}mjtEq<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtWrap_{ <C_BINDER_MOJO_NEWLINE>// type of tendon wrap objectmjWRAP_NONE          =  0 ,// null objectmjWRAP_JOINT ,// constant moment armmjWRAP_PULLEY ,// pulley used to split tendonmjWRAP_SITE ,// pass through sitemjWRAP_SPHERE ,// wrap around spheremjWRAP_CYLINDER                // wrap around  ( infinite )  cylinder<C_BINDER_MOJO_NEWLINE>}mjtWrap<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtTrn_{ <C_BINDER_MOJO_NEWLINE>// type of actuator transmissionmjTRN_JOINT          =  0 ,// force on jointmjTRN_JOINTINPARENT ,// force on joint ,  expressed in parent framemjTRN_SLIDERCRANK ,// force via slider-crank linkagemjTRN_TENDON ,// force on tendonmjTRN_SITE ,// force on sitemjTRN_BODY ,// adhesion force on a body's geomsmjTRN_UNDEFINED      =  1000     // undefined transmission type<C_BINDER_MOJO_NEWLINE>}mjtTrn<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtDyn_{ <C_BINDER_MOJO_NEWLINE>// type of actuator dynamicsmjDYN_NONE           =  0 ,// no internal dynamics ;  ctrl specifies forcemjDYN_INTEGRATOR ,// integrator: da/dt  =  umjDYN_FILTER ,// linear filter: da/dt  =   ( u-a )  / taumjDYN_FILTEREXACT ,// linear filter: da/dt  =   ( u-a )  / tau ,  with exact integrationmjDYN_MUSCLE ,// piece-wise linear filter with two time constantsmjDYN_USER                     // user-defined dynamics type<C_BINDER_MOJO_NEWLINE>}mjtDyn<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtGain_{ <C_BINDER_MOJO_NEWLINE>// type of actuator gainmjGAIN_FIXED         =  0 ,// fixed gainmjGAIN_AFFINE ,// const + kp*length + kv*velocitymjGAIN_MUSCLE ,// muscle FLV curve computed by mju_muscleGain (  ) mjGAIN_USER                    // user-defined gain type<C_BINDER_MOJO_NEWLINE>}mjtGain<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtBias_{ <C_BINDER_MOJO_NEWLINE>// type of actuator biasmjBIAS_NONE          =  0 ,// no biasmjBIAS_AFFINE ,// const + kp*length + kv*velocitymjBIAS_MUSCLE ,// muscle passive force computed by mju_muscleBias (  ) mjBIAS_USER                    // user-defined bias type<C_BINDER_MOJO_NEWLINE>}mjtBias<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtObj_{ <C_BINDER_MOJO_NEWLINE>// type of MujoCo objectmjOBJ_UNKNOWN        =  0 ,// unknown object typemjOBJ_BODY ,// bodymjOBJ_XBODY ,// body ,  used to access regular frame instead of i-framemjOBJ_JOINT ,// jointmjOBJ_DOF ,// dofmjOBJ_GEOM ,// geommjOBJ_SITE ,// sitemjOBJ_CAMERA ,// cameramjOBJ_LIGHT ,// lightmjOBJ_FLEX ,// flexmjOBJ_MESH ,// meshmjOBJ_SKIN ,// skinmjOBJ_HFIELD ,// heightfieldmjOBJ_TEXTURE ,// texturemjOBJ_MATERIAL ,// material for renderingmjOBJ_PAIR ,// geom pair to includemjOBJ_EXCLUDE ,// body pair to excludemjOBJ_EQUALITY ,// equality constraintmjOBJ_TENDON ,// tendonmjOBJ_ACTUATOR ,// actuatormjOBJ_SENSOR ,// sensormjOBJ_NUMERIC ,// numericmjOBJ_TEXT ,// textmjOBJ_TUPLE ,// tuplemjOBJ_KEY ,// keyframemjOBJ_PLUGIN ,// plugin instancemjNOBJECT ,// number of object types// meta elements ,  do not appear in mjModelmjOBJ_FRAME          =  100      // frame<C_BINDER_MOJO_NEWLINE>}mjtObj<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtConstraint_{ <C_BINDER_MOJO_NEWLINE>// type of constraintmjCNSTR_EQUALITY     =  0 ,// equality constraintmjCNSTR_FRICTION_DOF ,// dof frictionmjCNSTR_FRICTION_TENDON ,// tendon frictionmjCNSTR_LIMIT_JOINT ,// joint limitmjCNSTR_LIMIT_TENDON ,// tendon limitmjCNSTR_CONTACT_FRICTIONLESS ,// frictionless contactmjCNSTR_CONTACT_PYRAMIDAL ,// frictional contact ,  pyramidal friction conemjCNSTR_CONTACT_ELLIPTIC       // frictional contact ,  elliptic friction cone<C_BINDER_MOJO_NEWLINE>}mjtConstraint<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtConstraintState_{ <C_BINDER_MOJO_NEWLINE>// constraint statemjCNSTRSTATE_SATISFIED  =  0 ,// constraint satisfied ,  zero cost  ( limit ,  contact ) mjCNSTRSTATE_QUADRATIC ,// quadratic cost  ( equality ,  friction ,  limit ,  contact ) mjCNSTRSTATE_LINEARNEG ,// linear cost ,  negative side  ( friction ) mjCNSTRSTATE_LINEARPOS ,// linear cost ,  positive side  ( friction ) mjCNSTRSTATE_CONE                // squared distance to cone cost  ( elliptic contact ) <C_BINDER_MOJO_NEWLINE>}mjtConstraintState<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtSensor_{ <C_BINDER_MOJO_NEWLINE>// type of sensor// common robotic sensors ,  attached to a sitemjSENS_TOUCH         =  0 ,// scalar contact normal forces summed over sensor zonemjSENS_ACCELEROMETER ,// 3D linear acceleration ,  in local framemjSENS_VELOCIMETER ,// 3D linear velocity ,  in local framemjSENS_GYRO ,// 3D angular velocity ,  in local framemjSENS_FORCE ,// 3D force between site's body and its parent bodymjSENS_TORQUE ,// 3D torque between site's body and its parent bodymjSENS_MAGNETOMETER ,// 3D magnetometermjSENS_RANGEFINDER ,// scalar distance to nearest geom or site along z-axismjSENS_CAMPROJECTION ,// pixel coordinates of a site in the camera image// sensors related to scalar joints ,  tendons ,  actuatorsmjSENS_JOINTPOS ,// scalar joint position  ( hinge and slide only ) mjSENS_JOINTVEL ,// scalar joint velocity  ( hinge and slide only ) mjSENS_TENDONPOS ,// scalar tendon positionmjSENS_TENDONVEL ,// scalar tendon velocitymjSENS_ACTUATORPOS ,// scalar actuator positionmjSENS_ACTUATORVEL ,// scalar actuator velocitymjSENS_ACTUATORFRC ,// scalar actuator forcemjSENS_JOINTACTFRC ,// scalar actuator force ,  measured at the joint// sensors related to ball jointsmjSENS_BALLQUAT ,// 4D ball joint quaternionmjSENS_BALLANGVEL ,// 3D ball joint angular velocity// joint and tendon limit sensors ,  in constraint spacemjSENS_JOINTLIMITPOS ,// joint limit distance-marginmjSENS_JOINTLIMITVEL ,// joint limit velocitymjSENS_JOINTLIMITFRC ,// joint limit forcemjSENS_TENDONLIMITPOS ,// tendon limit distance-marginmjSENS_TENDONLIMITVEL ,// tendon limit velocitymjSENS_TENDONLIMITFRC ,// tendon limit force// sensors attached to an object with spatial frame:  ( x ) body ,  geom ,  site ,  cameramjSENS_FRAMEPOS ,// 3D positionmjSENS_FRAMEQUAT ,// 4D unit quaternion orientationmjSENS_FRAMEXAXIS ,// 3D unit vector: x-axis of object's framemjSENS_FRAMEYAXIS ,// 3D unit vector: y-axis of object's framemjSENS_FRAMEZAXIS ,// 3D unit vector: z-axis of object's framemjSENS_FRAMELINVEL ,// 3D linear velocitymjSENS_FRAMEANGVEL ,// 3D angular velocitymjSENS_FRAMELINACC ,// 3D linear accelerationmjSENS_FRAMEANGACC ,// 3D angular acceleration// sensors related to kinematic subtrees ;  attached to a body  ( which is the subtree root ) mjSENS_SUBTREECOM ,// 3D center of mass of subtreemjSENS_SUBTREELINVEL ,// 3D linear velocity of subtreemjSENS_SUBTREEANGMOM ,// 3D angular momentum of subtree// sensors for geometric distance ;  attached to geoms or bodiesmjSENS_GEOMDIST ,// signed distance between two geomsmjSENS_GEOMNORMAL ,// normal direction between two geomsmjSENS_GEOMFROMTO ,// segment between two geoms// global sensorsmjSENS_CLOCK ,// simulation time// plugin-controlled sensorsmjSENS_PLUGIN ,// plugin-controlled// user-defined sensormjSENS_USER                    // sensor data provided by mjcb_sensor callback<C_BINDER_MOJO_NEWLINE>}mjtSensor<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtStage_{ <C_BINDER_MOJO_NEWLINE>// computation stagemjSTAGE_NONE         =  0 ,// no computationsmjSTAGE_POS ,// position-dependent computationsmjSTAGE_VEL ,// velocity-dependent computationsmjSTAGE_ACC                    // acceleration/force-dependent computations<C_BINDER_MOJO_NEWLINE>}mjtStage<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtDataType_{ <C_BINDER_MOJO_NEWLINE>// data type for sensorsmjDATATYPE_REAL      =  0 ,// real values ,  no constraintsmjDATATYPE_POSITIVE ,// positive values ;  0 or negative: inactivemjDATATYPE_AXIS ,// 3D unit vectormjDATATYPE_QUATERNION          // unit quaternion<C_BINDER_MOJO_NEWLINE>}mjtDataType<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtSameFrame_{ <C_BINDER_MOJO_NEWLINE>// frame alignment of bodies with their childrenmjSAMEFRAME_NONE     =  0 ,// no alignmentmjSAMEFRAME_BODY ,// frame is same as body framemjSAMEFRAME_INERTIA ,// frame is same as inertial framemjSAMEFRAME_BODYROT ,// frame orientation is same as body orientationmjSAMEFRAME_INERTIAROT         // frame orientation is same as inertia orientation<C_BINDER_MOJO_NEWLINE>}mjtSameFrame<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtLRMode_{ <C_BINDER_MOJO_NEWLINE>// mode for actuator length range computationmjLRMODE_NONE    =  0 ,// do not process any actuatorsmjLRMODE_MUSCLE ,// process muscle actuatorsmjLRMODE_MUSCLEUSER ,// process muscle and user actuatorsmjLRMODE_ALL                   // process all actuators<C_BINDER_MOJO_NEWLINE>}mjtLRMode<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>typedefenum mjtFlexSelf_{ <C_BINDER_MOJO_NEWLINE>// mode for flex selfcollidemjFLEXSELF_NONE    =  0 ,// no self-collisionsmjFLEXSELF_NARROW ,// skip midphase ,  go directly to narrowphasemjFLEXSELF_BVH ,// use BVH in midphase  ( if midphase enabled ) mjFLEXSELF_SAP ,// use SAP in midphasemjFLEXSELF_AUTO                // choose between BVH and SAP automatically<C_BINDER_MOJO_NEWLINE>}mjtFlexSelf<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>//---------------------------------- mjLROpt -------------------------------------------------------<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>struct mjLROpt_{ <C_BINDER_MOJO_NEWLINE>// options for mj_setLengthRange (  ) // flagsint mode ;<C_BINDER_MOJO_NEWLINE>// which actuators to process  ( mjtLRMode ) int useexisting ;<C_BINDER_MOJO_NEWLINE>// use existing length range if availableint uselimit ;<C_BINDER_MOJO_NEWLINE>// use joint and tendon limits if available// algorithm parametersmjtNum accel ;<C_BINDER_MOJO_NEWLINE>// target acceleration used to compute forcemjtNum maxforce ;<C_BINDER_MOJO_NEWLINE>// maximum force ;  0: no limitmjtNum timeconst ;<C_BINDER_MOJO_NEWLINE>// time constant for velocity reduction ;  min 0.01mjtNum timestep ;<C_BINDER_MOJO_NEWLINE>// simulation timestep ;  0: use mjOption.timestepmjtNum inttotal ;<C_BINDER_MOJO_NEWLINE>// total simulation time intervalmjtNum interval ;<C_BINDER_MOJO_NEWLINE>// evaluation time interval  ( at the end ) mjtNum tolrange ;<C_BINDER_MOJO_NEWLINE>// convergence tolerance  ( relative to range ) <C_BINDER_MOJO_NEWLINE>}; <C_BINDER_MOJO_NEWLINE>typedefstruct mjLROpt_mjLROpt<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>//---------------------------------- mjVFS ---------------------------------------------------------<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>struct mjVFS_{ <C_BINDER_MOJO_NEWLINE>// virtual file system for loading from memoryvoid* impl_ ;<C_BINDER_MOJO_NEWLINE>// internal pointer to VFS memory<C_BINDER_MOJO_NEWLINE>}; <C_BINDER_MOJO_NEWLINE>typedefstruct mjVFS_mjVFS<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>//---------------------------------- mjOption ------------------------------------------------------<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>struct mjOption_{ <C_BINDER_MOJO_NEWLINE>// physics options// timing parametersmjtNum timestep ;<C_BINDER_MOJO_NEWLINE>// timestepmjtNum apirate ;<C_BINDER_MOJO_NEWLINE>// update rate for remote API  ( Hz ) // solver parametersmjtNum impratio ;<C_BINDER_MOJO_NEWLINE>// ratio of friction-to-normal contact impedancemjtNum tolerance ;<C_BINDER_MOJO_NEWLINE>// main solver tolerancemjtNum ls_tolerance ;<C_BINDER_MOJO_NEWLINE>// CG/Newton linesearch tolerancemjtNum noslip_tolerance ;<C_BINDER_MOJO_NEWLINE>// noslip solver tolerancemjtNum ccd_tolerance ;<C_BINDER_MOJO_NEWLINE>// convex collision solver tolerance// physical constantsmjtNum gravity[3] ;<C_BINDER_MOJO_NEWLINE>// gravitational accelerationmjtNum wind[3] ;<C_BINDER_MOJO_NEWLINE>// wind  ( for lift ,  drag and viscosity ) mjtNum magnetic[3] ;<C_BINDER_MOJO_NEWLINE>// global magnetic fluxmjtNum density ;<C_BINDER_MOJO_NEWLINE>// density of mediummjtNum viscosity ;<C_BINDER_MOJO_NEWLINE>// viscosity of medium// override contact solver parameters  ( if enabled ) mjtNum o_margin ;<C_BINDER_MOJO_NEWLINE>// marginmjtNum o_solref[mjNREF] ;<C_BINDER_MOJO_NEWLINE>// solrefmjtNum o_solimp[mjNIMP] ;<C_BINDER_MOJO_NEWLINE>// solimpmjtNum o_friction[5] ;<C_BINDER_MOJO_NEWLINE>// friction// discrete settingsint integrator ;<C_BINDER_MOJO_NEWLINE>// integration mode  ( mjtIntegrator ) int cone ;<C_BINDER_MOJO_NEWLINE>// type of friction cone  ( mjtCone ) int jacobian ;<C_BINDER_MOJO_NEWLINE>// type of Jacobian  ( mjtJacobian ) int solver ;<C_BINDER_MOJO_NEWLINE>// solver algorithm  ( mjtSolver ) int iterations ;<C_BINDER_MOJO_NEWLINE>// maximum number of main solver iterationsint ls_iterations ;<C_BINDER_MOJO_NEWLINE>// maximum number of CG/Newton linesearch iterationsint noslip_iterations ;<C_BINDER_MOJO_NEWLINE>// maximum number of noslip solver iterationsint ccd_iterations ;<C_BINDER_MOJO_NEWLINE>// maximum number of convex collision solver iterationsint disableflags ;<C_BINDER_MOJO_NEWLINE>// bit flags for disabling standard featuresint enableflags ;<C_BINDER_MOJO_NEWLINE>// bit flags for enabling optional featuresint disableactuator ;<C_BINDER_MOJO_NEWLINE>// bit flags for disabling actuators by group id// sdf collision settingsint sdf_initpoints ;<C_BINDER_MOJO_NEWLINE>// number of starting points for gradient descentint sdf_iterations ;<C_BINDER_MOJO_NEWLINE>// max number of iterations for gradient descent<C_BINDER_MOJO_NEWLINE>}; <C_BINDER_MOJO_NEWLINE>typedefstruct mjOption_mjOption<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>//---------------------------------- mjVisual ------------------------------------------------------<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>struct mjVisual_{ <C_BINDER_MOJO_NEWLINE>// visualization options{ <C_BINDER_MOJO_NEWLINE>// global parametersint orthographic ;// is the free camera orthographic  ( 0: no ,  1: yes ) float fovy ;// y field-of-view of free camera  ( orthographic ? length : degree ) float ipd ;// inter-pupilary distance for free camerafloat azimuth ;// initial azimuth of free camera  ( degrees ) float elevation ;// initial elevation of free camera  ( degrees ) float linewidth ;// line width for wireframe and ray renderingfloat glow ;// glow coefficient for selected bodyfloat realtime ;// initial real-time factor  ( 1: real time ) int   offwidth ;// width of offscreen bufferint   offheight ;// height of offscreen bufferint   ellipsoidinertia ;// geom for inertia visualization  ( 0: box ,  1: ellipsoid ) int   bvactive ;// visualize active bounding volumes  ( 0: no ,  1: yes ) <C_BINDER_MOJO_NEWLINE>}global ; <C_BINDER_MOJO_NEWLINE>{ <C_BINDER_MOJO_NEWLINE>// rendering qualityint   shadowsize ;// size of shadowmap textureint   offsamples ;// number of multisamples for offscreen renderingint   numslices ;// number of slices for builtin geom drawingint   numstacks ;// number of stacks for builtin geom drawingint   numquads ;// number of quads for box rendering<C_BINDER_MOJO_NEWLINE>}quality ; <C_BINDER_MOJO_NEWLINE>{ <C_BINDER_MOJO_NEWLINE>// head lightfloat ambient[3] ;// ambient rgb  ( alpha = 1 ) float diffuse[3] ;// diffuse rgb  ( alpha = 1 ) float specular[3] ;// specular rgb  ( alpha = 1 ) int   active ;// is headlight active<C_BINDER_MOJO_NEWLINE>}headlight ; <C_BINDER_MOJO_NEWLINE>{ <C_BINDER_MOJO_NEWLINE>// mappingfloat stiffness ;// mouse perturbation stiffness  ( space->force ) float stiffnessrot ;// mouse perturbation stiffness  ( space->torque ) float force ;// from force units to space unitsfloat torque ;// from torque units to space unitsfloat alpha ;// scale geom alphas when transparency is enabledfloat fogstart ;// OpenGL fog starts at fogstart * mjModel.stat.extentfloat fogend ;// OpenGL fog ends at fogend * mjModel.stat.extentfloat znear ;// near clipping plane  =  znear * mjModel.stat.extentfloat zfar ;// far clipping plane  =  zfar * mjModel.stat.extentfloat haze ;// haze ratiofloat shadowclip ;// directional light: shadowclip * mjModel.stat.extentfloat shadowscale ;// spot light: shadowscale * light.cutofffloat actuatortendon ;// scale tendon width<C_BINDER_MOJO_NEWLINE>}map ; <C_BINDER_MOJO_NEWLINE>{ <C_BINDER_MOJO_NEWLINE>// scale of decor elements relative to mean body sizefloat forcewidth ;// width of force arrowfloat contactwidth ;// contact widthfloat contactheight ;// contact heightfloat connect ;// autoconnect capsule widthfloat com ;// com radiusfloat camera ;// camera objectfloat light ;// light objectfloat selectpoint ;// selection pointfloat jointlength ;// joint lengthfloat jointwidth ;// joint widthfloat actuatorlength ;// actuator lengthfloat actuatorwidth ;// actuator widthfloat framelength ;// bodyframe axis lengthfloat framewidth ;// bodyframe axis widthfloat constraint ;// constraint widthfloat slidercrank ;// slidercrank widthfloat frustum ;// frustum zfar plane<C_BINDER_MOJO_NEWLINE>}scale ; <C_BINDER_MOJO_NEWLINE>{ <C_BINDER_MOJO_NEWLINE>// color of decor elementsfloat fog[4] ;// fogfloat haze[4] ;// hazefloat force[4] ;// external forcefloat inertia[4] ;// inertia boxfloat joint[4] ;// jointfloat actuator[4] ;// actuator ,  neutralfloat actuatornegative[4] ;// actuator ,  negative limitfloat actuatorpositive[4] ;// actuator ,  positive limitfloat com[4] ;// center of massfloat camera[4] ;// camera objectfloat light[4] ;// light objectfloat selectpoint[4] ;// selection pointfloat connect[4] ;// auto connectfloat contactpoint[4] ;// contact pointfloat contactforce[4] ;// contact forcefloat contactfriction[4] ;// contact friction forcefloat contacttorque[4] ;// contact torquefloat contactgap[4] ;// contact point in gapfloat rangefinder[4] ;// rangefinder rayfloat constraint[4] ;// constraintfloat slidercrank[4] ;// slidercrankfloat crankbroken[4] ;// used when crank must be stretched/brokenfloat frustum[4] ;// camera frustumfloat bv[4] ;// bounding volumefloat bvactive[4] ;// active bounding volume<C_BINDER_MOJO_NEWLINE>}rgba ; <C_BINDER_MOJO_NEWLINE><C_BINDER_MOJO_NEWLINE>}; <C_BINDER_MOJO_NEWLINE>typedefstruct mjVisual_mjVisual<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>//---------------------------------- mjStatistic ---------------------------------------------------<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>struct mjStatistic_{ <C_BINDER_MOJO_NEWLINE>// model statistics  ( in qpos0 ) mjtNum meaninertia ;<C_BINDER_MOJO_NEWLINE>// mean diagonal inertiamjtNum meanmass ;<C_BINDER_MOJO_NEWLINE>// mean body massmjtNum meansize ;<C_BINDER_MOJO_NEWLINE>// mean body sizemjtNum extent ;<C_BINDER_MOJO_NEWLINE>// spatial extentmjtNum center[3] ;<C_BINDER_MOJO_NEWLINE>// center of model<C_BINDER_MOJO_NEWLINE>}; <C_BINDER_MOJO_NEWLINE>typedefstruct mjStatistic_mjStatistic<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>//---------------------------------- mjModel -------------------------------------------------------<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>struct mjModel_{ <C_BINDER_MOJO_NEWLINE>// ------------------------------- sizes// sizes needed at mjModel constructionint nq ;<C_BINDER_MOJO_NEWLINE>// number of generalized coordinates  =  dim ( qpos ) int nv ;<C_BINDER_MOJO_NEWLINE>// number of degrees of freedom  =  dim ( qvel ) int nu ;<C_BINDER_MOJO_NEWLINE>// number of actuators/controls  =  dim ( ctrl ) int na ;<C_BINDER_MOJO_NEWLINE>// number of activation states  =  dim ( act ) int nbody ;<C_BINDER_MOJO_NEWLINE>// number of bodiesint nbvh ;<C_BINDER_MOJO_NEWLINE>// number of total bounding volumes in all bodiesint nbvhstatic ;<C_BINDER_MOJO_NEWLINE>// number of static bounding volumes  ( aabb stored in mjModel ) int nbvhdynamic ;<C_BINDER_MOJO_NEWLINE>// number of dynamic bounding volumes  ( aabb stored in mjData ) int njnt ;<C_BINDER_MOJO_NEWLINE>// number of jointsint ngeom ;<C_BINDER_MOJO_NEWLINE>// number of geomsint nsite ;<C_BINDER_MOJO_NEWLINE>// number of sitesint ncam ;<C_BINDER_MOJO_NEWLINE>// number of camerasint nlight ;<C_BINDER_MOJO_NEWLINE>// number of lightsint nflex ;<C_BINDER_MOJO_NEWLINE>// number of flexesint nflexvert ;<C_BINDER_MOJO_NEWLINE>// number of vertices in all flexesint nflexedge ;<C_BINDER_MOJO_NEWLINE>// number of edges in all flexesint nflexelem ;<C_BINDER_MOJO_NEWLINE>// number of elements in all flexesint nflexelemdata ;<C_BINDER_MOJO_NEWLINE>// number of element vertex ids in all flexesint nflexelemedge ;<C_BINDER_MOJO_NEWLINE>// number of element edge ids in all flexesint nflexshelldata ;<C_BINDER_MOJO_NEWLINE>// number of shell fragment vertex ids in all flexesint nflexevpair ;<C_BINDER_MOJO_NEWLINE>// number of element-vertex pairs in all flexesint nflextexcoord ;<C_BINDER_MOJO_NEWLINE>// number of vertices with texture coordinatesint nmesh ;<C_BINDER_MOJO_NEWLINE>// number of meshesint nmeshvert ;<C_BINDER_MOJO_NEWLINE>// number of vertices in all meshesint nmeshnormal ;<C_BINDER_MOJO_NEWLINE>// number of normals in all meshesint nmeshtexcoord ;<C_BINDER_MOJO_NEWLINE>// number of texcoords in all meshesint nmeshface ;<C_BINDER_MOJO_NEWLINE>// number of triangular faces in all meshesint nmeshgraph ;<C_BINDER_MOJO_NEWLINE>// number of ints in mesh auxiliary dataint nskin ;<C_BINDER_MOJO_NEWLINE>// number of skinsint nskinvert ;<C_BINDER_MOJO_NEWLINE>// number of vertices in all skinsint nskintexvert ;<C_BINDER_MOJO_NEWLINE>// number of vertiex with texcoords in all skinsint nskinface ;<C_BINDER_MOJO_NEWLINE>// number of triangular faces in all skinsint nskinbone ;<C_BINDER_MOJO_NEWLINE>// number of bones in all skinsint nskinbonevert ;<C_BINDER_MOJO_NEWLINE>// number of vertices in all skin bonesint nhfield ;<C_BINDER_MOJO_NEWLINE>// number of heightfieldsint nhfielddata ;<C_BINDER_MOJO_NEWLINE>// number of data points in all heightfieldsint ntex ;<C_BINDER_MOJO_NEWLINE>// number of texturesint ntexdata ;<C_BINDER_MOJO_NEWLINE>// number of bytes in texture rgb dataint nmat ;<C_BINDER_MOJO_NEWLINE>// number of materialsint npair ;<C_BINDER_MOJO_NEWLINE>// number of predefined geom pairsint nexclude ;<C_BINDER_MOJO_NEWLINE>// number of excluded geom pairsint neq ;<C_BINDER_MOJO_NEWLINE>// number of equality constraintsint ntendon ;<C_BINDER_MOJO_NEWLINE>// number of tendonsint nwrap ;<C_BINDER_MOJO_NEWLINE>// number of wrap objects in all tendon pathsint nsensor ;<C_BINDER_MOJO_NEWLINE>// number of sensorsint nnumeric ;<C_BINDER_MOJO_NEWLINE>// number of numeric custom fieldsint nnumericdata ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in all numeric fieldsint ntext ;<C_BINDER_MOJO_NEWLINE>// number of text custom fieldsint ntextdata ;<C_BINDER_MOJO_NEWLINE>// number of mjtBytes in all text fieldsint ntuple ;<C_BINDER_MOJO_NEWLINE>// number of tuple custom fieldsint ntupledata ;<C_BINDER_MOJO_NEWLINE>// number of objects in all tuple fieldsint nkey ;<C_BINDER_MOJO_NEWLINE>// number of keyframesint nmocap ;<C_BINDER_MOJO_NEWLINE>// number of mocap bodiesint nplugin ;<C_BINDER_MOJO_NEWLINE>// number of plugin instancesint npluginattr ;<C_BINDER_MOJO_NEWLINE>// number of chars in all plugin config attributesint nuser_body ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in body_userint nuser_jnt ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in jnt_userint nuser_geom ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in geom_userint nuser_site ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in site_userint nuser_cam ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in cam_userint nuser_tendon ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in tendon_userint nuser_actuator ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in actuator_userint nuser_sensor ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in sensor_userint nnames ;<C_BINDER_MOJO_NEWLINE>// number of chars in all namesint nnames_map ;<C_BINDER_MOJO_NEWLINE>// number of slots in the names hash mapint npaths ;<C_BINDER_MOJO_NEWLINE>// number of chars in all paths// sizes set after mjModel construction  ( only affect mjData ) int nM ;<C_BINDER_MOJO_NEWLINE>// number of non-zeros in sparse inertia matrixint nB ;<C_BINDER_MOJO_NEWLINE>// number of non-zeros in sparse body-dof matrixint nC ;<C_BINDER_MOJO_NEWLINE>// number of non-zeros in sparse reduced dof-dof matrixint nD ;<C_BINDER_MOJO_NEWLINE>// number of non-zeros in sparse dof-dof matrixint ntree ;<C_BINDER_MOJO_NEWLINE>// number of kinematic trees under world bodyint ngravcomp ;<C_BINDER_MOJO_NEWLINE>// number of bodies with nonzero gravcompint nemax ;<C_BINDER_MOJO_NEWLINE>// number of potential equality-constraint rowsint njmax ;<C_BINDER_MOJO_NEWLINE>// number of available rows in constraint Jacobianint nconmax ;<C_BINDER_MOJO_NEWLINE>// number of potential contacts in contact listint nuserdata ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums reserved for the userint nsensordata ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in sensor data vectorint npluginstate ;<C_BINDER_MOJO_NEWLINE>// number of mjtNums in plugin state vectorsize_t narena ;<C_BINDER_MOJO_NEWLINE>// number of bytes in the mjData arena  ( inclusive of stack ) size_t nbuffer ;<C_BINDER_MOJO_NEWLINE>// number of bytes in buffer// ------------------------------- options and statisticsmjOption opt ;<C_BINDER_MOJO_NEWLINE>// physics optionsmjVisual vis ;<C_BINDER_MOJO_NEWLINE>// visualization optionsmjStatistic stat ;<C_BINDER_MOJO_NEWLINE>// model statistics// ------------------------------- buffers// main buffervoid*     buffer ;<C_BINDER_MOJO_NEWLINE>// main buffer ;  all pointers point in it     ( nbuffer ) // default generalized coordinatesmjtNum*   qpos0 ;<C_BINDER_MOJO_NEWLINE>// qpos values at default pose               ( nq x 1 ) mjtNum*   qpos_spring ;<C_BINDER_MOJO_NEWLINE>// reference pose for springs                ( nq x 1 ) // bodiesint*      body_parentid ;<C_BINDER_MOJO_NEWLINE>// id of body's parent                       ( nbody x 1 ) int*      body_rootid ;<C_BINDER_MOJO_NEWLINE>// id of root above body                     ( nbody x 1 ) int*      body_weldid ;<C_BINDER_MOJO_NEWLINE>// id of body that this body is welded to    ( nbody x 1 ) int*      body_mocapid ;<C_BINDER_MOJO_NEWLINE>// id of mocap data ;  -1: none                ( nbody x 1 ) int*      body_jntnum ;<C_BINDER_MOJO_NEWLINE>// number of joints for this body            ( nbody x 1 ) int*      body_jntadr ;<C_BINDER_MOJO_NEWLINE>// start addr of joints ;  -1: no joints       ( nbody x 1 ) int*      body_dofnum ;<C_BINDER_MOJO_NEWLINE>// number of motion degrees of freedom       ( nbody x 1 ) int*      body_dofadr ;<C_BINDER_MOJO_NEWLINE>// start addr of dofs ;  -1: no dofs           ( nbody x 1 ) int*      body_treeid ;<C_BINDER_MOJO_NEWLINE>// id of body's kinematic tree ;  -1: static   ( nbody x 1 ) int*      body_geomnum ;<C_BINDER_MOJO_NEWLINE>// number of geoms                           ( nbody x 1 ) int*      body_geomadr ;<C_BINDER_MOJO_NEWLINE>// start addr of geoms ;  -1: no geoms         ( nbody x 1 ) mjtByte*  body_simple ;<C_BINDER_MOJO_NEWLINE>// 1: diag M ;  2: diag M ,  sliders only        ( nbody x 1 ) mjtByte*  body_sameframe ;<C_BINDER_MOJO_NEWLINE>// same frame as inertia  ( mjtSameframe )       ( nbody x 1 ) mjtNum*   body_pos ;<C_BINDER_MOJO_NEWLINE>// position offset rel. to parent body       ( nbody x 3 ) mjtNum*   body_quat ;<C_BINDER_MOJO_NEWLINE>// orientation offset rel. to parent body    ( nbody x 4 ) mjtNum*   body_ipos ;<C_BINDER_MOJO_NEWLINE>// local position of center of mass          ( nbody x 3 ) mjtNum*   body_iquat ;<C_BINDER_MOJO_NEWLINE>// local orientation of inertia ellipsoid    ( nbody x 4 ) mjtNum*   body_mass ;<C_BINDER_MOJO_NEWLINE>// mass                                      ( nbody x 1 ) mjtNum*   body_subtreemass ;<C_BINDER_MOJO_NEWLINE>// mass of subtree starting at this body     ( nbody x 1 ) mjtNum*   body_inertia ;<C_BINDER_MOJO_NEWLINE>// diagonal inertia in ipos/iquat frame      ( nbody x 3 ) mjtNum*   body_invweight0 ;<C_BINDER_MOJO_NEWLINE>// mean inv inert in qpos0  ( trn ,  rot )         ( nbody x 2 ) mjtNum*   body_gravcomp ;<C_BINDER_MOJO_NEWLINE>// antigravity force ,  units of body weight   ( nbody x 1 ) mjtNum*   body_margin ;<C_BINDER_MOJO_NEWLINE>// MAX over all geom margins                 ( nbody x 1 ) mjtNum*   body_user ;<C_BINDER_MOJO_NEWLINE>// user data                                 ( nbody x nuser_body ) int*      body_plugin ;<C_BINDER_MOJO_NEWLINE>// plugin instance id ;  -1: not in use        ( nbody x 1 ) int*      body_contype ;<C_BINDER_MOJO_NEWLINE>// OR over all geom contypes                 ( nbody x 1 ) int*      body_conaffinity ;<C_BINDER_MOJO_NEWLINE>// OR over all geom conaffinities            ( nbody x 1 ) int*      body_bvhadr ;<C_BINDER_MOJO_NEWLINE>// address of bvh root                       ( nbody x 1 ) int*      body_bvhnum ;<C_BINDER_MOJO_NEWLINE>// number of bounding volumes                ( nbody x 1 ) // bounding volume hierarchyint*      bvh_depth ;<C_BINDER_MOJO_NEWLINE>// depth in the bounding volume hierarchy    ( nbvh x 1 ) int*      bvh_child ;<C_BINDER_MOJO_NEWLINE>// left and right children in tree           ( nbvh x 2 ) int*      bvh_nodeid ;<C_BINDER_MOJO_NEWLINE>// geom or elem id of node ;  -1: non-leaf     ( nbvh x 1 ) mjtNum*   bvh_aabb ;<C_BINDER_MOJO_NEWLINE>// local bounding box  ( center ,  size )          ( nbvhstatic x 6 ) // jointsint*      jnt_type ;<C_BINDER_MOJO_NEWLINE>// type of joint  ( mjtJoint )                   ( njnt x 1 ) int*      jnt_qposadr ;<C_BINDER_MOJO_NEWLINE>// start addr in 'qpos' for joint's data     ( njnt x 1 ) int*      jnt_dofadr ;<C_BINDER_MOJO_NEWLINE>// start addr in 'qvel' for joint's data     ( njnt x 1 ) int*      jnt_bodyid ;<C_BINDER_MOJO_NEWLINE>// id of joint's body                        ( njnt x 1 ) int*      jnt_group ;<C_BINDER_MOJO_NEWLINE>// group for visibility                      ( njnt x 1 ) mjtByte*  jnt_limited ;<C_BINDER_MOJO_NEWLINE>// does joint have limits                    ( njnt x 1 ) mjtByte*  jnt_actfrclimited ;<C_BINDER_MOJO_NEWLINE>// does joint have actuator force limits     ( njnt x 1 ) mjtByte*  jnt_actgravcomp ;<C_BINDER_MOJO_NEWLINE>// is gravcomp force applied via actuators   ( njnt x 1 ) mjtNum*   jnt_solref ;<C_BINDER_MOJO_NEWLINE>// constraint solver reference: limit        ( njnt x mjNREF ) mjtNum*   jnt_solimp ;<C_BINDER_MOJO_NEWLINE>// constraint solver impedance: limit        ( njnt x mjNIMP ) mjtNum*   jnt_pos ;<C_BINDER_MOJO_NEWLINE>// local anchor position                     ( njnt x 3 ) mjtNum*   jnt_axis ;<C_BINDER_MOJO_NEWLINE>// local joint axis                          ( njnt x 3 ) mjtNum*   jnt_stiffness ;<C_BINDER_MOJO_NEWLINE>// stiffness coefficient                     ( njnt x 1 ) mjtNum*   jnt_range ;<C_BINDER_MOJO_NEWLINE>// joint limits                              ( njnt x 2 ) mjtNum*   jnt_actfrcrange ;<C_BINDER_MOJO_NEWLINE>// range of total actuator force             ( njnt x 2 ) mjtNum*   jnt_margin ;<C_BINDER_MOJO_NEWLINE>// min distance for limit detection          ( njnt x 1 ) mjtNum*   jnt_user ;<C_BINDER_MOJO_NEWLINE>// user data                                 ( njnt x nuser_jnt ) // dofsint*      dof_bodyid ;<C_BINDER_MOJO_NEWLINE>// id of dof's body                          ( nv x 1 ) int*      dof_jntid ;<C_BINDER_MOJO_NEWLINE>// id of dof's joint                         ( nv x 1 ) int*      dof_parentid ;<C_BINDER_MOJO_NEWLINE>// id of dof's parent ;  -1: none              ( nv x 1 ) int*      dof_treeid ;<C_BINDER_MOJO_NEWLINE>// id of dof's kinematic tree                ( nv x 1 ) int*      dof_Madr ;<C_BINDER_MOJO_NEWLINE>// dof address in M-diagonal                 ( nv x 1 ) int*      dof_simplenum ;<C_BINDER_MOJO_NEWLINE>// number of consecutive simple dofs         ( nv x 1 ) mjtNum*   dof_solref ;<C_BINDER_MOJO_NEWLINE>// constraint solver reference:frictionloss  ( nv x mjNREF ) mjtNum*   dof_solimp ;<C_BINDER_MOJO_NEWLINE>// constraint solver impedance:frictionloss  ( nv x mjNIMP ) mjtNum*   dof_frictionloss ;<C_BINDER_MOJO_NEWLINE>// dof friction loss                         ( nv x 1 ) mjtNum*   dof_armature ;<C_BINDER_MOJO_NEWLINE>// dof armature inertia/mass                 ( nv x 1 ) mjtNum*   dof_damping ;<C_BINDER_MOJO_NEWLINE>// damping coefficient                       ( nv x 1 ) mjtNum*   dof_invweight0 ;<C_BINDER_MOJO_NEWLINE>// diag. inverse inertia in qpos0            ( nv x 1 ) mjtNum*   dof_M0 ;<C_BINDER_MOJO_NEWLINE>// diag. inertia in qpos0                    ( nv x 1 ) // geomsint*      geom_type ;<C_BINDER_MOJO_NEWLINE>// geometric type  ( mjtGeom )                   ( ngeom x 1 ) int*      geom_contype ;<C_BINDER_MOJO_NEWLINE>// geom contact type                         ( ngeom x 1 ) int*      geom_conaffinity ;<C_BINDER_MOJO_NEWLINE>// geom contact affinity                     ( ngeom x 1 ) int*      geom_condim ;<C_BINDER_MOJO_NEWLINE>// contact dimensionality  ( 1 ,  3 ,  4 ,  6 )        ( ngeom x 1 ) int*      geom_bodyid ;<C_BINDER_MOJO_NEWLINE>// id of geom's body                         ( ngeom x 1 ) int*      geom_dataid ;<C_BINDER_MOJO_NEWLINE>// id of geom's mesh/hfield ;  -1: none        ( ngeom x 1 ) int*      geom_matid ;<C_BINDER_MOJO_NEWLINE>// material id for rendering ;  -1: none       ( ngeom x 1 ) int*      geom_group ;<C_BINDER_MOJO_NEWLINE>// group for visibility                      ( ngeom x 1 ) int*      geom_priority ;<C_BINDER_MOJO_NEWLINE>// geom contact priority                     ( ngeom x 1 ) int*      geom_plugin ;<C_BINDER_MOJO_NEWLINE>// plugin instance id ;  -1: not in use        ( ngeom x 1 ) mjtByte*  geom_sameframe ;<C_BINDER_MOJO_NEWLINE>// same frame as body  ( mjtSameframe )          ( ngeom x 1 ) mjtNum*   geom_solmix ;<C_BINDER_MOJO_NEWLINE>// mixing coef for solref/imp in geom pair   ( ngeom x 1 ) mjtNum*   geom_solref ;<C_BINDER_MOJO_NEWLINE>// constraint solver reference: contact      ( ngeom x mjNREF ) mjtNum*   geom_solimp ;<C_BINDER_MOJO_NEWLINE>// constraint solver impedance: contact      ( ngeom x mjNIMP ) mjtNum*   geom_size ;<C_BINDER_MOJO_NEWLINE>// geom-specific size parameters             ( ngeom x 3 ) mjtNum*   geom_aabb ;<C_BINDER_MOJO_NEWLINE>// bounding box ,   ( center ,  size )               ( ngeom x 6 ) mjtNum*   geom_rbound ;<C_BINDER_MOJO_NEWLINE>// radius of bounding sphere                 ( ngeom x 1 ) mjtNum*   geom_pos ;<C_BINDER_MOJO_NEWLINE>// local position offset rel. to body        ( ngeom x 3 ) mjtNum*   geom_quat ;<C_BINDER_MOJO_NEWLINE>// local orientation offset rel. to body     ( ngeom x 4 ) mjtNum*   geom_friction ;<C_BINDER_MOJO_NEWLINE>// friction for  ( slide ,  spin ,  roll )           ( ngeom x 3 ) mjtNum*   geom_margin ;<C_BINDER_MOJO_NEWLINE>// detect contact if dist<margin             ( ngeom x 1 ) mjtNum*   geom_gap ;<C_BINDER_MOJO_NEWLINE>// include in solver if dist<margin-gap      ( ngeom x 1 ) mjtNum*   geom_fluid ;<C_BINDER_MOJO_NEWLINE>// fluid interaction parameters              ( ngeom x mjNFLUID ) mjtNum*   geom_user ;<C_BINDER_MOJO_NEWLINE>// user data                                 ( ngeom x nuser_geom ) float*    geom_rgba ;<C_BINDER_MOJO_NEWLINE>// rgba when material is omitted             ( ngeom x 4 ) // sitesint*      site_type ;<C_BINDER_MOJO_NEWLINE>// geom type for rendering  ( mjtGeom )          ( nsite x 1 ) int*      site_bodyid ;<C_BINDER_MOJO_NEWLINE>// id of site's body                         ( nsite x 1 ) int*      site_matid ;<C_BINDER_MOJO_NEWLINE>// material id for rendering ;  -1: none       ( nsite x 1 ) int*      site_group ;<C_BINDER_MOJO_NEWLINE>// group for visibility                      ( nsite x 1 ) mjtByte*  site_sameframe ;<C_BINDER_MOJO_NEWLINE>// same frame as body  ( mjtSameframe )          ( nsite x 1 ) mjtNum*   site_size ;<C_BINDER_MOJO_NEWLINE>// geom size for rendering                   ( nsite x 3 ) mjtNum*   site_pos ;<C_BINDER_MOJO_NEWLINE>// local position offset rel. to body        ( nsite x 3 ) mjtNum*   site_quat ;<C_BINDER_MOJO_NEWLINE>// local orientation offset rel. to body     ( nsite x 4 ) mjtNum*   site_user ;<C_BINDER_MOJO_NEWLINE>// user data                                 ( nsite x nuser_site ) float*    site_rgba ;<C_BINDER_MOJO_NEWLINE>// rgba when material is omitted             ( nsite x 4 ) // camerasint*      cam_mode ;<C_BINDER_MOJO_NEWLINE>// camera tracking mode  ( mjtCamLight )         ( ncam x 1 ) int*      cam_bodyid ;<C_BINDER_MOJO_NEWLINE>// id of camera's body                       ( ncam x 1 ) int*      cam_targetbodyid ;<C_BINDER_MOJO_NEWLINE>// id of targeted body ;  -1: none             ( ncam x 1 ) mjtNum*   cam_pos ;<C_BINDER_MOJO_NEWLINE>// position rel. to body frame               ( ncam x 3 ) mjtNum*   cam_quat ;<C_BINDER_MOJO_NEWLINE>// orientation rel. to body frame            ( ncam x 4 ) mjtNum*   cam_poscom0 ;<C_BINDER_MOJO_NEWLINE>// global position rel. to sub-com in qpos0  ( ncam x 3 ) mjtNum*   cam_pos0 ;<C_BINDER_MOJO_NEWLINE>// global position rel. to body in qpos0     ( ncam x 3 ) mjtNum*   cam_mat0 ;<C_BINDER_MOJO_NEWLINE>// global orientation in qpos0               ( ncam x 9 ) int*      cam_orthographic ;<C_BINDER_MOJO_NEWLINE>// orthographic camera ;  0: no ,  1: yes        ( ncam x 1 ) mjtNum*   cam_fovy ;<C_BINDER_MOJO_NEWLINE>// y field-of-view  ( ortho ? len : deg )        ( ncam x 1 ) mjtNum*   cam_ipd ;<C_BINDER_MOJO_NEWLINE>// inter-pupilary distance                   ( ncam x 1 ) int*      cam_resolution ;<C_BINDER_MOJO_NEWLINE>// resolution: pixels [width ,  height]        ( ncam x 2 ) float*    cam_sensorsize ;<C_BINDER_MOJO_NEWLINE>// sensor size: length [width ,  height]       ( ncam x 2 ) float*    cam_intrinsic ;<C_BINDER_MOJO_NEWLINE>// [focal length ;  principal point]           ( ncam x 4 ) mjtNum*   cam_user ;<C_BINDER_MOJO_NEWLINE>// user data                                 ( ncam x nuser_cam ) // lightsint*      light_mode ;<C_BINDER_MOJO_NEWLINE>// light tracking mode  ( mjtCamLight )          ( nlight x 1 ) int*      light_bodyid ;<C_BINDER_MOJO_NEWLINE>// id of light's body                        ( nlight x 1 ) int*      light_targetbodyid ;<C_BINDER_MOJO_NEWLINE>// id of targeted body ;  -1: none             ( nlight x 1 ) mjtByte*  light_directional ;<C_BINDER_MOJO_NEWLINE>// directional light                         ( nlight x 1 ) mjtByte*  light_castshadow ;<C_BINDER_MOJO_NEWLINE>// does light cast shadows                   ( nlight x 1 ) float*    light_bulbradius ;<C_BINDER_MOJO_NEWLINE>// light radius for soft shadows             ( nlight x 1 ) mjtByte*  light_active ;<C_BINDER_MOJO_NEWLINE>// is light on                               ( nlight x 1 ) mjtNum*   light_pos ;<C_BINDER_MOJO_NEWLINE>// position rel. to body frame               ( nlight x 3 ) mjtNum*   light_dir ;<C_BINDER_MOJO_NEWLINE>// direction rel. to body frame              ( nlight x 3 ) mjtNum*   light_poscom0 ;<C_BINDER_MOJO_NEWLINE>// global position rel. to sub-com in qpos0  ( nlight x 3 ) mjtNum*   light_pos0 ;<C_BINDER_MOJO_NEWLINE>// global position rel. to body in qpos0     ( nlight x 3 ) mjtNum*   light_dir0 ;<C_BINDER_MOJO_NEWLINE>// global direction in qpos0                 ( nlight x 3 ) float*    light_attenuation ;<C_BINDER_MOJO_NEWLINE>// OpenGL attenuation  ( quadratic model )       ( nlight x 3 ) float*    light_cutoff ;<C_BINDER_MOJO_NEWLINE>// OpenGL cutoff                             ( nlight x 1 ) float*    light_exponent ;<C_BINDER_MOJO_NEWLINE>// OpenGL exponent                           ( nlight x 1 ) float*    light_ambient ;<C_BINDER_MOJO_NEWLINE>// ambient rgb  ( alpha = 1 )                      ( nlight x 3 ) float*    light_diffuse ;<C_BINDER_MOJO_NEWLINE>// diffuse rgb  ( alpha = 1 )                      ( nlight x 3 ) float*    light_specular ;<C_BINDER_MOJO_NEWLINE>// specular rgb  ( alpha = 1 )                     ( nlight x 3 ) // flexes: contact propertiesint*      flex_contype ;<C_BINDER_MOJO_NEWLINE>// flex contact type                         ( nflex x 1 ) int*      flex_conaffinity ;<C_BINDER_MOJO_NEWLINE>// flex contact affinity                     ( nflex x 1 ) int*      flex_condim ;<C_BINDER_MOJO_NEWLINE>// contact dimensionality  ( 1 ,  3 ,  4 ,  6 )        ( nflex x 1 ) int*      flex_priority ;<C_BINDER_MOJO_NEWLINE>// flex contact priority                     ( nflex x 1 ) mjtNum*   flex_solmix ;<C_BINDER_MOJO_NEWLINE>// mix coef for solref/imp in contact pair   ( nflex x 1 ) mjtNum*   flex_solref ;<C_BINDER_MOJO_NEWLINE>// constraint solver reference: contact      ( nflex x mjNREF ) mjtNum*   flex_solimp ;<C_BINDER_MOJO_NEWLINE>// constraint solver impedance: contact      ( nflex x mjNIMP ) mjtNum*   flex_friction ;<C_BINDER_MOJO_NEWLINE>// friction for  ( slide ,  spin ,  roll )           ( nflex x 3 ) mjtNum*   flex_margin ;<C_BINDER_MOJO_NEWLINE>// detect contact if dist<margin             ( nflex x 1 ) mjtNum*   flex_gap ;<C_BINDER_MOJO_NEWLINE>// include in solver if dist<margin-gap      ( nflex x 1 ) mjtByte*  flex_internal ;<C_BINDER_MOJO_NEWLINE>// internal flex collision enabled           ( nflex x 1 ) int*      flex_selfcollide ;<C_BINDER_MOJO_NEWLINE>// self collision mode  ( mjtFlexSelf )          ( nflex x 1 ) int*      flex_activelayers ;<C_BINDER_MOJO_NEWLINE>// number of active element layers ,  3D only  ( nflex x 1 ) // flexes: other propertiesint*      flex_dim ;<C_BINDER_MOJO_NEWLINE>// 1: lines ,  2: triangles ,  3: tetrahedra     ( nflex x 1 ) int*      flex_matid ;<C_BINDER_MOJO_NEWLINE>// material id for rendering                 ( nflex x 1 ) int*      flex_group ;<C_BINDER_MOJO_NEWLINE>// group for visibility                      ( nflex x 1 ) int*      flex_vertadr ;<C_BINDER_MOJO_NEWLINE>// first vertex address                      ( nflex x 1 ) int*      flex_vertnum ;<C_BINDER_MOJO_NEWLINE>// number of vertices                        ( nflex x 1 ) int*      flex_edgeadr ;<C_BINDER_MOJO_NEWLINE>// first edge address                        ( nflex x 1 ) int*      flex_edgenum ;<C_BINDER_MOJO_NEWLINE>// number of edges                           ( nflex x 1 ) int*      flex_elemadr ;<C_BINDER_MOJO_NEWLINE>// first element address                     ( nflex x 1 ) int*      flex_elemnum ;<C_BINDER_MOJO_NEWLINE>// number of elements                        ( nflex x 1 ) int*      flex_elemdataadr ;<C_BINDER_MOJO_NEWLINE>// first element vertex id address           ( nflex x 1 ) int*      flex_elemedgeadr ;<C_BINDER_MOJO_NEWLINE>// first element edge id address             ( nflex x 1 ) int*      flex_shellnum ;<C_BINDER_MOJO_NEWLINE>// number of shells                          ( nflex x 1 ) int*      flex_shelldataadr ;<C_BINDER_MOJO_NEWLINE>// first shell data address                  ( nflex x 1 ) int*      flex_evpairadr ;<C_BINDER_MOJO_NEWLINE>// first evpair address                      ( nflex x 1 ) int*      flex_evpairnum ;<C_BINDER_MOJO_NEWLINE>// number of evpairs                         ( nflex x 1 ) int*      flex_texcoordadr ;<C_BINDER_MOJO_NEWLINE>// address in flex_texcoord ;  -1: none        ( nflex x 1 ) int*      flex_vertbodyid ;<C_BINDER_MOJO_NEWLINE>// vertex body ids                           ( nflexvert x 1 ) int*      flex_edge ;<C_BINDER_MOJO_NEWLINE>// edge vertex ids  ( 2 per edge )               ( nflexedge x 2 ) int*      flex_elem ;<C_BINDER_MOJO_NEWLINE>// element vertex ids  ( dim+1 per elem )        ( nflexelemdata x 1 ) int*      flex_elemedge ;<C_BINDER_MOJO_NEWLINE>// element edge ids                          ( nflexelemedge x 1 ) int*      flex_elemlayer ;<C_BINDER_MOJO_NEWLINE>// element distance from surface ,  3D only    ( nflexelem x 1 ) int*      flex_shell ;<C_BINDER_MOJO_NEWLINE>// shell fragment vertex ids  ( dim per frag )   ( nflexshelldata x 1 ) int*      flex_evpair ;<C_BINDER_MOJO_NEWLINE>//  ( element ,  vertex )  collision pairs         ( nflexevpair x 2 ) mjtNum*   flex_vert ;<C_BINDER_MOJO_NEWLINE>// vertex positions in local body frames     ( nflexvert x 3 ) mjtNum*   flex_xvert0 ;<C_BINDER_MOJO_NEWLINE>// Cartesian vertex positions in qpos0       ( nflexvert x 3 ) mjtNum*   flexedge_length0 ;<C_BINDER_MOJO_NEWLINE>// edge lengths in qpos0                     ( nflexedge x 1 ) mjtNum*   flexedge_invweight0 ;<C_BINDER_MOJO_NEWLINE>// edge inv. weight in qpos0                 ( nflexedge x 1 ) mjtNum*   flex_radius ;<C_BINDER_MOJO_NEWLINE>// radius around primitive element           ( nflex x 1 ) mjtNum*   flex_stiffness ;<C_BINDER_MOJO_NEWLINE>// finite element stiffness matrix           ( nflexelem x 21 ) mjtNum*   flex_damping ;<C_BINDER_MOJO_NEWLINE>// Rayleigh's damping coefficient            ( nflex x 1 ) mjtNum*   flex_edgestiffness ;<C_BINDER_MOJO_NEWLINE>// edge stiffness                            ( nflex x 1 ) mjtNum*   flex_edgedamping ;<C_BINDER_MOJO_NEWLINE>// edge damping                              ( nflex x 1 ) mjtByte*  flex_edgeequality ;<C_BINDER_MOJO_NEWLINE>// is edge equality constraint defined       ( nflex x 1 ) mjtByte*  flex_rigid ;<C_BINDER_MOJO_NEWLINE>// are all verices in the same body          ( nflex x 1 ) mjtByte*  flexedge_rigid ;<C_BINDER_MOJO_NEWLINE>// are both edge vertices in same body       ( nflexedge x 1 ) mjtByte*  flex_centered ;<C_BINDER_MOJO_NEWLINE>// are all vertex coordinates  ( 0 , 0 , 0 )         ( nflex x 1 ) mjtByte*  flex_flatskin ;<C_BINDER_MOJO_NEWLINE>// render flex skin with flat shading        ( nflex x 1 ) int*      flex_bvhadr ;<C_BINDER_MOJO_NEWLINE>// address of bvh root ;  -1: no bvh           ( nflex x 1 ) int*      flex_bvhnum ;<C_BINDER_MOJO_NEWLINE>// number of bounding volumes                ( nflex x 1 ) float*    flex_rgba ;<C_BINDER_MOJO_NEWLINE>// rgba when material is omitted             ( nflex x 4 ) float*    flex_texcoord ;<C_BINDER_MOJO_NEWLINE>// vertex texture coordinates                ( nflextexcoord x 2 ) // meshesint*      mesh_vertadr ;<C_BINDER_MOJO_NEWLINE>// first vertex address                      ( nmesh x 1 ) int*      mesh_vertnum ;<C_BINDER_MOJO_NEWLINE>// number of vertices                        ( nmesh x 1 ) int*      mesh_faceadr ;<C_BINDER_MOJO_NEWLINE>// first face address                        ( nmesh x 1 ) int*      mesh_facenum ;<C_BINDER_MOJO_NEWLINE>// number of faces                           ( nmesh x 1 ) int*      mesh_bvhadr ;<C_BINDER_MOJO_NEWLINE>// address of bvh root                       ( nmesh x 1 ) int*      mesh_bvhnum ;<C_BINDER_MOJO_NEWLINE>// number of bvh                             ( nmesh x 1 ) int*      mesh_normaladr ;<C_BINDER_MOJO_NEWLINE>// first normal address                      ( nmesh x 1 ) int*      mesh_normalnum ;<C_BINDER_MOJO_NEWLINE>// number of normals                         ( nmesh x 1 ) int*      mesh_texcoordadr ;<C_BINDER_MOJO_NEWLINE>// texcoord data address ;  -1: no texcoord    ( nmesh x 1 ) int*      mesh_texcoordnum ;<C_BINDER_MOJO_NEWLINE>// number of texcoord                        ( nmesh x 1 ) int*      mesh_graphadr ;<C_BINDER_MOJO_NEWLINE>// graph data address ;  -1: no graph          ( nmesh x 1 ) float*    mesh_vert ;<C_BINDER_MOJO_NEWLINE>// vertex positions for all meshes           ( nmeshvert x 3 ) float*    mesh_normal ;<C_BINDER_MOJO_NEWLINE>// normals for all meshes                    ( nmeshnormal x 3 ) float*    mesh_texcoord ;<C_BINDER_MOJO_NEWLINE>// vertex texcoords for all meshes           ( nmeshtexcoord x 2 ) int*      mesh_face ;<C_BINDER_MOJO_NEWLINE>// vertex face data                          ( nmeshface x 3 ) int*      mesh_facenormal ;<C_BINDER_MOJO_NEWLINE>// normal face data                          ( nmeshface x 3 ) int*      mesh_facetexcoord ;<C_BINDER_MOJO_NEWLINE>// texture face data                         ( nmeshface x 3 ) int*      mesh_graph ;<C_BINDER_MOJO_NEWLINE>// convex graph data                         ( nmeshgraph x 1 ) mjtNum*   mesh_scale ;<C_BINDER_MOJO_NEWLINE>// scaling applied to asset vertices         ( nmesh x 3 ) mjtNum*   mesh_pos ;<C_BINDER_MOJO_NEWLINE>// translation applied to asset vertices     ( nmesh x 3 ) mjtNum*   mesh_quat ;<C_BINDER_MOJO_NEWLINE>// rotation applied to asset vertices        ( nmesh x 4 ) int*      mesh_pathadr ;<C_BINDER_MOJO_NEWLINE>// address of asset path for mesh ;  -1: none  ( nmesh x 1 ) // skinsint*      skin_matid ;<C_BINDER_MOJO_NEWLINE>// skin material id ;  -1: none                ( nskin x 1 ) int*      skin_group ;<C_BINDER_MOJO_NEWLINE>// group for visibility                      ( nskin x 1 ) float*    skin_rgba ;<C_BINDER_MOJO_NEWLINE>// skin rgba                                 ( nskin x 4 ) float*    skin_inflate ;<C_BINDER_MOJO_NEWLINE>// inflate skin in normal direction          ( nskin x 1 ) int*      skin_vertadr ;<C_BINDER_MOJO_NEWLINE>// first vertex address                      ( nskin x 1 ) int*      skin_vertnum ;<C_BINDER_MOJO_NEWLINE>// number of vertices                        ( nskin x 1 ) int*      skin_texcoordadr ;<C_BINDER_MOJO_NEWLINE>// texcoord data address ;  -1: no texcoord    ( nskin x 1 ) int*      skin_faceadr ;<C_BINDER_MOJO_NEWLINE>// first face address                        ( nskin x 1 ) int*      skin_facenum ;<C_BINDER_MOJO_NEWLINE>// number of faces                           ( nskin x 1 ) int*      skin_boneadr ;<C_BINDER_MOJO_NEWLINE>// first bone in skin                        ( nskin x 1 ) int*      skin_bonenum ;<C_BINDER_MOJO_NEWLINE>// number of bones in skin                   ( nskin x 1 ) float*    skin_vert ;<C_BINDER_MOJO_NEWLINE>// vertex positions for all skin meshes      ( nskinvert x 3 ) float*    skin_texcoord ;<C_BINDER_MOJO_NEWLINE>// vertex texcoords for all skin meshes      ( nskintexvert x 2 ) int*      skin_face ;<C_BINDER_MOJO_NEWLINE>// triangle faces for all skin meshes        ( nskinface x 3 ) int*      skin_bonevertadr ;<C_BINDER_MOJO_NEWLINE>// first vertex in each bone                 ( nskinbone x 1 ) int*      skin_bonevertnum ;<C_BINDER_MOJO_NEWLINE>// number of vertices in each bone           ( nskinbone x 1 ) float*    skin_bonebindpos ;<C_BINDER_MOJO_NEWLINE>// bind pos of each bone                     ( nskinbone x 3 ) float*    skin_bonebindquat ;<C_BINDER_MOJO_NEWLINE>// bind quat of each bone                    ( nskinbone x 4 ) int*      skin_bonebodyid ;<C_BINDER_MOJO_NEWLINE>// body id of each bone                      ( nskinbone x 1 ) int*      skin_bonevertid ;<C_BINDER_MOJO_NEWLINE>// mesh ids of vertices in each bone         ( nskinbonevert x 1 ) float*    skin_bonevertweight ;<C_BINDER_MOJO_NEWLINE>// weights of vertices in each bone          ( nskinbonevert x 1 ) int*      skin_pathadr ;<C_BINDER_MOJO_NEWLINE>// address of asset path for skin ;  -1: none  ( nskin x 1 ) // height fieldsmjtNum*   hfield_size ;<C_BINDER_MOJO_NEWLINE>//  ( x ,  y ,  z_top ,  z_bottom )                    ( nhfield x 4 ) int*      hfield_nrow ;<C_BINDER_MOJO_NEWLINE>// number of rows in grid                    ( nhfield x 1 ) int*      hfield_ncol ;<C_BINDER_MOJO_NEWLINE>// number of columns in grid                 ( nhfield x 1 ) int*      hfield_adr ;<C_BINDER_MOJO_NEWLINE>// address in hfield_data                    ( nhfield x 1 ) float*    hfield_data ;<C_BINDER_MOJO_NEWLINE>// elevation data                            ( nhfielddata x 1 ) int*      hfield_pathadr ;<C_BINDER_MOJO_NEWLINE>// address of hfield asset path ;  -1: none    ( nhfield x 1 ) // texturesint*      tex_type ;<C_BINDER_MOJO_NEWLINE>// texture type  ( mjtTexture )                  ( ntex x 1 ) int*      tex_height ;<C_BINDER_MOJO_NEWLINE>// number of rows in texture image           ( ntex x 1 ) int*      tex_width ;<C_BINDER_MOJO_NEWLINE>// number of columns in texture image        ( ntex x 1 ) int*      tex_nchannel ;<C_BINDER_MOJO_NEWLINE>// number of channels in texture image       ( ntex x 1 ) int*      tex_adr ;<C_BINDER_MOJO_NEWLINE>// start address in tex_data                 ( ntex x 1 ) mjtByte*  tex_data ;<C_BINDER_MOJO_NEWLINE>// pixel values                              ( ntexdata x 1 ) int*      tex_pathadr ;<C_BINDER_MOJO_NEWLINE>// address of texture asset path ;  -1: none   ( ntex x 1 ) // materialsint*      mat_texid ;<C_BINDER_MOJO_NEWLINE>// indices of textures ;  -1: none             ( nmat x mjNTEXROLE ) mjtByte*  mat_texuniform ;<C_BINDER_MOJO_NEWLINE>// make texture cube uniform                 ( nmat x 1 ) float*    mat_texrepeat ;<C_BINDER_MOJO_NEWLINE>// texture repetition for 2d mapping         ( nmat x 2 ) float*    mat_emission ;<C_BINDER_MOJO_NEWLINE>// emission  ( x rgb )                           ( nmat x 1 ) float*    mat_specular ;<C_BINDER_MOJO_NEWLINE>// specular  ( x white )                         ( nmat x 1 ) float*    mat_shininess ;<C_BINDER_MOJO_NEWLINE>// shininess coef                            ( nmat x 1 ) float*    mat_reflectance ;<C_BINDER_MOJO_NEWLINE>// reflectance  ( 0: disable )                   ( nmat x 1 ) float*    mat_metallic ;<C_BINDER_MOJO_NEWLINE>// metallic coef                             ( nmat x 1 ) float*    mat_roughness ;<C_BINDER_MOJO_NEWLINE>// roughness coef                            ( nmat x 1 ) float*    mat_rgba ;<C_BINDER_MOJO_NEWLINE>// rgba                                      ( nmat x 4 ) // predefined geom pairs for collision detection ;  has precedence over excludeint*      pair_dim ;<C_BINDER_MOJO_NEWLINE>// contact dimensionality                    ( npair x 1 ) int*      pair_geom1 ;<C_BINDER_MOJO_NEWLINE>// id of geom1                               ( npair x 1 ) int*      pair_geom2 ;<C_BINDER_MOJO_NEWLINE>// id of geom2                               ( npair x 1 ) int*      pair_signature ;<C_BINDER_MOJO_NEWLINE>// body1 << 16 + body2                       ( npair x 1 ) mjtNum*   pair_solref ;<C_BINDER_MOJO_NEWLINE>// solver reference: contact normal          ( npair x mjNREF ) mjtNum*   pair_solreffriction ;<C_BINDER_MOJO_NEWLINE>// solver reference: contact friction        ( npair x mjNREF ) mjtNum*   pair_solimp ;<C_BINDER_MOJO_NEWLINE>// solver impedance: contact                 ( npair x mjNIMP ) mjtNum*   pair_margin ;<C_BINDER_MOJO_NEWLINE>// detect contact if dist<margin             ( npair x 1 ) mjtNum*   pair_gap ;<C_BINDER_MOJO_NEWLINE>// include in solver if dist<margin-gap      ( npair x 1 ) mjtNum*   pair_friction ;<C_BINDER_MOJO_NEWLINE>// tangent1 ,  2 ,  spin ,  roll1 ,  2               ( npair x 5 ) // excluded body pairs for collision detectionint*      exclude_signature ;<C_BINDER_MOJO_NEWLINE>// body1 << 16 + body2                       ( nexclude x 1 ) // equality constraintsint*      eq_type ;<C_BINDER_MOJO_NEWLINE>// constraint type  ( mjtEq )                    ( neq x 1 ) int*      eq_obj1id ;<C_BINDER_MOJO_NEWLINE>// id of object 1                            ( neq x 1 ) int*      eq_obj2id ;<C_BINDER_MOJO_NEWLINE>// id of object 2                            ( neq x 1 ) int*      eq_objtype ;<C_BINDER_MOJO_NEWLINE>// type of both objects  ( mjtObj )              ( neq x 1 ) mjtByte*  eq_active0 ;<C_BINDER_MOJO_NEWLINE>// initial enable/disable constraint state   ( neq x 1 ) mjtNum*   eq_solref ;<C_BINDER_MOJO_NEWLINE>// constraint solver reference               ( neq x mjNREF ) mjtNum*   eq_solimp ;<C_BINDER_MOJO_NEWLINE>// constraint solver impedance               ( neq x mjNIMP ) mjtNum*   eq_data ;<C_BINDER_MOJO_NEWLINE>// numeric data for constraint               ( neq x mjNEQDATA ) // tendonsint*      tendon_adr ;<C_BINDER_MOJO_NEWLINE>// address of first object in tendon's path  ( ntendon x 1 ) int*      tendon_num ;<C_BINDER_MOJO_NEWLINE>// number of objects in tendon's path        ( ntendon x 1 ) int*      tendon_matid ;<C_BINDER_MOJO_NEWLINE>// material id for rendering                 ( ntendon x 1 ) int*      tendon_group ;<C_BINDER_MOJO_NEWLINE>// group for visibility                      ( ntendon x 1 ) mjtByte*  tendon_limited ;<C_BINDER_MOJO_NEWLINE>// does tendon have length limits            ( ntendon x 1 ) mjtNum*   tendon_width ;<C_BINDER_MOJO_NEWLINE>// width for rendering                       ( ntendon x 1 ) mjtNum*   tendon_solref_lim ;<C_BINDER_MOJO_NEWLINE>// constraint solver reference: limit        ( ntendon x mjNREF ) mjtNum*   tendon_solimp_lim ;<C_BINDER_MOJO_NEWLINE>// constraint solver impedance: limit        ( ntendon x mjNIMP ) mjtNum*   tendon_solref_fri ;<C_BINDER_MOJO_NEWLINE>// constraint solver reference: friction     ( ntendon x mjNREF ) mjtNum*   tendon_solimp_fri ;<C_BINDER_MOJO_NEWLINE>// constraint solver impedance: friction     ( ntendon x mjNIMP ) mjtNum*   tendon_range ;<C_BINDER_MOJO_NEWLINE>// tendon length limits                      ( ntendon x 2 ) mjtNum*   tendon_margin ;<C_BINDER_MOJO_NEWLINE>// min distance for limit detection          ( ntendon x 1 ) mjtNum*   tendon_stiffness ;<C_BINDER_MOJO_NEWLINE>// stiffness coefficient                     ( ntendon x 1 ) mjtNum*   tendon_damping ;<C_BINDER_MOJO_NEWLINE>// damping coefficient                       ( ntendon x 1 ) mjtNum*   tendon_frictionloss ;<C_BINDER_MOJO_NEWLINE>// loss due to friction                      ( ntendon x 1 ) mjtNum*   tendon_lengthspring ;<C_BINDER_MOJO_NEWLINE>// spring resting length range               ( ntendon x 2 ) mjtNum*   tendon_length0 ;<C_BINDER_MOJO_NEWLINE>// tendon length in qpos0                    ( ntendon x 1 ) mjtNum*   tendon_invweight0 ;<C_BINDER_MOJO_NEWLINE>// inv. weight in qpos0                      ( ntendon x 1 ) mjtNum*   tendon_user ;<C_BINDER_MOJO_NEWLINE>// user data                                 ( ntendon x nuser_tendon ) float*    tendon_rgba ;<C_BINDER_MOJO_NEWLINE>// rgba when material is omitted             ( ntendon x 4 ) // list of all wrap objects in tendon pathsint*      wrap_type ;<C_BINDER_MOJO_NEWLINE>// wrap object type  ( mjtWrap )                 ( nwrap x 1 ) int*      wrap_objid ;<C_BINDER_MOJO_NEWLINE>// object id: geom ,  site ,  joint              ( nwrap x 1 ) mjtNum*   wrap_prm ;<C_BINDER_MOJO_NEWLINE>// divisor ,  joint coef ,  or site id           ( nwrap x 1 ) // actuatorsint*      actuator_trntype ;<C_BINDER_MOJO_NEWLINE>// transmission type  ( mjtTrn )                 ( nu x 1 ) int*      actuator_dyntype ;<C_BINDER_MOJO_NEWLINE>// dynamics type  ( mjtDyn )                     ( nu x 1 ) int*      actuator_gaintype ;<C_BINDER_MOJO_NEWLINE>// gain type  ( mjtGain )                        ( nu x 1 ) int*      actuator_biastype ;<C_BINDER_MOJO_NEWLINE>// bias type  ( mjtBias )                        ( nu x 1 ) int*      actuator_trnid ;<C_BINDER_MOJO_NEWLINE>// transmission id: joint ,  tendon ,  site      ( nu x 2 ) int*      actuator_actadr ;<C_BINDER_MOJO_NEWLINE>// first activation address ;  -1: stateless   ( nu x 1 ) int*      actuator_actnum ;<C_BINDER_MOJO_NEWLINE>// number of activation variables            ( nu x 1 ) int*      actuator_group ;<C_BINDER_MOJO_NEWLINE>// group for visibility                      ( nu x 1 ) mjtByte*  actuator_ctrllimited ;<C_BINDER_MOJO_NEWLINE>// is control limited                        ( nu x 1 ) mjtByte*  actuator_forcelimited ;<C_BINDER_MOJO_NEWLINE>// is force limited                          ( nu x 1 ) mjtByte*  actuator_actlimited ;<C_BINDER_MOJO_NEWLINE>// is activation limited                     ( nu x 1 ) mjtNum*   actuator_dynprm ;<C_BINDER_MOJO_NEWLINE>// dynamics parameters                       ( nu x mjNDYN ) mjtNum*   actuator_gainprm ;<C_BINDER_MOJO_NEWLINE>// gain parameters                           ( nu x mjNGAIN ) mjtNum*   actuator_biasprm ;<C_BINDER_MOJO_NEWLINE>// bias parameters                           ( nu x mjNBIAS ) mjtByte*  actuator_actearly ;<C_BINDER_MOJO_NEWLINE>// step activation before force              ( nu x 1 ) mjtNum*   actuator_ctrlrange ;<C_BINDER_MOJO_NEWLINE>// range of controls                         ( nu x 2 ) mjtNum*   actuator_forcerange ;<C_BINDER_MOJO_NEWLINE>// range of forces                           ( nu x 2 ) mjtNum*   actuator_actrange ;<C_BINDER_MOJO_NEWLINE>// range of activations                      ( nu x 2 ) mjtNum*   actuator_gear ;<C_BINDER_MOJO_NEWLINE>// scale length and transmitted force        ( nu x 6 ) mjtNum*   actuator_cranklength ;<C_BINDER_MOJO_NEWLINE>// crank length for slider-crank             ( nu x 1 ) mjtNum*   actuator_acc0 ;<C_BINDER_MOJO_NEWLINE>// acceleration from unit force in qpos0     ( nu x 1 ) mjtNum*   actuator_length0 ;<C_BINDER_MOJO_NEWLINE>// actuator length in qpos0                  ( nu x 1 ) mjtNum*   actuator_lengthrange ;<C_BINDER_MOJO_NEWLINE>// feasible actuator length range            ( nu x 2 ) mjtNum*   actuator_user ;<C_BINDER_MOJO_NEWLINE>// user data                                 ( nu x nuser_actuator ) int*      actuator_plugin ;<C_BINDER_MOJO_NEWLINE>// plugin instance id ;  -1: not a plugin      ( nu x 1 ) // sensorsint*      sensor_type ;<C_BINDER_MOJO_NEWLINE>// sensor type  ( mjtSensor )                    ( nsensor x 1 ) int*      sensor_datatype ;<C_BINDER_MOJO_NEWLINE>// numeric data type  ( mjtDataType )            ( nsensor x 1 ) int*      sensor_needstage ;<C_BINDER_MOJO_NEWLINE>// required compute stage  ( mjtStage )          ( nsensor x 1 ) int*      sensor_objtype ;<C_BINDER_MOJO_NEWLINE>// type of sensorized object  ( mjtObj )         ( nsensor x 1 ) int*      sensor_objid ;<C_BINDER_MOJO_NEWLINE>// id of sensorized object                   ( nsensor x 1 ) int*      sensor_reftype ;<C_BINDER_MOJO_NEWLINE>// type of reference frame  ( mjtObj )           ( nsensor x 1 ) int*      sensor_refid ;<C_BINDER_MOJO_NEWLINE>// id of reference frame ;  -1: global frame   ( nsensor x 1 ) int*      sensor_dim ;<C_BINDER_MOJO_NEWLINE>// number of scalar outputs                  ( nsensor x 1 ) int*      sensor_adr ;<C_BINDER_MOJO_NEWLINE>// address in sensor array                   ( nsensor x 1 ) mjtNum*   sensor_cutoff ;<C_BINDER_MOJO_NEWLINE>// cutoff for real and positive ;  0: ignore   ( nsensor x 1 ) mjtNum*   sensor_noise ;<C_BINDER_MOJO_NEWLINE>// noise standard deviation                  ( nsensor x 1 ) mjtNum*   sensor_user ;<C_BINDER_MOJO_NEWLINE>// user data                                 ( nsensor x nuser_sensor ) int*      sensor_plugin ;<C_BINDER_MOJO_NEWLINE>// plugin instance id ;  -1: not a plugin      ( nsensor x 1 ) // plugin instancesint*      plugin ;<C_BINDER_MOJO_NEWLINE>// globally registered plugin slot number    ( nplugin x 1 ) int*      plugin_stateadr ;<C_BINDER_MOJO_NEWLINE>// address in the plugin state array         ( nplugin x 1 ) int*      plugin_statenum ;<C_BINDER_MOJO_NEWLINE>// number of states in the plugin instance   ( nplugin x 1 ) char*     plugin_attr ;<C_BINDER_MOJO_NEWLINE>// config attributes of plugin instances     ( npluginattr x 1 ) int*      plugin_attradr ;<C_BINDER_MOJO_NEWLINE>// address to each instance's config attrib  ( nplugin x 1 ) // custom numeric fieldsint*      numeric_adr ;<C_BINDER_MOJO_NEWLINE>// address of field in numeric_data          ( nnumeric x 1 ) int*      numeric_size ;<C_BINDER_MOJO_NEWLINE>// size of numeric field                     ( nnumeric x 1 ) mjtNum*   numeric_data ;<C_BINDER_MOJO_NEWLINE>// array of all numeric fields               ( nnumericdata x 1 ) // custom text fieldsint*      text_adr ;<C_BINDER_MOJO_NEWLINE>// address of text in text_data              ( ntext x 1 ) int*      text_size ;<C_BINDER_MOJO_NEWLINE>// size of text field  ( strlen+1 )              ( ntext x 1 ) char*     text_data ;<C_BINDER_MOJO_NEWLINE>// array of all text fields  ( 0-terminated )    ( ntextdata x 1 ) // custom tuple fieldsint*      tuple_adr ;<C_BINDER_MOJO_NEWLINE>// address of text in text_data              ( ntuple x 1 ) int*      tuple_size ;<C_BINDER_MOJO_NEWLINE>// number of objects in tuple                ( ntuple x 1 ) int*      tuple_objtype ;<C_BINDER_MOJO_NEWLINE>// array of object types in all tuples       ( ntupledata x 1 ) int*      tuple_objid ;<C_BINDER_MOJO_NEWLINE>// array of object ids in all tuples         ( ntupledata x 1 ) mjtNum*   tuple_objprm ;<C_BINDER_MOJO_NEWLINE>// array of object params in all tuples      ( ntupledata x 1 ) // keyframesmjtNum*   key_time ;<C_BINDER_MOJO_NEWLINE>// key time                                  ( nkey x 1 ) mjtNum*   key_qpos ;<C_BINDER_MOJO_NEWLINE>// key position                              ( nkey x nq ) mjtNum*   key_qvel ;<C_BINDER_MOJO_NEWLINE>// key velocity                              ( nkey x nv ) mjtNum*   key_act ;<C_BINDER_MOJO_NEWLINE>// key activation                            ( nkey x na ) mjtNum*   key_mpos ;<C_BINDER_MOJO_NEWLINE>// key mocap position                        ( nkey x nmocap*3 ) mjtNum*   key_mquat ;<C_BINDER_MOJO_NEWLINE>// key mocap quaternion                      ( nkey x nmocap*4 ) mjtNum*   key_ctrl ;<C_BINDER_MOJO_NEWLINE>// key control                               ( nkey x nu ) // namesint*      name_bodyadr ;<C_BINDER_MOJO_NEWLINE>// body name pointers                        ( nbody x 1 ) int*      name_jntadr ;<C_BINDER_MOJO_NEWLINE>// joint name pointers                       ( njnt x 1 ) int*      name_geomadr ;<C_BINDER_MOJO_NEWLINE>// geom name pointers                        ( ngeom x 1 ) int*      name_siteadr ;<C_BINDER_MOJO_NEWLINE>// site name pointers                        ( nsite x 1 ) int*      name_camadr ;<C_BINDER_MOJO_NEWLINE>// camera name pointers                      ( ncam x 1 ) int*      name_lightadr ;<C_BINDER_MOJO_NEWLINE>// light name pointers                       ( nlight x 1 ) int*      name_flexadr ;<C_BINDER_MOJO_NEWLINE>// flex name pointers                        ( nflex x 1 ) int*      name_meshadr ;<C_BINDER_MOJO_NEWLINE>// mesh name pointers                        ( nmesh x 1 ) int*      name_skinadr ;<C_BINDER_MOJO_NEWLINE>// skin name pointers                        ( nskin x 1 ) int*      name_hfieldadr ;<C_BINDER_MOJO_NEWLINE>// hfield name pointers                      ( nhfield x 1 ) int*      name_texadr ;<C_BINDER_MOJO_NEWLINE>// texture name pointers                     ( ntex x 1 ) int*      name_matadr ;<C_BINDER_MOJO_NEWLINE>// material name pointers                    ( nmat x 1 ) int*      name_pairadr ;<C_BINDER_MOJO_NEWLINE>// geom pair name pointers                   ( npair x 1 ) int*      name_excludeadr ;<C_BINDER_MOJO_NEWLINE>// exclude name pointers                     ( nexclude x 1 ) int*      name_eqadr ;<C_BINDER_MOJO_NEWLINE>// equality constraint name pointers         ( neq x 1 ) int*      name_tendonadr ;<C_BINDER_MOJO_NEWLINE>// tendon name pointers                      ( ntendon x 1 ) int*      name_actuatoradr ;<C_BINDER_MOJO_NEWLINE>// actuator name pointers                    ( nu x 1 ) int*      name_sensoradr ;<C_BINDER_MOJO_NEWLINE>// sensor name pointers                      ( nsensor x 1 ) int*      name_numericadr ;<C_BINDER_MOJO_NEWLINE>// numeric name pointers                     ( nnumeric x 1 ) int*      name_textadr ;<C_BINDER_MOJO_NEWLINE>// text name pointers                        ( ntext x 1 ) int*      name_tupleadr ;<C_BINDER_MOJO_NEWLINE>// tuple name pointers                       ( ntuple x 1 ) int*      name_keyadr ;<C_BINDER_MOJO_NEWLINE>// keyframe name pointers                    ( nkey x 1 ) int*      name_pluginadr ;<C_BINDER_MOJO_NEWLINE>// plugin instance name pointers             ( nplugin x 1 ) char*     names ;<C_BINDER_MOJO_NEWLINE>// names of all objects ,  0-terminated        ( nnames x 1 ) int*      names_map ;<C_BINDER_MOJO_NEWLINE>// internal hash map of names                ( nnames_map x 1 ) // pathschar*     paths ;<C_BINDER_MOJO_NEWLINE>// paths to assets ,  0-terminated             ( npaths x 1 ) <C_BINDER_MOJO_NEWLINE>}; <C_BINDER_MOJO_NEWLINE>typedefstruct mjModel_mjModel<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>#endif// MUJOCO_MJMODEL_H_<C_BINDER_MOJO_NEWLINE> <C_BINDER_MOJO_NEWLINE>