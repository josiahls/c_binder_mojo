// Copyright 2021 DeepMind Technologies Limited 
// 
// Licensed under the Apache License ,  Version 2.0  ( the "License" )  ;  
// you may not use this file except in compliance with the License. 
// You may obtain a copy of the License at 
// 
//     http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing ,  software 
// distributed under the License is distributed on an "AS IS" BASIS ,  
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND ,  either express or implied. 
// See the License for the specific language governing permissions and 
// limitations under the License. 
 
#ifndef MUJOCO_MJMODEL_H_ 
	#define MUJOCO_MJMODEL_H_ 
	 
	#include <stddef.h> 
	#include <stdint.h> 
	 
	 
	#include <mujoco/mjtnum.h> 
	 
	// global constants 
	#define mjPI 
		           3.14159265358979323846 
	#define mjMAXVAL 
		       1E+10     // maximum value in qpos ,  qvel ,  qacc 
	#define mjMINMU 
		        1E-5      // minimum friction coefficient 
	#define mjMINIMP 
		       0.0001    // minimum constraint impedance 
	#define mjMAXIMP 
		       0.9999    // maximum constraint impedance 
	#define mjMAXCONPAIR 
		   50        // maximum number of contacts per geom pair 
	#define mjMAXTREEDEPTH 
		 50        // maximum bounding volume hierarchy depth 
	 
	 
	//---------------------------------- sizes --------------------------------------------------------- 
	 
	#define mjNEQDATA 
		      11        // number of eq_data fields 
	#define mjNDYN 
		         10        // number of actuator dynamics parameters 
	#define mjNGAIN 
		        10        // number of actuator gain parameters 
	#define mjNBIAS 
		        10        // number of actuator bias parameters 
	#define mjNFLUID 
		       12        // number of fluid interaction parameters 
	#define mjNREF 
		         2         // number of solver reference parameters 
	#define mjNIMP 
		         5         // number of solver impedance parameters 
	#define mjNSOLVER 
		      200       // size of one mjData.solver array 
	#define mjNISLAND 
		      20        // number of mjData.solver arrays 
	 
	//---------------------------------- enum types  ( mjt )  ---------------------------------------------- 
	 
	typedef 	
	enum mjtDisableBit_  	
	{ 	
		     
		// disable default feature bitflags 
		  
		mjDSBL_CONSTRAINT   = 1<<0 , 
		     
		// entire constraint solver 
		  
		mjDSBL_EQUALITY     = 1<<1 , 
		     
		// equality constraints 
		  
		mjDSBL_FRICTIONLOSS = 1<<2 , 
		     
		// joint and tendon frictionloss constraints 
		  
		mjDSBL_LIMIT        = 1<<3 , 
		     
		// joint and tendon limit constraints 
		  
		mjDSBL_CONTACT      = 1<<4 , 
		     
		// contact constraints 
		  
		mjDSBL_PASSIVE      = 1<<5 , 
		     
		// passive forces 
		  
		mjDSBL_GRAVITY      = 1<<6 , 
		     
		// gravitational forces 
		  
		mjDSBL_CLAMPCTRL    = 1<<7 , 
		     
		// clamp control to specified range 
		  
		mjDSBL_WARMSTART    = 1<<8 , 
		     
		// warmstart constraint solver 
		  
		mjDSBL_FILTERPARENT = 1<<9 , 
		     
		// remove collisions with parent body 
		  
		mjDSBL_ACTUATION    = 1<<10 , 
		    
		// apply actuation forces 
		  
		mjDSBL_REFSAFE      = 1<<11 , 
		    
		// integrator safety: make ref[0]>=2*timestep 
		  
		mjDSBL_SENSOR       = 1<<12 , 
		    
		// sensors 
		  
		mjDSBL_MIDPHASE     = 1<<13 , 
		    
		// mid-phase collision filtering 
		  
		mjDSBL_EULERDAMP    = 1<<14 , 
		    
		// implicit integration of joint damping in Euler integrator 
		  
		mjDSBL_AUTORESET    = 1<<15 , 
		    
		// automatic reset when numerical issues are detected 
		 
		  
		mjNDISABLE          = 16        // number of disable flags 
		 
	} 
	 
	mjtDisableBit 
	 
	 
	 
	typedef 	
	enum mjtEnableBit_  	
	{ 	
		      
		// enable optional feature bitflags 
		  
		mjENBL_OVERRIDE     = 1<<0 , 
		     
		// override contact parameters 
		  
		mjENBL_ENERGY       = 1<<1 , 
		     
		// energy computation 
		  
		mjENBL_FWDINV       = 1<<2 , 
		     
		// record solver statistics 
		  
		mjENBL_INVDISCRETE  = 1<<3 , 
		     
		// discrete-time inverse dynamics 
		                                  
		// experimental features: 
		  
		mjENBL_MULTICCD     = 1<<4 , 
		     
		// multi-point convex collision detection 
		  
		mjENBL_ISLAND       = 1<<5 , 
		     
		// constraint island discovery 
		  
		mjENBL_NATIVECCD    = 1<<6 , 
		     
		// native convex collision detection 
		 
		  
		mjNENABLE           = 7         // number of enable flags 
		 
	} 
	 
	mjtEnableBit 
	 
	 
	 
	typedef 	
	enum mjtJoint_  	
	{ 	
		          
		// type of degree of freedom 
		  
		mjJNT_FREE          = 0 , 
		        
		// global position and orientation  ( quat )         ( 7 )  
		  
		mjJNT_BALL , 
		                     
		// orientation  ( quat )  relative to parent         ( 4 )  
		  
		mjJNT_SLIDE , 
		                    
		// sliding distance along body-fixed axis        ( 1 )  
		  
		mjJNT_HINGE                     
		// rotation angle  ( rad )  around body-fixed axis   ( 1 )  
		 
	} 
	 
	mjtJoint 
	 
	 
	 
	typedef 	
	enum mjtGeom_  	
	{ 	
		           
		// type of geometric shape 
		  
		// regular geom types 
		  
		mjGEOM_PLANE        = 0 , 
		        
		// plane 
		  
		mjGEOM_HFIELD , 
		                  
		// height field 
		  
		mjGEOM_SPHERE , 
		                  
		// sphere 
		  
		mjGEOM_CAPSULE , 
		                 
		// capsule 
		  
		mjGEOM_ELLIPSOID , 
		               
		// ellipsoid 
		  
		mjGEOM_CYLINDER , 
		                
		// cylinder 
		  
		mjGEOM_BOX , 
		                     
		// box 
		  
		mjGEOM_MESH , 
		                    
		// mesh 
		  
		mjGEOM_SDF , 
		                     
		// signed distance field 
		 
		  
		mjNGEOMTYPES , 
		                   
		// number of regular geom types 
		 
		  
		// rendering-only geom types: not used in mjModel ,  not counted in mjNGEOMTYPES 
		  
		mjGEOM_ARROW        = 100 , 
		      
		// arrow 
		  
		mjGEOM_ARROW1 , 
		                  
		// arrow without wedges 
		  
		mjGEOM_ARROW2 , 
		                  
		// arrow in both directions 
		  
		mjGEOM_LINE , 
		                    
		// line 
		  
		mjGEOM_LINEBOX , 
		                 
		// box with line edges 
		  
		mjGEOM_FLEX , 
		                    
		// flex 
		  
		mjGEOM_SKIN , 
		                    
		// skin 
		  
		mjGEOM_LABEL , 
		                   
		// text label 
		  
		mjGEOM_TRIANGLE , 
		                
		// triangle 
		 
		  
		mjGEOM_NONE         = 1001      // missing geom type 
		 
	} 
	 
	mjtGeom 
	 
	 
	 
	typedef 	
	enum mjtCamLight_  	
	{ 	
		       
		// tracking mode for camera and light 
		  
		mjCAMLIGHT_FIXED    = 0 , 
		        
		// pos and rot fixed in body 
		  
		mjCAMLIGHT_TRACK , 
		               
		// pos tracks body ,  rot fixed in global 
		  
		mjCAMLIGHT_TRACKCOM , 
		            
		// pos tracks subtree com ,  rot fixed in body 
		  
		mjCAMLIGHT_TARGETBODY , 
		          
		// pos fixed in body ,  rot tracks target body 
		  
		mjCAMLIGHT_TARGETBODYCOM        
		// pos fixed in body ,  rot tracks target subtree com 
		 
	} 
	 
	mjtCamLight 
	 
	 
	 
	typedef 	
	enum mjtTexture_  	
	{ 	
		        
		// type of texture 
		  
		mjTEXTURE_2D        = 0 , 
		        
		// 2d texture ,  suitable for planes and hfields 
		  
		mjTEXTURE_CUBE , 
		                 
		// cube texture ,  suitable for all other geom types 
		  
		mjTEXTURE_SKYBOX                
		// cube texture used as skybox 
		 
	} 
	 
	mjtTexture 
	 
	 
	 
	typedef 	
	enum mjtTextureRole_  	
	{ 	
		    
		// role of texture map in rendering 
		  
		mjTEXROLE_USER      = 0 , 
		        
		// unspecified 
		  
		mjTEXROLE_RGB , 
		                  
		// base color  ( albedo )  
		  
		mjTEXROLE_OCCLUSION , 
		            
		// ambient occlusion 
		  
		mjTEXROLE_ROUGHNESS , 
		            
		// roughness 
		  
		mjTEXROLE_METALLIC , 
		             
		// metallic 
		  
		mjTEXROLE_NORMAL , 
		               
		// normal  ( bump )  map 
		  
		mjTEXROLE_OPACITY , 
		              
		// transperancy 
		  
		mjTEXROLE_EMISSIVE , 
		             
		// light emission 
		  
		mjTEXROLE_RGBA , 
		                 
		// base color ,  opacity 
		  
		mjTEXROLE_ORM , 
		                  
		// occlusion ,  roughness ,  metallic 
		  
		mjNTEXROLE 
		 
	} 
	 
	mjtTextureRole 
	 
	 
	 
	typedef 	
	enum mjtIntegrator_  	
	{ 	
		     
		// integrator mode 
		  
		mjINT_EULER         = 0 , 
		        
		// semi-implicit Euler 
		  
		mjINT_RK4 , 
		                      
		// 4th-order Runge Kutta 
		  
		mjINT_IMPLICIT , 
		                 
		// implicit in velocity 
		  
		mjINT_IMPLICITFAST              
		// implicit in velocity ,  no rne derivative 
		 
	} 
	 
	mjtIntegrator 
	 
	 
	 
	typedef 	
	enum mjtCone_  	
	{ 	
		           
		// type of friction cone 
		  
		mjCONE_PYRAMIDAL     = 0 , 
		       
		// pyramidal 
		  
		mjCONE_ELLIPTIC                 
		// elliptic 
		 
	} 
	 
	mjtCone 
	 
	 
	 
	typedef 	
	enum mjtJacobian_  	
	{ 	
		       
		// type of constraint Jacobian 
		  
		mjJAC_DENSE          = 0 , 
		       
		// dense 
		  
		mjJAC_SPARSE , 
		                   
		// sparse 
		  
		mjJAC_AUTO                      
		// dense if nv<60 ,  sparse otherwise 
		 
	} 
	 
	mjtJacobian 
	 
	 
	 
	typedef 	
	enum mjtSolver_  	
	{ 	
		         
		// constraint solver algorithm 
		  
		mjSOL_PGS            = 0 , 
		       
		// PGS     ( dual )  
		  
		mjSOL_CG , 
		                       
		// CG      ( primal )  
		  
		mjSOL_NEWTON                    
		// Newton  ( primal )  
		 
	} 
	 
	mjtSolver 
	 
	 
	 
	typedef 	
	enum mjtEq_  	
	{ 	
		             
		// type of equality constraint 
		  
		mjEQ_CONNECT        = 0 , 
		        
		// connect two bodies at a point  ( ball joint )  
		  
		mjEQ_WELD , 
		                      
		// fix relative position and orientation of two bodies 
		  
		mjEQ_JOINT , 
		                     
		// couple the values of two scalar joints with cubic 
		  
		mjEQ_TENDON , 
		                    
		// couple the lengths of two tendons with cubic 
		  
		mjEQ_FLEX , 
		                      
		// fix all edge lengths of a flex 
		  
		mjEQ_DISTANCE                   
		// unsupported ,  will cause an error if used 
		 
	} 
	 
	mjtEq 
	 
	 
	 
	typedef 	
	enum mjtWrap_  	
	{ 	
		           
		// type of tendon wrap object 
		  
		mjWRAP_NONE         = 0 , 
		        
		// null object 
		  
		mjWRAP_JOINT , 
		                   
		// constant moment arm 
		  
		mjWRAP_PULLEY , 
		                  
		// pulley used to split tendon 
		  
		mjWRAP_SITE , 
		                    
		// pass through site 
		  
		mjWRAP_SPHERE , 
		                  
		// wrap around sphere 
		  
		mjWRAP_CYLINDER                 
		// wrap around  ( infinite )  cylinder 
		 
	} 
	 
	mjtWrap 
	 
	 
	 
	typedef 	
	enum mjtTrn_  	
	{ 	
		            
		// type of actuator transmission 
		  
		mjTRN_JOINT         = 0 , 
		        
		// force on joint 
		  
		mjTRN_JOINTINPARENT , 
		            
		// force on joint ,  expressed in parent frame 
		  
		mjTRN_SLIDERCRANK , 
		              
		// force via slider-crank linkage 
		  
		mjTRN_TENDON , 
		                   
		// force on tendon 
		  
		mjTRN_SITE , 
		                     
		// force on site 
		  
		mjTRN_BODY , 
		                     
		// adhesion force on a body's geoms 
		 
		  
		mjTRN_UNDEFINED     = 1000      // undefined transmission type 
		 
	} 
	 
	mjtTrn 
	 
	 
	 
	typedef 	
	enum mjtDyn_  	
	{ 	
		            
		// type of actuator dynamics 
		  
		mjDYN_NONE          = 0 , 
		        
		// no internal dynamics ;  ctrl specifies force 
		  
		mjDYN_INTEGRATOR , 
		               
		// integrator: da/dt = u 
		  
		mjDYN_FILTER , 
		                   
		// linear filter: da/dt =  ( u-a )  / tau 
		  
		mjDYN_FILTEREXACT , 
		              
		// linear filter: da/dt =  ( u-a )  / tau ,  with exact integration 
		  
		mjDYN_MUSCLE , 
		                   
		// piece-wise linear filter with two time constants 
		  
		mjDYN_USER                      
		// user-defined dynamics type 
		 
	} 
	 
	mjtDyn 
	 
	 
	 
	typedef 	
	enum mjtGain_  	
	{ 	
		           
		// type of actuator gain 
		  
		mjGAIN_FIXED        = 0 , 
		        
		// fixed gain 
		  
		mjGAIN_AFFINE , 
		                  
		// const + kp*length + kv*velocity 
		  
		mjGAIN_MUSCLE , 
		                  
		// muscle FLV curve computed by mju_muscleGain (  )  
		  
		mjGAIN_USER                     
		// user-defined gain type 
		 
	} 
	 
	mjtGain 
	 
	 
	 
	typedef 	
	enum mjtBias_  	
	{ 	
		           
		// type of actuator bias 
		  
		mjBIAS_NONE         = 0 , 
		        
		// no bias 
		  
		mjBIAS_AFFINE , 
		                  
		// const + kp*length + kv*velocity 
		  
		mjBIAS_MUSCLE , 
		                  
		// muscle passive force computed by mju_muscleBias (  )  
		  
		mjBIAS_USER                     
		// user-defined bias type 
		 
	} 
	 
	mjtBias 
	 
	 
	 
	typedef 	
	enum mjtObj_  	
	{ 	
		            
		// type of MujoCo object 
		  
		mjOBJ_UNKNOWN       = 0 , 
		        
		// unknown object type 
		  
		mjOBJ_BODY , 
		                     
		// body 
		  
		mjOBJ_XBODY , 
		                    
		// body ,  used to access regular frame instead of i-frame 
		  
		mjOBJ_JOINT , 
		                    
		// joint 
		  
		mjOBJ_DOF , 
		                      
		// dof 
		  
		mjOBJ_GEOM , 
		                     
		// geom 
		  
		mjOBJ_SITE , 
		                     
		// site 
		  
		mjOBJ_CAMERA , 
		                   
		// camera 
		  
		mjOBJ_LIGHT , 
		                    
		// light 
		  
		mjOBJ_FLEX , 
		                     
		// flex 
		  
		mjOBJ_MESH , 
		                     
		// mesh 
		  
		mjOBJ_SKIN , 
		                     
		// skin 
		  
		mjOBJ_HFIELD , 
		                   
		// heightfield 
		  
		mjOBJ_TEXTURE , 
		                  
		// texture 
		  
		mjOBJ_MATERIAL , 
		                 
		// material for rendering 
		  
		mjOBJ_PAIR , 
		                     
		// geom pair to include 
		  
		mjOBJ_EXCLUDE , 
		                  
		// body pair to exclude 
		  
		mjOBJ_EQUALITY , 
		                 
		// equality constraint 
		  
		mjOBJ_TENDON , 
		                   
		// tendon 
		  
		mjOBJ_ACTUATOR , 
		                 
		// actuator 
		  
		mjOBJ_SENSOR , 
		                   
		// sensor 
		  
		mjOBJ_NUMERIC , 
		                  
		// numeric 
		  
		mjOBJ_TEXT , 
		                     
		// text 
		  
		mjOBJ_TUPLE , 
		                    
		// tuple 
		  
		mjOBJ_KEY , 
		                      
		// keyframe 
		  
		mjOBJ_PLUGIN , 
		                   
		// plugin instance 
		 
		  
		mjNOBJECT , 
		                      
		// number of object types 
		 
		  
		// meta elements ,  do not appear in mjModel 
		  
		mjOBJ_FRAME         = 100       // frame 
		 
	} 
	 
	mjtObj 
	 
	 
	 
	typedef 	
	enum mjtConstraint_  	
	{ 	
		     
		// type of constraint 
		  
		mjCNSTR_EQUALITY    = 0 , 
		        
		// equality constraint 
		  
		mjCNSTR_FRICTION_DOF , 
		           
		// dof friction 
		  
		mjCNSTR_FRICTION_TENDON , 
		        
		// tendon friction 
		  
		mjCNSTR_LIMIT_JOINT , 
		            
		// joint limit 
		  
		mjCNSTR_LIMIT_TENDON , 
		           
		// tendon limit 
		  
		mjCNSTR_CONTACT_FRICTIONLESS , 
		   
		// frictionless contact 
		  
		mjCNSTR_CONTACT_PYRAMIDAL , 
		      
		// frictional contact ,  pyramidal friction cone 
		  
		mjCNSTR_CONTACT_ELLIPTIC        
		// frictional contact ,  elliptic friction cone 
		 
	} 
	 
	mjtConstraint 
	 
	 
	 
	typedef 	
	enum mjtConstraintState_  	
	{ 	
		  
		// constraint state 
		  
		mjCNSTRSTATE_SATISFIED = 0 , 
		       
		// constraint satisfied ,  zero cost  ( limit ,  contact )  
		  
		mjCNSTRSTATE_QUADRATIC , 
		           
		// quadratic cost  ( equality ,  friction ,  limit ,  contact )  
		  
		mjCNSTRSTATE_LINEARNEG , 
		           
		// linear cost ,  negative side  ( friction )  
		  
		mjCNSTRSTATE_LINEARPOS , 
		           
		// linear cost ,  positive side  ( friction )  
		  
		mjCNSTRSTATE_CONE                 
		// squared distance to cone cost  ( elliptic contact )  
		 
	} 
	 
	mjtConstraintState 
	 
	 
	 
	typedef 	
	enum mjtSensor_  	
	{ 	
		         
		// type of sensor 
		  
		// common robotic sensors ,  attached to a site 
		  
		mjSENS_TOUCH        = 0 , 
		        
		// scalar contact normal forces summed over sensor zone 
		  
		mjSENS_ACCELEROMETER , 
		           
		// 3D linear acceleration ,  in local frame 
		  
		mjSENS_VELOCIMETER , 
		             
		// 3D linear velocity ,  in local frame 
		  
		mjSENS_GYRO , 
		                    
		// 3D angular velocity ,  in local frame 
		  
		mjSENS_FORCE , 
		                   
		// 3D force between site's body and its parent body 
		  
		mjSENS_TORQUE , 
		                  
		// 3D torque between site's body and its parent body 
		  
		mjSENS_MAGNETOMETER , 
		            
		// 3D magnetometer 
		  
		mjSENS_RANGEFINDER , 
		             
		// scalar distance to nearest geom or site along z-axis 
		  
		mjSENS_CAMPROJECTION , 
		           
		// pixel coordinates of a site in the camera image 
		 
		  
		// sensors related to scalar joints ,  tendons ,  actuators 
		  
		mjSENS_JOINTPOS , 
		                
		// scalar joint position  ( hinge and slide only )  
		  
		mjSENS_JOINTVEL , 
		                
		// scalar joint velocity  ( hinge and slide only )  
		  
		mjSENS_TENDONPOS , 
		               
		// scalar tendon position 
		  
		mjSENS_TENDONVEL , 
		               
		// scalar tendon velocity 
		  
		mjSENS_ACTUATORPOS , 
		             
		// scalar actuator position 
		  
		mjSENS_ACTUATORVEL , 
		             
		// scalar actuator velocity 
		  
		mjSENS_ACTUATORFRC , 
		             
		// scalar actuator force 
		  
		mjSENS_JOINTACTFRC , 
		             
		// scalar actuator force ,  measured at the joint 
		 
		  
		// sensors related to ball joints 
		  
		mjSENS_BALLQUAT , 
		                
		// 4D ball joint quaternion 
		  
		mjSENS_BALLANGVEL , 
		              
		// 3D ball joint angular velocity 
		 
		  
		// joint and tendon limit sensors ,  in constraint space 
		  
		mjSENS_JOINTLIMITPOS , 
		           
		// joint limit distance-margin 
		  
		mjSENS_JOINTLIMITVEL , 
		           
		// joint limit velocity 
		  
		mjSENS_JOINTLIMITFRC , 
		           
		// joint limit force 
		  
		mjSENS_TENDONLIMITPOS , 
		          
		// tendon limit distance-margin 
		  
		mjSENS_TENDONLIMITVEL , 
		          
		// tendon limit velocity 
		  
		mjSENS_TENDONLIMITFRC , 
		          
		// tendon limit force 
		 
		  
		// sensors attached to an object with spatial frame:  ( x ) body ,  geom ,  site ,  camera 
		  
		mjSENS_FRAMEPOS , 
		                
		// 3D position 
		  
		mjSENS_FRAMEQUAT , 
		               
		// 4D unit quaternion orientation 
		  
		mjSENS_FRAMEXAXIS , 
		              
		// 3D unit vector: x-axis of object's frame 
		  
		mjSENS_FRAMEYAXIS , 
		              
		// 3D unit vector: y-axis of object's frame 
		  
		mjSENS_FRAMEZAXIS , 
		              
		// 3D unit vector: z-axis of object's frame 
		  
		mjSENS_FRAMELINVEL , 
		             
		// 3D linear velocity 
		  
		mjSENS_FRAMEANGVEL , 
		             
		// 3D angular velocity 
		  
		mjSENS_FRAMELINACC , 
		             
		// 3D linear acceleration 
		  
		mjSENS_FRAMEANGACC , 
		             
		// 3D angular acceleration 
		 
		  
		// sensors related to kinematic subtrees ;  attached to a body  ( which is the subtree root )  
		  
		mjSENS_SUBTREECOM , 
		              
		// 3D center of mass of subtree 
		  
		mjSENS_SUBTREELINVEL , 
		           
		// 3D linear velocity of subtree 
		  
		mjSENS_SUBTREEANGMOM , 
		           
		// 3D angular momentum of subtree 
		 
		  
		// sensors for geometric distance ;  attached to geoms or bodies 
		  
		mjSENS_GEOMDIST , 
		                
		// signed distance between two geoms 
		  
		mjSENS_GEOMNORMAL , 
		              
		// normal direction between two geoms 
		  
		mjSENS_GEOMFROMTO , 
		              
		// segment between two geoms 
		 
		  
		// global sensors 
		  
		mjSENS_CLOCK , 
		                   
		// simulation time 
		 
		  
		// plugin-controlled sensors 
		  
		mjSENS_PLUGIN , 
		                  
		// plugin-controlled 
		 
		  
		// user-defined sensor 
		  
		mjSENS_USER                     
		// sensor data provided by mjcb_sensor callback 
		 
	} 
	 
	mjtSensor 
	 
	 
	 
	typedef 	
	enum mjtStage_  	
	{ 	
		          
		// computation stage 
		  
		mjSTAGE_NONE        = 0 , 
		        
		// no computations 
		  
		mjSTAGE_POS , 
		                    
		// position-dependent computations 
		  
		mjSTAGE_VEL , 
		                    
		// velocity-dependent computations 
		  
		mjSTAGE_ACC                     
		// acceleration/force-dependent computations 
		 
	} 
	 
	mjtStage 
	 
	 
	 
	typedef 	
	enum mjtDataType_  	
	{ 	
		       
		// data type for sensors 
		  
		mjDATATYPE_REAL     = 0 , 
		        
		// real values ,  no constraints 
		  
		mjDATATYPE_POSITIVE , 
		            
		// positive values ;  0 or negative: inactive 
		  
		mjDATATYPE_AXIS , 
		                
		// 3D unit vector 
		  
		mjDATATYPE_QUATERNION           
		// unit quaternion 
		 
	} 
	 
	mjtDataType 
	 
	 
	 
	typedef 	
	enum mjtSameFrame_  	
	{ 	
		      
		// frame alignment of bodies with their children 
		  
		mjSAMEFRAME_NONE    = 0 , 
		        
		// no alignment 
		  
		mjSAMEFRAME_BODY , 
		               
		// frame is same as body frame 
		  
		mjSAMEFRAME_INERTIA , 
		            
		// frame is same as inertial frame 
		  
		mjSAMEFRAME_BODYROT , 
		            
		// frame orientation is same as body orientation 
		  
		mjSAMEFRAME_INERTIAROT          
		// frame orientation is same as inertia orientation 
		 
	} 
	 
	mjtSameFrame 
	 
	 
	 
	typedef 	
	enum mjtLRMode_  	
	{ 	
		         
		// mode for actuator length range computation 
		  
		mjLRMODE_NONE   = 0 , 
		            
		// do not process any actuators 
		  
		mjLRMODE_MUSCLE , 
		                
		// process muscle actuators 
		  
		mjLRMODE_MUSCLEUSER , 
		            
		// process muscle and user actuators 
		  
		mjLRMODE_ALL                    
		// process all actuators 
		 
	} 
	 
	mjtLRMode 
	 
	 
	 
	typedef 	
	enum mjtFlexSelf_  	
	{ 	
		       
		// mode for flex selfcollide 
		  
		mjFLEXSELF_NONE   = 0 , 
		          
		// no self-collisions 
		  
		mjFLEXSELF_NARROW , 
		              
		// skip midphase ,  go directly to narrowphase 
		  
		mjFLEXSELF_BVH , 
		                 
		// use BVH in midphase  ( if midphase enabled )  
		  
		mjFLEXSELF_SAP , 
		                 
		// use SAP in midphase 
		  
		mjFLEXSELF_AUTO                 
		// choose between BVH and SAP automatically 
		 
	} 
	 
	mjtFlexSelf 
	 
	 
	 
	//---------------------------------- mjLROpt ------------------------------------------------------- 
	 
	struct mjLROpt_  	
	{ 	
		                 
		// options for mj_setLengthRange (  )  
		  
		// flags 
		  
		int mode ; 
		                       
		// which actuators to process  ( mjtLRMode )  
		  
		int useexisting ; 
		                
		// use existing length range if available 
		  
		int uselimit ; 
		                   
		// use joint and tendon limits if available 
		 
		  
		// algorithm parameters 
		  
		mjtNum accel ; 
		                   
		// target acceleration used to compute force 
		  
		mjtNum maxforce ; 
		                
		// maximum force ;  0: no limit 
		  
		mjtNum timeconst ; 
		               
		// time constant for velocity reduction ;  min 0.01 
		  
		mjtNum timestep ; 
		                
		// simulation timestep ;  0: use mjOption.timestep 
		  
		mjtNum inttotal ; 
		                
		// total simulation time interval 
		  
		mjtNum interval ; 
		                
		// evaluation time interval  ( at the end )  
		  
		mjtNum tolrange ; 
		                
		// convergence tolerance  ( relative to range )  
		 
	} 
	 ;  
	typedef 
	mjVFS --------------------------------------------------------- 
	 
	mjOption ------------------------------------------------------ 
	 
	mjVisual ------------------------------------------------------ 
	 
	mjStatistic --------------------------------------------------- 
	 
	mjModel ------------------------------------------------------- 
	 
	 // MUJOCO_MJMODEL_H_ 
	 	
	struct mjLROpt_ mjLROpt ;  
	 
	 
	struct mjVFS_  	
	{ 	
		                               
		// virtual file system for loading from memory 
		  
		void* impl_ ; 
		                                
		// internal pointer to VFS memory 
		 
	} 
	 ;  
	struct mjVFS_ mjVFS ;  
	 
	struct mjOption_  	
	{ 	
		                
		// physics options 
		  
		// timing parameters 
		  
		mjtNum timestep ; 
		                
		// timestep 
		  
		mjtNum apirate ; 
		                 
		// update rate for remote API  ( Hz )  
		 
		  
		// solver parameters 
		  
		mjtNum impratio ; 
		                
		// ratio of friction-to-normal contact impedance 
		  
		mjtNum tolerance ; 
		               
		// main solver tolerance 
		  
		mjtNum ls_tolerance ; 
		            
		// CG/Newton linesearch tolerance 
		  
		mjtNum noslip_tolerance ; 
		        
		// noslip solver tolerance 
		  
		mjtNum ccd_tolerance ; 
		           
		// convex collision solver tolerance 
		 
		  
		// physical constants 
		  
		mjtNum gravity[3] ; 
		              
		// gravitational acceleration 
		  
		mjtNum wind[3] ; 
		                 
		// wind  ( for lift ,  drag and viscosity )  
		  
		mjtNum magnetic[3] ; 
		             
		// global magnetic flux 
		  
		mjtNum density ; 
		                 
		// density of medium 
		  
		mjtNum viscosity ; 
		               
		// viscosity of medium 
		 
		  
		// override contact solver parameters  ( if enabled )  
		  
		mjtNum o_margin ; 
		                
		// margin 
		  
		mjtNum o_solref[mjNREF] ; 
		        
		// solref 
		  
		mjtNum o_solimp[mjNIMP] ; 
		        
		// solimp 
		  
		mjtNum o_friction[5] ; 
		           
		// friction 
		 
		  
		// discrete settings 
		  
		int integrator ; 
		                 
		// integration mode  ( mjtIntegrator )  
		  
		int cone ; 
		                       
		// type of friction cone  ( mjtCone )  
		  
		int jacobian ; 
		                   
		// type of Jacobian  ( mjtJacobian )  
		  
		int solver ; 
		                     
		// solver algorithm  ( mjtSolver )  
		  
		int iterations ; 
		                 
		// maximum number of main solver iterations 
		  
		int ls_iterations ; 
		              
		// maximum number of CG/Newton linesearch iterations 
		  
		int noslip_iterations ; 
		          
		// maximum number of noslip solver iterations 
		  
		int ccd_iterations ; 
		             
		// maximum number of convex collision solver iterations 
		  
		int disableflags ; 
		               
		// bit flags for disabling standard features 
		  
		int enableflags ; 
		                
		// bit flags for enabling optional features 
		  
		int disableactuator ; 
		            
		// bit flags for disabling actuators by group id 
		 
		  
		// sdf collision settings 
		  
		int sdf_initpoints ; 
		             
		// number of starting points for gradient descent 
		  
		int sdf_iterations ; 
		             
		// max number of iterations for gradient descent 
		 
	} 
	 ;  
	struct mjOption_ mjOption ;  
	 
	 
	struct mjVisual_  	
	{ 	
		                
		// visualization options 
		  
		struct  		
		{ 		
			                        
			// global parameters 
			    
			int orthographic ; 
			             
			// is the free camera orthographic  ( 0: no ,  1: yes )  
			    
			float fovy ; 
			                   
			// y field-of-view of free camera  ( orthographic ? length : degree )  
			    
			float ipd ; 
			                    
			// inter-pupilary distance for free camera 
			    
			float azimuth ; 
			                
			// initial azimuth of free camera  ( degrees )  
			    
			float elevation ; 
			              
			// initial elevation of free camera  ( degrees )  
			    
			float linewidth ; 
			              
			// line width for wireframe and ray rendering 
			    
			float glow ; 
			                   
			// glow coefficient for selected body 
			    
			float realtime ; 
			               
			// initial real-time factor  ( 1: real time )  
			    
			int   offwidth ; 
			               
			// width of offscreen buffer 
			    
			int   offheight ; 
			              
			// height of offscreen buffer 
			    
			int   ellipsoidinertia ; 
			       
			// geom for inertia visualization  ( 0: box ,  1: ellipsoid )  
			    
			int   bvactive ; 
			               
			// visualize active bounding volumes  ( 0: no ,  1: yes )  
			   
		} 
		 
		global ; 
		 
		 
		  
		struct  		
		{ 		
			                        
			// rendering quality 
			    
			int   shadowsize ; 
			             
			// size of shadowmap texture 
			    
			int   offsamples ; 
			             
			// number of multisamples for offscreen rendering 
			    
			int   numslices ; 
			              
			// number of slices for builtin geom drawing 
			    
			int   numstacks ; 
			              
			// number of stacks for builtin geom drawing 
			    
			int   numquads ; 
			               
			// number of quads for box rendering 
			   
		} 
		 
		quality ; 
		 
		 
		  
		struct  		
		{ 		
			                        
			// head light 
			    
			float ambient[3] ; 
			             
			// ambient rgb  ( alpha=1 )  
			    
			float diffuse[3] ; 
			             
			// diffuse rgb  ( alpha=1 )  
			    
			float specular[3] ; 
			            
			// specular rgb  ( alpha=1 )  
			    
			int   active ; 
			                 
			// is headlight active 
			   
		} 
		 
		headlight ; 
		 
		 
		  
		struct  		
		{ 		
			                        
			// mapping 
			    
			float stiffness ; 
			              
			// mouse perturbation stiffness  ( space->force )  
			    
			float stiffnessrot ; 
			           
			// mouse perturbation stiffness  ( space->torque )  
			    
			float force ; 
			                  
			// from force units to space units 
			    
			float torque ; 
			                 
			// from torque units to space units 
			    
			float alpha ; 
			                  
			// scale geom alphas when transparency is enabled 
			    
			float fogstart ; 
			               
			// OpenGL fog starts at fogstart * mjModel.stat.extent 
			    
			float fogend ; 
			                 
			// OpenGL fog ends at fogend * mjModel.stat.extent 
			    
			float znear ; 
			                  
			// near clipping plane = znear * mjModel.stat.extent 
			    
			float zfar ; 
			                   
			// far clipping plane = zfar * mjModel.stat.extent 
			    
			float haze ; 
			                   
			// haze ratio 
			    
			float shadowclip ; 
			             
			// directional light: shadowclip * mjModel.stat.extent 
			    
			float shadowscale ; 
			            
			// spot light: shadowscale * light.cutoff 
			    
			float actuatortendon ; 
			         
			// scale tendon width 
			   
		} 
		 
		map ; 
		 
		 
		  
		struct  		
		{ 		
			                        
			// scale of decor elements relative to mean body size 
			    
			float forcewidth ; 
			             
			// width of force arrow 
			    
			float contactwidth ; 
			           
			// contact width 
			    
			float contactheight ; 
			          
			// contact height 
			    
			float connect ; 
			                
			// autoconnect capsule width 
			    
			float com ; 
			                    
			// com radius 
			    
			float camera ; 
			                 
			// camera object 
			    
			float light ; 
			                  
			// light object 
			    
			float selectpoint ; 
			            
			// selection point 
			    
			float jointlength ; 
			            
			// joint length 
			    
			float jointwidth ; 
			             
			// joint width 
			    
			float actuatorlength ; 
			         
			// actuator length 
			    
			float actuatorwidth ; 
			          
			// actuator width 
			    
			float framelength ; 
			            
			// bodyframe axis length 
			    
			float framewidth ; 
			             
			// bodyframe axis width 
			    
			float constraint ; 
			             
			// constraint width 
			    
			float slidercrank ; 
			            
			// slidercrank width 
			    
			float frustum ; 
			                
			// frustum zfar plane 
			   
		} 
		 
		scale ; 
		 
		 
		  
		struct  		
		{ 		
			                        
			// color of decor elements 
			    
			float fog[4] ; 
			                 
			// fog 
			    
			float haze[4] ; 
			                
			// haze 
			    
			float force[4] ; 
			               
			// external force 
			    
			float inertia[4] ; 
			             
			// inertia box 
			    
			float joint[4] ; 
			               
			// joint 
			    
			float actuator[4] ; 
			            
			// actuator ,  neutral 
			    
			float actuatornegative[4] ; 
			    
			// actuator ,  negative limit 
			    
			float actuatorpositive[4] ; 
			    
			// actuator ,  positive limit 
			    
			float com[4] ; 
			                 
			// center of mass 
			    
			float camera[4] ; 
			              
			// camera object 
			    
			float light[4] ; 
			               
			// light object 
			    
			float selectpoint[4] ; 
			         
			// selection point 
			    
			float connect[4] ; 
			             
			// auto connect 
			    
			float contactpoint[4] ; 
			        
			// contact point 
			    
			float contactforce[4] ; 
			        
			// contact force 
			    
			float contactfriction[4] ; 
			     
			// contact friction force 
			    
			float contacttorque[4] ; 
			       
			// contact torque 
			    
			float contactgap[4] ; 
			          
			// contact point in gap 
			    
			float rangefinder[4] ; 
			         
			// rangefinder ray 
			    
			float constraint[4] ; 
			          
			// constraint 
			    
			float slidercrank[4] ; 
			         
			// slidercrank 
			    
			float crankbroken[4] ; 
			         
			// used when crank must be stretched/broken 
			    
			float frustum[4] ; 
			             
			// camera frustum 
			    
			float bv[4] ; 
			                  
			// bounding volume 
			    
			float bvactive[4] ; 
			            
			// active bounding volume 
			   
		} 
		 
		rgba ; 
		 
		 
	} 
	 ;  
	struct mjVisual_ mjVisual ;  
	 
	 
	struct mjStatistic_  	
	{ 	
		             
		// model statistics  ( in qpos0 )  
		  
		mjtNum meaninertia ; 
		             
		// mean diagonal inertia 
		  
		mjtNum meanmass ; 
		                
		// mean body mass 
		  
		mjtNum meansize ; 
		                
		// mean body size 
		  
		mjtNum extent ; 
		                  
		// spatial extent 
		  
		mjtNum center[3] ; 
		               
		// center of model 
		 
	} 
	 ;  
	struct mjStatistic_ mjStatistic ;  
	 
	 
	struct mjModel_  	
	{ 	
		 
		  
		// ------------------------------- sizes 
		 
		  
		// sizes needed at mjModel construction 
		  
		int nq ; 
		                         
		// number of generalized coordinates = dim ( qpos )  
		 
		 
		 
		 
		 
	} 
	 ;  
	struct mjModel_ mjModel ;  
	 
	//---------------------------------- 
	typedef 
	//---------------------------------- 
	typedef 
	//---------------------------------- 
	typedef 
	//---------------------------------- 
	typedef 
	//---------------------------------- 
	typedef 
	#endif 