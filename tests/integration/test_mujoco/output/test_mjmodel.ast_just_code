	// Copyright 2021 DeepMind Technologies Limited	<C_BINDER_MOJO_NEWLINE>		//	<C_BINDER_MOJO_NEWLINE>		// Licensed under the Apache License ,  Version 2.0  ( the "License" )  ; 	<C_BINDER_MOJO_NEWLINE>		// you may not use this file except in compliance with the License.	<C_BINDER_MOJO_NEWLINE>		// You may obtain a copy of the License at	<C_BINDER_MOJO_NEWLINE>		//	<C_BINDER_MOJO_NEWLINE>		//     http://www.apache.org/licenses/LICENSE-2.0	<C_BINDER_MOJO_NEWLINE>		//	<C_BINDER_MOJO_NEWLINE>		// Unless required by applicable law or agreed to in writing ,  software	<C_BINDER_MOJO_NEWLINE>		// distributed under the License is distributed on an "AS IS" BASIS , 	<C_BINDER_MOJO_NEWLINE>		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND ,  either express or implied.	<C_BINDER_MOJO_NEWLINE>		// See the License for the specific language governing permissions and	<C_BINDER_MOJO_NEWLINE>		// limitations under the License.	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		#ifndef MUJOCO_MJMODEL_H_	<C_BINDER_MOJO_NEWLINE>		#define MUJOCO_MJMODEL_H_	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		#include <stddef.h>	<C_BINDER_MOJO_NEWLINE>		#include <stdint.h>	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		#include <mujoco/mjtnum.h>	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		// global constants	<C_BINDER_MOJO_NEWLINE>		#define mjPI		3.14159265358979323846 <C_BINDER_MOJO_NEWLINE>		#define mjMAXVAL		1E+10     // maximum value in qpos ,  qvel ,  qacc <C_BINDER_MOJO_NEWLINE>		#define mjMINMU		1E-5      // minimum friction coefficient <C_BINDER_MOJO_NEWLINE>		#define mjMINIMP		0.0001    // minimum constraint impedance <C_BINDER_MOJO_NEWLINE>		#define mjMAXIMP		0.9999    // maximum constraint impedance <C_BINDER_MOJO_NEWLINE>		#define mjMAXCONPAIR		50        // maximum number of contacts per geom pair <C_BINDER_MOJO_NEWLINE>		#define mjMAXTREEDEPTH		50        // maximum bounding volume hierarchy depth <C_BINDER_MOJO_NEWLINE>		<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		//---------------------------------- sizes ---------------------------------------------------------	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		#define mjNEQDATA		11        // number of eq_data fields <C_BINDER_MOJO_NEWLINE>		#define mjNDYN		10        // number of actuator dynamics parameters <C_BINDER_MOJO_NEWLINE>		#define mjNGAIN		10        // number of actuator gain parameters <C_BINDER_MOJO_NEWLINE>		#define mjNBIAS		10        // number of actuator bias parameters <C_BINDER_MOJO_NEWLINE>		#define mjNFLUID		12        // number of fluid interaction parameters <C_BINDER_MOJO_NEWLINE>		#define mjNREF		2         // number of solver reference parameters <C_BINDER_MOJO_NEWLINE>		#define mjNIMP		5         // number of solver impedance parameters <C_BINDER_MOJO_NEWLINE>		#define mjNSOLVER		200       // size of one mjData.solver array <C_BINDER_MOJO_NEWLINE>		#define mjNISLAND		20        // number of mjData.solver arrays <C_BINDER_MOJO_NEWLINE>		<C_BINDER_MOJO_NEWLINE>		//---------------------------------- enum types  ( mjt )  ----------------------------------------------	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtDisableBit_	{ <C_BINDER_MOJO_NEWLINE>		// disable default feature bitflags	mjDSBL_CONSTRAINT    =  1<<0 ,	// entire constraint solver	mjDSBL_EQUALITY      =  1<<1 ,	// equality constraints	mjDSBL_FRICTIONLOSS  =  1<<2 ,	// joint and tendon frictionloss constraints	mjDSBL_LIMIT         =  1<<3 ,	// joint and tendon limit constraints	mjDSBL_CONTACT       =  1<<4 ,	// contact constraints	mjDSBL_PASSIVE       =  1<<5 ,	// passive forces	mjDSBL_GRAVITY       =  1<<6 ,	// gravitational forces	mjDSBL_CLAMPCTRL     =  1<<7 ,	// clamp control to specified range	mjDSBL_WARMSTART     =  1<<8 ,	// warmstart constraint solver	mjDSBL_FILTERPARENT  =  1<<9 ,	// remove collisions with parent body	mjDSBL_ACTUATION     =  1<<10 ,	// apply actuation forces	mjDSBL_REFSAFE       =  1<<11 ,	// integrator safety: make ref[0]> = 2*timestep	mjDSBL_SENSOR        =  1<<12 ,	// sensors	mjDSBL_MIDPHASE      =  1<<13 ,	// mid-phase collision filtering	mjDSBL_EULERDAMP     =  1<<14 ,	// implicit integration of joint damping in Euler integrator	mjDSBL_AUTORESET     =  1<<15 ,	// automatic reset when numerical issues are detected	mjNDISABLE           =  16       	// number of disable flags<C_BINDER_MOJO_NEWLINE>	}mjtDisableBit	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtEnableBit_	{ <C_BINDER_MOJO_NEWLINE>		// enable optional feature bitflags	mjENBL_OVERRIDE      =  1<<0 ,	// override contact parameters	mjENBL_ENERGY        =  1<<1 ,	// energy computation	mjENBL_FWDINV        =  1<<2 ,	// record solver statistics	mjENBL_INVDISCRETE   =  1<<3 ,	// discrete-time inverse dynamics	// experimental features:	mjENBL_MULTICCD      =  1<<4 ,	// multi-point convex collision detection	mjENBL_ISLAND        =  1<<5 ,	// constraint island discovery	mjENBL_NATIVECCD     =  1<<6 ,	// native convex collision detection	mjNENABLE            =  7        	// number of enable flags<C_BINDER_MOJO_NEWLINE>	}mjtEnableBit	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtJoint_	{ <C_BINDER_MOJO_NEWLINE>		// type of degree of freedom	mjJNT_FREE           =  0 ,	// global position and orientation  ( quat )         ( 7 ) 	mjJNT_BALL ,	// orientation  ( quat )  relative to parent         ( 4 ) 	mjJNT_SLIDE ,	// sliding distance along body-fixed axis        ( 1 ) 	mjJNT_HINGE                    	// rotation angle  ( rad )  around body-fixed axis   ( 1 ) <C_BINDER_MOJO_NEWLINE>	}mjtJoint	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtGeom_	{ <C_BINDER_MOJO_NEWLINE>		// type of geometric shape	// regular geom types	mjGEOM_PLANE         =  0 ,	// plane	mjGEOM_HFIELD ,	// height field	mjGEOM_SPHERE ,	// sphere	mjGEOM_CAPSULE ,	// capsule	mjGEOM_ELLIPSOID ,	// ellipsoid	mjGEOM_CYLINDER ,	// cylinder	mjGEOM_BOX ,	// box	mjGEOM_MESH ,	// mesh	mjGEOM_SDF ,	// signed distance field	mjNGEOMTYPES ,	// number of regular geom types	// rendering-only geom types: not used in mjModel ,  not counted in mjNGEOMTYPES	mjGEOM_ARROW         =  100 ,	// arrow	mjGEOM_ARROW1 ,	// arrow without wedges	mjGEOM_ARROW2 ,	// arrow in both directions	mjGEOM_LINE ,	// line	mjGEOM_LINEBOX ,	// box with line edges	mjGEOM_FLEX ,	// flex	mjGEOM_SKIN ,	// skin	mjGEOM_LABEL ,	// text label	mjGEOM_TRIANGLE ,	// triangle	mjGEOM_NONE          =  1001     	// missing geom type<C_BINDER_MOJO_NEWLINE>	}mjtGeom	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtCamLight_	{ <C_BINDER_MOJO_NEWLINE>		// tracking mode for camera and light	mjCAMLIGHT_FIXED     =  0 ,	// pos and rot fixed in body	mjCAMLIGHT_TRACK ,	// pos tracks body ,  rot fixed in global	mjCAMLIGHT_TRACKCOM ,	// pos tracks subtree com ,  rot fixed in body	mjCAMLIGHT_TARGETBODY ,	// pos fixed in body ,  rot tracks target body	mjCAMLIGHT_TARGETBODYCOM       	// pos fixed in body ,  rot tracks target subtree com<C_BINDER_MOJO_NEWLINE>	}mjtCamLight	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtTexture_	{ <C_BINDER_MOJO_NEWLINE>		// type of texture	mjTEXTURE_2D         =  0 ,	// 2d texture ,  suitable for planes and hfields	mjTEXTURE_CUBE ,	// cube texture ,  suitable for all other geom types	mjTEXTURE_SKYBOX               	// cube texture used as skybox<C_BINDER_MOJO_NEWLINE>	}mjtTexture	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtTextureRole_	{ <C_BINDER_MOJO_NEWLINE>		// role of texture map in rendering	mjTEXROLE_USER       =  0 ,	// unspecified	mjTEXROLE_RGB ,	// base color  ( albedo ) 	mjTEXROLE_OCCLUSION ,	// ambient occlusion	mjTEXROLE_ROUGHNESS ,	// roughness	mjTEXROLE_METALLIC ,	// metallic	mjTEXROLE_NORMAL ,	// normal  ( bump )  map	mjTEXROLE_OPACITY ,	// transperancy	mjTEXROLE_EMISSIVE ,	// light emission	mjTEXROLE_RGBA ,	// base color ,  opacity	mjTEXROLE_ORM ,	// occlusion ,  roughness ,  metallic	mjNTEXROLE <C_BINDER_MOJO_NEWLINE>	<C_BINDER_MOJO_NEWLINE>	}mjtTextureRole	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtIntegrator_	{ <C_BINDER_MOJO_NEWLINE>		// integrator mode	mjINT_EULER          =  0 ,	// semi-implicit Euler	mjINT_RK4 ,	// 4th-order Runge Kutta	mjINT_IMPLICIT ,	// implicit in velocity	mjINT_IMPLICITFAST             	// implicit in velocity ,  no rne derivative<C_BINDER_MOJO_NEWLINE>	}mjtIntegrator	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtCone_	{ <C_BINDER_MOJO_NEWLINE>		// type of friction cone	mjCONE_PYRAMIDAL      =  0 ,	// pyramidal	mjCONE_ELLIPTIC                	// elliptic<C_BINDER_MOJO_NEWLINE>	}mjtCone	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtJacobian_	{ <C_BINDER_MOJO_NEWLINE>		// type of constraint Jacobian	mjJAC_DENSE           =  0 ,	// dense	mjJAC_SPARSE ,	// sparse	mjJAC_AUTO                     	// dense if nv<60 ,  sparse otherwise<C_BINDER_MOJO_NEWLINE>	}mjtJacobian	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtSolver_	{ <C_BINDER_MOJO_NEWLINE>		// constraint solver algorithm	mjSOL_PGS             =  0 ,	// PGS     ( dual ) 	mjSOL_CG ,	// CG      ( primal ) 	mjSOL_NEWTON                   	// Newton  ( primal ) <C_BINDER_MOJO_NEWLINE>	}mjtSolver	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtEq_	{ <C_BINDER_MOJO_NEWLINE>		// type of equality constraint	mjEQ_CONNECT         =  0 ,	// connect two bodies at a point  ( ball joint ) 	mjEQ_WELD ,	// fix relative position and orientation of two bodies	mjEQ_JOINT ,	// couple the values of two scalar joints with cubic	mjEQ_TENDON ,	// couple the lengths of two tendons with cubic	mjEQ_FLEX ,	// fix all edge lengths of a flex	mjEQ_DISTANCE                  	// unsupported ,  will cause an error if used<C_BINDER_MOJO_NEWLINE>	}mjtEq	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtWrap_	{ <C_BINDER_MOJO_NEWLINE>		// type of tendon wrap object	mjWRAP_NONE          =  0 ,	// null object	mjWRAP_JOINT ,	// constant moment arm	mjWRAP_PULLEY ,	// pulley used to split tendon	mjWRAP_SITE ,	// pass through site	mjWRAP_SPHERE ,	// wrap around sphere	mjWRAP_CYLINDER                	// wrap around  ( infinite )  cylinder<C_BINDER_MOJO_NEWLINE>	}mjtWrap	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtTrn_	{ <C_BINDER_MOJO_NEWLINE>		// type of actuator transmission	mjTRN_JOINT          =  0 ,	// force on joint	mjTRN_JOINTINPARENT ,	// force on joint ,  expressed in parent frame	mjTRN_SLIDERCRANK ,	// force via slider-crank linkage	mjTRN_TENDON ,	// force on tendon	mjTRN_SITE ,	// force on site	mjTRN_BODY ,	// adhesion force on a body's geoms	mjTRN_UNDEFINED      =  1000     	// undefined transmission type<C_BINDER_MOJO_NEWLINE>	}mjtTrn	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtDyn_	{ <C_BINDER_MOJO_NEWLINE>		// type of actuator dynamics	mjDYN_NONE           =  0 ,	// no internal dynamics ;  ctrl specifies force	mjDYN_INTEGRATOR ,	// integrator: da/dt  =  u	mjDYN_FILTER ,	// linear filter: da/dt  =   ( u-a )  / tau	mjDYN_FILTEREXACT ,	// linear filter: da/dt  =   ( u-a )  / tau ,  with exact integration	mjDYN_MUSCLE ,	// piece-wise linear filter with two time constants	mjDYN_USER                     	// user-defined dynamics type<C_BINDER_MOJO_NEWLINE>	}mjtDyn	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtGain_	{ <C_BINDER_MOJO_NEWLINE>		// type of actuator gain	mjGAIN_FIXED         =  0 ,	// fixed gain	mjGAIN_AFFINE ,	// const + kp*length + kv*velocity	mjGAIN_MUSCLE ,	// muscle FLV curve computed by mju_muscleGain (  ) 	mjGAIN_USER                    	// user-defined gain type<C_BINDER_MOJO_NEWLINE>	}mjtGain	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtBias_	{ <C_BINDER_MOJO_NEWLINE>		// type of actuator bias	mjBIAS_NONE          =  0 ,	// no bias	mjBIAS_AFFINE ,	// const + kp*length + kv*velocity	mjBIAS_MUSCLE ,	// muscle passive force computed by mju_muscleBias (  ) 	mjBIAS_USER                    	// user-defined bias type<C_BINDER_MOJO_NEWLINE>	}mjtBias	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtObj_	{ <C_BINDER_MOJO_NEWLINE>		// type of MujoCo object	mjOBJ_UNKNOWN        =  0 ,	// unknown object type	mjOBJ_BODY ,	// body	mjOBJ_XBODY ,	// body ,  used to access regular frame instead of i-frame	mjOBJ_JOINT ,	// joint	mjOBJ_DOF ,	// dof	mjOBJ_GEOM ,	// geom	mjOBJ_SITE ,	// site	mjOBJ_CAMERA ,	// camera	mjOBJ_LIGHT ,	// light	mjOBJ_FLEX ,	// flex	mjOBJ_MESH ,	// mesh	mjOBJ_SKIN ,	// skin	mjOBJ_HFIELD ,	// heightfield	mjOBJ_TEXTURE ,	// texture	mjOBJ_MATERIAL ,	// material for rendering	mjOBJ_PAIR ,	// geom pair to include	mjOBJ_EXCLUDE ,	// body pair to exclude	mjOBJ_EQUALITY ,	// equality constraint	mjOBJ_TENDON ,	// tendon	mjOBJ_ACTUATOR ,	// actuator	mjOBJ_SENSOR ,	// sensor	mjOBJ_NUMERIC ,	// numeric	mjOBJ_TEXT ,	// text	mjOBJ_TUPLE ,	// tuple	mjOBJ_KEY ,	// keyframe	mjOBJ_PLUGIN ,	// plugin instance	mjNOBJECT ,	// number of object types	// meta elements ,  do not appear in mjModel	mjOBJ_FRAME          =  100      	// frame<C_BINDER_MOJO_NEWLINE>	}mjtObj	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtConstraint_	{ <C_BINDER_MOJO_NEWLINE>		// type of constraint	mjCNSTR_EQUALITY     =  0 ,	// equality constraint	mjCNSTR_FRICTION_DOF ,	// dof friction	mjCNSTR_FRICTION_TENDON ,	// tendon friction	mjCNSTR_LIMIT_JOINT ,	// joint limit	mjCNSTR_LIMIT_TENDON ,	// tendon limit	mjCNSTR_CONTACT_FRICTIONLESS ,	// frictionless contact	mjCNSTR_CONTACT_PYRAMIDAL ,	// frictional contact ,  pyramidal friction cone	mjCNSTR_CONTACT_ELLIPTIC       	// frictional contact ,  elliptic friction cone<C_BINDER_MOJO_NEWLINE>	}mjtConstraint	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtConstraintState_	{ <C_BINDER_MOJO_NEWLINE>		// constraint state	mjCNSTRSTATE_SATISFIED  =  0 ,	// constraint satisfied ,  zero cost  ( limit ,  contact ) 	mjCNSTRSTATE_QUADRATIC ,	// quadratic cost  ( equality ,  friction ,  limit ,  contact ) 	mjCNSTRSTATE_LINEARNEG ,	// linear cost ,  negative side  ( friction ) 	mjCNSTRSTATE_LINEARPOS ,	// linear cost ,  positive side  ( friction ) 	mjCNSTRSTATE_CONE                	// squared distance to cone cost  ( elliptic contact ) <C_BINDER_MOJO_NEWLINE>	}mjtConstraintState	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtSensor_	{ <C_BINDER_MOJO_NEWLINE>		// type of sensor	// common robotic sensors ,  attached to a site	mjSENS_TOUCH         =  0 ,	// scalar contact normal forces summed over sensor zone	mjSENS_ACCELEROMETER ,	// 3D linear acceleration ,  in local frame	mjSENS_VELOCIMETER ,	// 3D linear velocity ,  in local frame	mjSENS_GYRO ,	// 3D angular velocity ,  in local frame	mjSENS_FORCE ,	// 3D force between site's body and its parent body	mjSENS_TORQUE ,	// 3D torque between site's body and its parent body	mjSENS_MAGNETOMETER ,	// 3D magnetometer	mjSENS_RANGEFINDER ,	// scalar distance to nearest geom or site along z-axis	mjSENS_CAMPROJECTION ,	// pixel coordinates of a site in the camera image	// sensors related to scalar joints ,  tendons ,  actuators	mjSENS_JOINTPOS ,	// scalar joint position  ( hinge and slide only ) 	mjSENS_JOINTVEL ,	// scalar joint velocity  ( hinge and slide only ) 	mjSENS_TENDONPOS ,	// scalar tendon position	mjSENS_TENDONVEL ,	// scalar tendon velocity	mjSENS_ACTUATORPOS ,	// scalar actuator position	mjSENS_ACTUATORVEL ,	// scalar actuator velocity	mjSENS_ACTUATORFRC ,	// scalar actuator force	mjSENS_JOINTACTFRC ,	// scalar actuator force ,  measured at the joint	// sensors related to ball joints	mjSENS_BALLQUAT ,	// 4D ball joint quaternion	mjSENS_BALLANGVEL ,	// 3D ball joint angular velocity	// joint and tendon limit sensors ,  in constraint space	mjSENS_JOINTLIMITPOS ,	// joint limit distance-margin	mjSENS_JOINTLIMITVEL ,	// joint limit velocity	mjSENS_JOINTLIMITFRC ,	// joint limit force	mjSENS_TENDONLIMITPOS ,	// tendon limit distance-margin	mjSENS_TENDONLIMITVEL ,	// tendon limit velocity	mjSENS_TENDONLIMITFRC ,	// tendon limit force	// sensors attached to an object with spatial frame:  ( x ) body ,  geom ,  site ,  camera	mjSENS_FRAMEPOS ,	// 3D position	mjSENS_FRAMEQUAT ,	// 4D unit quaternion orientation	mjSENS_FRAMEXAXIS ,	// 3D unit vector: x-axis of object's frame	mjSENS_FRAMEYAXIS ,	// 3D unit vector: y-axis of object's frame	mjSENS_FRAMEZAXIS ,	// 3D unit vector: z-axis of object's frame	mjSENS_FRAMELINVEL ,	// 3D linear velocity	mjSENS_FRAMEANGVEL ,	// 3D angular velocity	mjSENS_FRAMELINACC ,	// 3D linear acceleration	mjSENS_FRAMEANGACC ,	// 3D angular acceleration	// sensors related to kinematic subtrees ;  attached to a body  ( which is the subtree root ) 	mjSENS_SUBTREECOM ,	// 3D center of mass of subtree	mjSENS_SUBTREELINVEL ,	// 3D linear velocity of subtree	mjSENS_SUBTREEANGMOM ,	// 3D angular momentum of subtree	// sensors for geometric distance ;  attached to geoms or bodies	mjSENS_GEOMDIST ,	// signed distance between two geoms	mjSENS_GEOMNORMAL ,	// normal direction between two geoms	mjSENS_GEOMFROMTO ,	// segment between two geoms	// global sensors	mjSENS_CLOCK ,	// simulation time	// plugin-controlled sensors	mjSENS_PLUGIN ,	// plugin-controlled	// user-defined sensor	mjSENS_USER                    	// sensor data provided by mjcb_sensor callback<C_BINDER_MOJO_NEWLINE>	}mjtSensor	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtStage_	{ <C_BINDER_MOJO_NEWLINE>		// computation stage	mjSTAGE_NONE         =  0 ,	// no computations	mjSTAGE_POS ,	// position-dependent computations	mjSTAGE_VEL ,	// velocity-dependent computations	mjSTAGE_ACC                    	// acceleration/force-dependent computations<C_BINDER_MOJO_NEWLINE>	}mjtStage	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtDataType_	{ <C_BINDER_MOJO_NEWLINE>		// data type for sensors	mjDATATYPE_REAL      =  0 ,	// real values ,  no constraints	mjDATATYPE_POSITIVE ,	// positive values ;  0 or negative: inactive	mjDATATYPE_AXIS ,	// 3D unit vector	mjDATATYPE_QUATERNION          	// unit quaternion<C_BINDER_MOJO_NEWLINE>	}mjtDataType	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtSameFrame_	{ <C_BINDER_MOJO_NEWLINE>		// frame alignment of bodies with their children	mjSAMEFRAME_NONE     =  0 ,	// no alignment	mjSAMEFRAME_BODY ,	// frame is same as body frame	mjSAMEFRAME_INERTIA ,	// frame is same as inertial frame	mjSAMEFRAME_BODYROT ,	// frame orientation is same as body orientation	mjSAMEFRAME_INERTIAROT         	// frame orientation is same as inertia orientation<C_BINDER_MOJO_NEWLINE>	}mjtSameFrame	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtLRMode_	{ <C_BINDER_MOJO_NEWLINE>		// mode for actuator length range computation	mjLRMODE_NONE    =  0 ,	// do not process any actuators	mjLRMODE_MUSCLE ,	// process muscle actuators	mjLRMODE_MUSCLEUSER ,	// process muscle and user actuators	mjLRMODE_ALL                   	// process all actuators<C_BINDER_MOJO_NEWLINE>	}mjtLRMode	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		typedef	enum mjtFlexSelf_	{ <C_BINDER_MOJO_NEWLINE>		// mode for flex selfcollide	mjFLEXSELF_NONE    =  0 ,	// no self-collisions	mjFLEXSELF_NARROW ,	// skip midphase ,  go directly to narrowphase	mjFLEXSELF_BVH ,	// use BVH in midphase  ( if midphase enabled ) 	mjFLEXSELF_SAP ,	// use SAP in midphase	mjFLEXSELF_AUTO                	// choose between BVH and SAP automatically<C_BINDER_MOJO_NEWLINE>	}mjtFlexSelf	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		//---------------------------------- mjLROpt -------------------------------------------------------	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		struct mjLROpt_	{ <C_BINDER_MOJO_NEWLINE>		// options for mj_setLengthRange (  ) 	// flags	int mode ;<C_BINDER_MOJO_NEWLINE>		// which actuators to process  ( mjtLRMode ) 	int useexisting ;<C_BINDER_MOJO_NEWLINE>		// use existing length range if available	int uselimit ;<C_BINDER_MOJO_NEWLINE>		// use joint and tendon limits if available	// algorithm parameters	mjtNum accel ;<C_BINDER_MOJO_NEWLINE>		// target acceleration used to compute force	mjtNum maxforce ;<C_BINDER_MOJO_NEWLINE>		// maximum force ;  0: no limit	mjtNum timeconst ;<C_BINDER_MOJO_NEWLINE>		// time constant for velocity reduction ;  min 0.01	mjtNum timestep ;<C_BINDER_MOJO_NEWLINE>		// simulation timestep ;  0: use mjOption.timestep	mjtNum inttotal ;<C_BINDER_MOJO_NEWLINE>		// total simulation time interval	mjtNum interval ;<C_BINDER_MOJO_NEWLINE>		// evaluation time interval  ( at the end ) 	mjtNum tolrange ;<C_BINDER_MOJO_NEWLINE>		// convergence tolerance  ( relative to range ) <C_BINDER_MOJO_NEWLINE>	}; <C_BINDER_MOJO_NEWLINE>		typedef	struct mjLROpt_mjLROpt	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		//---------------------------------- mjVFS ---------------------------------------------------------	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		struct mjVFS_	{ <C_BINDER_MOJO_NEWLINE>		// virtual file system for loading from memory	void* impl_ ;<C_BINDER_MOJO_NEWLINE>		// internal pointer to VFS memory<C_BINDER_MOJO_NEWLINE>	}; <C_BINDER_MOJO_NEWLINE>		typedef	struct mjVFS_mjVFS	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		//---------------------------------- mjOption ------------------------------------------------------	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		struct mjOption_	{ <C_BINDER_MOJO_NEWLINE>		// physics options	// timing parameters	mjtNum timestep ;<C_BINDER_MOJO_NEWLINE>		// timestep	mjtNum apirate ;<C_BINDER_MOJO_NEWLINE>		// update rate for remote API  ( Hz ) 	// solver parameters	mjtNum impratio ;<C_BINDER_MOJO_NEWLINE>		// ratio of friction-to-normal contact impedance	mjtNum tolerance ;<C_BINDER_MOJO_NEWLINE>		// main solver tolerance	mjtNum ls_tolerance ;<C_BINDER_MOJO_NEWLINE>		// CG/Newton linesearch tolerance	mjtNum noslip_tolerance ;<C_BINDER_MOJO_NEWLINE>		// noslip solver tolerance	mjtNum ccd_tolerance ;<C_BINDER_MOJO_NEWLINE>		// convex collision solver tolerance	// physical constants	mjtNum gravity[3] ;<C_BINDER_MOJO_NEWLINE>		// gravitational acceleration	mjtNum wind[3] ;<C_BINDER_MOJO_NEWLINE>		// wind  ( for lift ,  drag and viscosity ) 	mjtNum magnetic[3] ;<C_BINDER_MOJO_NEWLINE>		// global magnetic flux	mjtNum density ;<C_BINDER_MOJO_NEWLINE>		// density of medium	mjtNum viscosity ;<C_BINDER_MOJO_NEWLINE>		// viscosity of medium	// override contact solver parameters  ( if enabled ) 	mjtNum o_margin ;<C_BINDER_MOJO_NEWLINE>		// margin	mjtNum o_solref[mjNREF] ;<C_BINDER_MOJO_NEWLINE>		// solref	mjtNum o_solimp[mjNIMP] ;<C_BINDER_MOJO_NEWLINE>		// solimp	mjtNum o_friction[5] ;<C_BINDER_MOJO_NEWLINE>		// friction	// discrete settings	int integrator ;<C_BINDER_MOJO_NEWLINE>		// integration mode  ( mjtIntegrator ) 	int cone ;<C_BINDER_MOJO_NEWLINE>		// type of friction cone  ( mjtCone ) 	int jacobian ;<C_BINDER_MOJO_NEWLINE>		// type of Jacobian  ( mjtJacobian ) 	int solver ;<C_BINDER_MOJO_NEWLINE>		// solver algorithm  ( mjtSolver ) 	int iterations ;<C_BINDER_MOJO_NEWLINE>		// maximum number of main solver iterations	int ls_iterations ;<C_BINDER_MOJO_NEWLINE>		// maximum number of CG/Newton linesearch iterations	int noslip_iterations ;<C_BINDER_MOJO_NEWLINE>		// maximum number of noslip solver iterations	int ccd_iterations ;<C_BINDER_MOJO_NEWLINE>		// maximum number of convex collision solver iterations	int disableflags ;<C_BINDER_MOJO_NEWLINE>		// bit flags for disabling standard features	int enableflags ;<C_BINDER_MOJO_NEWLINE>		// bit flags for enabling optional features	int disableactuator ;<C_BINDER_MOJO_NEWLINE>		// bit flags for disabling actuators by group id	// sdf collision settings	int sdf_initpoints ;<C_BINDER_MOJO_NEWLINE>		// number of starting points for gradient descent	int sdf_iterations ;<C_BINDER_MOJO_NEWLINE>		// max number of iterations for gradient descent<C_BINDER_MOJO_NEWLINE>	}; <C_BINDER_MOJO_NEWLINE>		typedef	struct mjOption_mjOption	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		//---------------------------------- mjVisual ------------------------------------------------------	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		struct mjVisual_	{ <C_BINDER_MOJO_NEWLINE>		// visualization options		{ <C_BINDER_MOJO_NEWLINE>		// global parameters	int orthographic ;	// is the free camera orthographic  ( 0: no ,  1: yes ) 	float fovy ;	// y field-of-view of free camera  ( orthographic ? length : degree ) 	float ipd ;	// inter-pupilary distance for free camera	float azimuth ;	// initial azimuth of free camera  ( degrees ) 	float elevation ;	// initial elevation of free camera  ( degrees ) 	float linewidth ;	// line width for wireframe and ray rendering	float glow ;	// glow coefficient for selected body	float realtime ;	// initial real-time factor  ( 1: real time ) 	int   offwidth ;	// width of offscreen buffer	int   offheight ;	// height of offscreen buffer	int   ellipsoidinertia ;	// geom for inertia visualization  ( 0: box ,  1: ellipsoid ) 	int   bvactive ;	// visualize active bounding volumes  ( 0: no ,  1: yes ) <C_BINDER_MOJO_NEWLINE>	}global ; <C_BINDER_MOJO_NEWLINE>			{ <C_BINDER_MOJO_NEWLINE>		// rendering quality	int   shadowsize ;	// size of shadowmap texture	int   offsamples ;	// number of multisamples for offscreen rendering	int   numslices ;	// number of slices for builtin geom drawing	int   numstacks ;	// number of stacks for builtin geom drawing	int   numquads ;	// number of quads for box rendering<C_BINDER_MOJO_NEWLINE>	}quality ; <C_BINDER_MOJO_NEWLINE>			{ <C_BINDER_MOJO_NEWLINE>		// head light	float ambient[3] ;	// ambient rgb  ( alpha = 1 ) 	float diffuse[3] ;	// diffuse rgb  ( alpha = 1 ) 	float specular[3] ;	// specular rgb  ( alpha = 1 ) 	int   active ;	// is headlight active<C_BINDER_MOJO_NEWLINE>	}headlight ; <C_BINDER_MOJO_NEWLINE>			{ <C_BINDER_MOJO_NEWLINE>		// mapping	float stiffness ;	// mouse perturbation stiffness  ( space->force ) 	float stiffnessrot ;	// mouse perturbation stiffness  ( space->torque ) 	float force ;	// from force units to space units	float torque ;	// from torque units to space units	float alpha ;	// scale geom alphas when transparency is enabled	float fogstart ;	// OpenGL fog starts at fogstart * mjModel.stat.extent	float fogend ;	// OpenGL fog ends at fogend * mjModel.stat.extent	float znear ;	// near clipping plane  =  znear * mjModel.stat.extent	float zfar ;	// far clipping plane  =  zfar * mjModel.stat.extent	float haze ;	// haze ratio	float shadowclip ;	// directional light: shadowclip * mjModel.stat.extent	float shadowscale ;	// spot light: shadowscale * light.cutoff	float actuatortendon ;	// scale tendon width<C_BINDER_MOJO_NEWLINE>	}map ; <C_BINDER_MOJO_NEWLINE>			{ <C_BINDER_MOJO_NEWLINE>		// scale of decor elements relative to mean body size	float forcewidth ;	// width of force arrow	float contactwidth ;	// contact width	float contactheight ;	// contact height	float connect ;	// autoconnect capsule width	float com ;	// com radius	float camera ;	// camera object	float light ;	// light object	float selectpoint ;	// selection point	float jointlength ;	// joint length	float jointwidth ;	// joint width	float actuatorlength ;	// actuator length	float actuatorwidth ;	// actuator width	float framelength ;	// bodyframe axis length	float framewidth ;	// bodyframe axis width	float constraint ;	// constraint width	float slidercrank ;	// slidercrank width	float frustum ;	// frustum zfar plane<C_BINDER_MOJO_NEWLINE>	}scale ; <C_BINDER_MOJO_NEWLINE>			{ <C_BINDER_MOJO_NEWLINE>		// color of decor elements	float fog[4] ;	// fog	float haze[4] ;	// haze	float force[4] ;	// external force	float inertia[4] ;	// inertia box	float joint[4] ;	// joint	float actuator[4] ;	// actuator ,  neutral	float actuatornegative[4] ;	// actuator ,  negative limit	float actuatorpositive[4] ;	// actuator ,  positive limit	float com[4] ;	// center of mass	float camera[4] ;	// camera object	float light[4] ;	// light object	float selectpoint[4] ;	// selection point	float connect[4] ;	// auto connect	float contactpoint[4] ;	// contact point	float contactforce[4] ;	// contact force	float contactfriction[4] ;	// contact friction force	float contacttorque[4] ;	// contact torque	float contactgap[4] ;	// contact point in gap	float rangefinder[4] ;	// rangefinder ray	float constraint[4] ;	// constraint	float slidercrank[4] ;	// slidercrank	float crankbroken[4] ;	// used when crank must be stretched/broken	float frustum[4] ;	// camera frustum	float bv[4] ;	// bounding volume	float bvactive[4] ;	// active bounding volume<C_BINDER_MOJO_NEWLINE>	}rgba ; <C_BINDER_MOJO_NEWLINE>	<C_BINDER_MOJO_NEWLINE>	}; <C_BINDER_MOJO_NEWLINE>		typedef	struct mjVisual_mjVisual	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		//---------------------------------- mjStatistic ---------------------------------------------------	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		struct mjStatistic_	{ <C_BINDER_MOJO_NEWLINE>		// model statistics  ( in qpos0 ) 	mjtNum meaninertia ;<C_BINDER_MOJO_NEWLINE>		// mean diagonal inertia	mjtNum meanmass ;<C_BINDER_MOJO_NEWLINE>		// mean body mass	mjtNum meansize ;<C_BINDER_MOJO_NEWLINE>		// mean body size	mjtNum extent ;<C_BINDER_MOJO_NEWLINE>		// spatial extent	mjtNum center[3] ;<C_BINDER_MOJO_NEWLINE>		// center of model<C_BINDER_MOJO_NEWLINE>	}; <C_BINDER_MOJO_NEWLINE>		typedef	struct mjStatistic_mjStatistic	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		//---------------------------------- mjModel -------------------------------------------------------	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>		struct mjModel_	{ <C_BINDER_MOJO_NEWLINE>		// ------------------------------- sizes	// sizes needed at mjModel construction	int nq ;<C_BINDER_MOJO_NEWLINE>		// number of generalized coordinates  =  dim ( qpos ) 	int nv ;<C_BINDER_MOJO_NEWLINE>		// number of degrees of freedom  =  dim ( qvel ) 	int nu ;<C_BINDER_MOJO_NEWLINE>		// number of actuators/controls  =  dim ( ctrl ) 	int na ;<C_BINDER_MOJO_NEWLINE>		// number of activation states  =  dim ( act ) 	int nbody ;<C_BINDER_MOJO_NEWLINE>		// number of bodies	int nbvh ;<C_BINDER_MOJO_NEWLINE>		// number of total bounding volumes in all bodies	int nbvhstatic ;<C_BINDER_MOJO_NEWLINE>		// number of static bounding volumes  ( aabb stored in mjModel ) 	int nbvhdynamic ;<C_BINDER_MOJO_NEWLINE>		// number of dynamic bounding volumes  ( aabb stored in mjData ) 	int njnt ;<C_BINDER_MOJO_NEWLINE>		// number of joints	int ngeom ;<C_BINDER_MOJO_NEWLINE>		// number of geoms	int nsite ;<C_BINDER_MOJO_NEWLINE>		// number of sites	int ncam ;<C_BINDER_MOJO_NEWLINE>		// number of cameras	int nlight ;<C_BINDER_MOJO_NEWLINE>		// number of lights	int nflex ;<C_BINDER_MOJO_NEWLINE>		// number of flexes	int nflexvert ;<C_BINDER_MOJO_NEWLINE>		// number of vertices in all flexes	int nflexedge ;<C_BINDER_MOJO_NEWLINE>		// number of edges in all flexes	int nflexelem ;<C_BINDER_MOJO_NEWLINE>		// number of elements in all flexes	int nflexelemdata ;<C_BINDER_MOJO_NEWLINE>		// number of element vertex ids in all flexes	int nflexelemedge ;<C_BINDER_MOJO_NEWLINE>		// number of element edge ids in all flexes	int nflexshelldata ;<C_BINDER_MOJO_NEWLINE>		// number of shell fragment vertex ids in all flexes	int nflexevpair ;<C_BINDER_MOJO_NEWLINE>		// number of element-vertex pairs in all flexes	int nflextexcoord ;<C_BINDER_MOJO_NEWLINE>		// number of vertices with texture coordinates	int nmesh ;<C_BINDER_MOJO_NEWLINE>		// number of meshes	int nmeshvert ;<C_BINDER_MOJO_NEWLINE>		// number of vertices in all meshes	int nmeshnormal ;<C_BINDER_MOJO_NEWLINE>		// number of normals in all meshes	int nmeshtexcoord ;<C_BINDER_MOJO_NEWLINE>		// number of texcoords in all meshes	int nmeshface ;<C_BINDER_MOJO_NEWLINE>		// number of triangular faces in all meshes	int nmeshgraph ;<C_BINDER_MOJO_NEWLINE>		// number of ints in mesh auxiliary data	int nskin ;<C_BINDER_MOJO_NEWLINE>		// number of skins	int nskinvert ;<C_BINDER_MOJO_NEWLINE>		// number of vertices in all skins	int nskintexvert ;<C_BINDER_MOJO_NEWLINE>		// number of vertiex with texcoords in all skins	int nskinface ;<C_BINDER_MOJO_NEWLINE>		// number of triangular faces in all skins	int nskinbone ;<C_BINDER_MOJO_NEWLINE>		// number of bones in all skins	int nskinbonevert ;<C_BINDER_MOJO_NEWLINE>		// number of vertices in all skin bones	int nhfield ;<C_BINDER_MOJO_NEWLINE>		// number of heightfields	int nhfielddata ;<C_BINDER_MOJO_NEWLINE>		// number of data points in all heightfields	int ntex ;<C_BINDER_MOJO_NEWLINE>		// number of textures	int ntexdata ;<C_BINDER_MOJO_NEWLINE>		// number of bytes in texture rgb data	int nmat ;<C_BINDER_MOJO_NEWLINE>		// number of materials	int npair ;<C_BINDER_MOJO_NEWLINE>		// number of predefined geom pairs	int nexclude ;<C_BINDER_MOJO_NEWLINE>		// number of excluded geom pairs	int neq ;<C_BINDER_MOJO_NEWLINE>		// number of equality constraints	int ntendon ;<C_BINDER_MOJO_NEWLINE>		// number of tendons	int nwrap ;<C_BINDER_MOJO_NEWLINE>		// number of wrap objects in all tendon paths	int nsensor ;<C_BINDER_MOJO_NEWLINE>		// number of sensors	int nnumeric ;<C_BINDER_MOJO_NEWLINE>		// number of numeric custom fields	int nnumericdata ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in all numeric fields	int ntext ;<C_BINDER_MOJO_NEWLINE>		// number of text custom fields	int ntextdata ;<C_BINDER_MOJO_NEWLINE>		// number of mjtBytes in all text fields	int ntuple ;<C_BINDER_MOJO_NEWLINE>		// number of tuple custom fields	int ntupledata ;<C_BINDER_MOJO_NEWLINE>		// number of objects in all tuple fields	int nkey ;<C_BINDER_MOJO_NEWLINE>		// number of keyframes	int nmocap ;<C_BINDER_MOJO_NEWLINE>		// number of mocap bodies	int nplugin ;<C_BINDER_MOJO_NEWLINE>		// number of plugin instances	int npluginattr ;<C_BINDER_MOJO_NEWLINE>		// number of chars in all plugin config attributes	int nuser_body ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in body_user	int nuser_jnt ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in jnt_user	int nuser_geom ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in geom_user	int nuser_site ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in site_user	int nuser_cam ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in cam_user	int nuser_tendon ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in tendon_user	int nuser_actuator ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in actuator_user	int nuser_sensor ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in sensor_user	int nnames ;<C_BINDER_MOJO_NEWLINE>		// number of chars in all names	int nnames_map ;<C_BINDER_MOJO_NEWLINE>		// number of slots in the names hash map	int npaths ;<C_BINDER_MOJO_NEWLINE>		// number of chars in all paths	// sizes set after mjModel construction  ( only affect mjData ) 	int nM ;<C_BINDER_MOJO_NEWLINE>		// number of non-zeros in sparse inertia matrix	int nB ;<C_BINDER_MOJO_NEWLINE>		// number of non-zeros in sparse body-dof matrix	int nC ;<C_BINDER_MOJO_NEWLINE>		// number of non-zeros in sparse reduced dof-dof matrix	int nD ;<C_BINDER_MOJO_NEWLINE>		// number of non-zeros in sparse dof-dof matrix	int ntree ;<C_BINDER_MOJO_NEWLINE>		// number of kinematic trees under world body	int ngravcomp ;<C_BINDER_MOJO_NEWLINE>		// number of bodies with nonzero gravcomp	int nemax ;<C_BINDER_MOJO_NEWLINE>		// number of potential equality-constraint rows	int njmax ;<C_BINDER_MOJO_NEWLINE>		// number of available rows in constraint Jacobian	int nconmax ;<C_BINDER_MOJO_NEWLINE>		// number of potential contacts in contact list	int nuserdata ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums reserved for the user	int nsensordata ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in sensor data vector	int npluginstate ;<C_BINDER_MOJO_NEWLINE>		// number of mjtNums in plugin state vector	size_t narena ;<C_BINDER_MOJO_NEWLINE>		// number of bytes in the mjData arena  ( inclusive of stack ) 	size_t nbuffer ;<C_BINDER_MOJO_NEWLINE>		// number of bytes in buffer	// ------------------------------- options and statistics	mjOption opt ;<C_BINDER_MOJO_NEWLINE>		// physics options	mjVisual vis ;<C_BINDER_MOJO_NEWLINE>		// visualization options	mjStatistic stat ;<C_BINDER_MOJO_NEWLINE>		// model statistics	// ------------------------------- buffers	// main buffer	void*     buffer ;<C_BINDER_MOJO_NEWLINE>		// main buffer ;  all pointers point in it     ( nbuffer ) 	// default generalized coordinates	mjtNum*   qpos0 ;<C_BINDER_MOJO_NEWLINE>		// qpos values at default pose               ( nq x 1 ) 	mjtNum*   qpos_spring ;<C_BINDER_MOJO_NEWLINE>		// reference pose for springs                ( nq x 1 ) 	// bodies	int*      body_parentid ;<C_BINDER_MOJO_NEWLINE>		// id of body's parent                       ( nbody x 1 ) 	int*      body_rootid ;<C_BINDER_MOJO_NEWLINE>		// id of root above body                     ( nbody x 1 ) 	int*      body_weldid ;<C_BINDER_MOJO_NEWLINE>		// id of body that this body is welded to    ( nbody x 1 ) 	int*      body_mocapid ;<C_BINDER_MOJO_NEWLINE>		// id of mocap data ;  -1: none                ( nbody x 1 ) 	int*      body_jntnum ;<C_BINDER_MOJO_NEWLINE>		// number of joints for this body            ( nbody x 1 ) 	int*      body_jntadr ;<C_BINDER_MOJO_NEWLINE>		// start addr of joints ;  -1: no joints       ( nbody x 1 ) 	int*      body_dofnum ;<C_BINDER_MOJO_NEWLINE>		// number of motion degrees of freedom       ( nbody x 1 ) 	int*      body_dofadr ;<C_BINDER_MOJO_NEWLINE>		// start addr of dofs ;  -1: no dofs           ( nbody x 1 ) 	int*      body_treeid ;<C_BINDER_MOJO_NEWLINE>		// id of body's kinematic tree ;  -1: static   ( nbody x 1 ) 	int*      body_geomnum ;<C_BINDER_MOJO_NEWLINE>		// number of geoms                           ( nbody x 1 ) 	int*      body_geomadr ;<C_BINDER_MOJO_NEWLINE>		// start addr of geoms ;  -1: no geoms         ( nbody x 1 ) 	mjtByte*  body_simple ;<C_BINDER_MOJO_NEWLINE>		// 1: diag M ;  2: diag M ,  sliders only        ( nbody x 1 ) 	mjtByte*  body_sameframe ;<C_BINDER_MOJO_NEWLINE>		// same frame as inertia  ( mjtSameframe )       ( nbody x 1 ) 	mjtNum*   body_pos ;<C_BINDER_MOJO_NEWLINE>		// position offset rel. to parent body       ( nbody x 3 ) 	mjtNum*   body_quat ;<C_BINDER_MOJO_NEWLINE>		// orientation offset rel. to parent body    ( nbody x 4 ) 	mjtNum*   body_ipos ;<C_BINDER_MOJO_NEWLINE>		// local position of center of mass          ( nbody x 3 ) 	mjtNum*   body_iquat ;<C_BINDER_MOJO_NEWLINE>		// local orientation of inertia ellipsoid    ( nbody x 4 ) 	mjtNum*   body_mass ;<C_BINDER_MOJO_NEWLINE>		// mass                                      ( nbody x 1 ) 	mjtNum*   body_subtreemass ;<C_BINDER_MOJO_NEWLINE>		// mass of subtree starting at this body     ( nbody x 1 ) 	mjtNum*   body_inertia ;<C_BINDER_MOJO_NEWLINE>		// diagonal inertia in ipos/iquat frame      ( nbody x 3 ) 	mjtNum*   body_invweight0 ;<C_BINDER_MOJO_NEWLINE>		// mean inv inert in qpos0  ( trn ,  rot )         ( nbody x 2 ) 	mjtNum*   body_gravcomp ;<C_BINDER_MOJO_NEWLINE>		// antigravity force ,  units of body weight   ( nbody x 1 ) 	mjtNum*   body_margin ;<C_BINDER_MOJO_NEWLINE>		// MAX over all geom margins                 ( nbody x 1 ) 	mjtNum*   body_user ;<C_BINDER_MOJO_NEWLINE>		// user data                                 ( nbody x nuser_body ) 	int*      body_plugin ;<C_BINDER_MOJO_NEWLINE>		// plugin instance id ;  -1: not in use        ( nbody x 1 ) 	int*      body_contype ;<C_BINDER_MOJO_NEWLINE>		// OR over all geom contypes                 ( nbody x 1 ) 	int*      body_conaffinity ;<C_BINDER_MOJO_NEWLINE>		// OR over all geom conaffinities            ( nbody x 1 ) 	int*      body_bvhadr ;<C_BINDER_MOJO_NEWLINE>		// address of bvh root                       ( nbody x 1 ) 	int*      body_bvhnum ;<C_BINDER_MOJO_NEWLINE>		// number of bounding volumes                ( nbody x 1 ) 	// bounding volume hierarchy	int*      bvh_depth ;<C_BINDER_MOJO_NEWLINE>		// depth in the bounding volume hierarchy    ( nbvh x 1 ) 	int*      bvh_child ;<C_BINDER_MOJO_NEWLINE>		// left and right children in tree           ( nbvh x 2 ) 	int*      bvh_nodeid ;<C_BINDER_MOJO_NEWLINE>		// geom or elem id of node ;  -1: non-leaf     ( nbvh x 1 ) 	mjtNum*   bvh_aabb ;<C_BINDER_MOJO_NEWLINE>		// local bounding box  ( center ,  size )          ( nbvhstatic x 6 ) 	// joints	int*      jnt_type ;<C_BINDER_MOJO_NEWLINE>		// type of joint  ( mjtJoint )                   ( njnt x 1 ) 	int*      jnt_qposadr ;<C_BINDER_MOJO_NEWLINE>		// start addr in 'qpos' for joint's data     ( njnt x 1 ) 	int*      jnt_dofadr ;<C_BINDER_MOJO_NEWLINE>		// start addr in 'qvel' for joint's data     ( njnt x 1 ) 	int*      jnt_bodyid ;<C_BINDER_MOJO_NEWLINE>		// id of joint's body                        ( njnt x 1 ) 	int*      jnt_group ;<C_BINDER_MOJO_NEWLINE>		// group for visibility                      ( njnt x 1 ) 	mjtByte*  jnt_limited ;<C_BINDER_MOJO_NEWLINE>		// does joint have limits                    ( njnt x 1 ) 	mjtByte*  jnt_actfrclimited ;<C_BINDER_MOJO_NEWLINE>		// does joint have actuator force limits     ( njnt x 1 ) 	mjtByte*  jnt_actgravcomp ;<C_BINDER_MOJO_NEWLINE>		// is gravcomp force applied via actuators   ( njnt x 1 ) 	mjtNum*   jnt_solref ;<C_BINDER_MOJO_NEWLINE>		// constraint solver reference: limit        ( njnt x mjNREF ) 	mjtNum*   jnt_solimp ;<C_BINDER_MOJO_NEWLINE>		// constraint solver impedance: limit        ( njnt x mjNIMP ) 	mjtNum*   jnt_pos ;<C_BINDER_MOJO_NEWLINE>		// local anchor position                     ( njnt x 3 ) 	mjtNum*   jnt_axis ;<C_BINDER_MOJO_NEWLINE>		// local joint axis                          ( njnt x 3 ) 	mjtNum*   jnt_stiffness ;<C_BINDER_MOJO_NEWLINE>		// stiffness coefficient                     ( njnt x 1 ) 	mjtNum*   jnt_range ;<C_BINDER_MOJO_NEWLINE>		// joint limits                              ( njnt x 2 ) 	mjtNum*   jnt_actfrcrange ;<C_BINDER_MOJO_NEWLINE>		// range of total actuator force             ( njnt x 2 ) 	mjtNum*   jnt_margin ;<C_BINDER_MOJO_NEWLINE>		// min distance for limit detection          ( njnt x 1 ) 	mjtNum*   jnt_user ;<C_BINDER_MOJO_NEWLINE>		// user data                                 ( njnt x nuser_jnt ) 	// dofs	int*      dof_bodyid ;<C_BINDER_MOJO_NEWLINE>		// id of dof's body                          ( nv x 1 ) 	int*      dof_jntid ;<C_BINDER_MOJO_NEWLINE>		// id of dof's joint                         ( nv x 1 ) 	int*      dof_parentid ;<C_BINDER_MOJO_NEWLINE>		// id of dof's parent ;  -1: none              ( nv x 1 ) 	int*      dof_treeid ;<C_BINDER_MOJO_NEWLINE>		// id of dof's kinematic tree                ( nv x 1 ) 	int*      dof_Madr ;<C_BINDER_MOJO_NEWLINE>		// dof address in M-diagonal                 ( nv x 1 ) 	int*      dof_simplenum ;<C_BINDER_MOJO_NEWLINE>		// number of consecutive simple dofs         ( nv x 1 ) 	mjtNum*   dof_solref ;<C_BINDER_MOJO_NEWLINE>		// constraint solver reference:frictionloss  ( nv x mjNREF ) 	mjtNum*   dof_solimp ;<C_BINDER_MOJO_NEWLINE>		// constraint solver impedance:frictionloss  ( nv x mjNIMP ) 	mjtNum*   dof_frictionloss ;<C_BINDER_MOJO_NEWLINE>		// dof friction loss                         ( nv x 1 ) 	mjtNum*   dof_armature ;<C_BINDER_MOJO_NEWLINE>		// dof armature inertia/mass                 ( nv x 1 ) 	mjtNum*   dof_damping ;<C_BINDER_MOJO_NEWLINE>		// damping coefficient                       ( nv x 1 ) 	mjtNum*   dof_invweight0 ;<C_BINDER_MOJO_NEWLINE>		// diag. inverse inertia in qpos0            ( nv x 1 ) 	mjtNum*   dof_M0 ;<C_BINDER_MOJO_NEWLINE>		// diag. inertia in qpos0                    ( nv x 1 ) 	// geoms	int*      geom_type ;<C_BINDER_MOJO_NEWLINE>		// geometric type  ( mjtGeom )                   ( ngeom x 1 ) 	int*      geom_contype ;<C_BINDER_MOJO_NEWLINE>		// geom contact type                         ( ngeom x 1 ) 	int*      geom_conaffinity ;<C_BINDER_MOJO_NEWLINE>		// geom contact affinity                     ( ngeom x 1 ) 	int*      geom_condim ;<C_BINDER_MOJO_NEWLINE>		// contact dimensionality  ( 1 ,  3 ,  4 ,  6 )        ( ngeom x 1 ) 	int*      geom_bodyid ;<C_BINDER_MOJO_NEWLINE>		// id of geom's body                         ( ngeom x 1 ) 	int*      geom_dataid ;<C_BINDER_MOJO_NEWLINE>		// id of geom's mesh/hfield ;  -1: none        ( ngeom x 1 ) 	int*      geom_matid ;<C_BINDER_MOJO_NEWLINE>		// material id for rendering ;  -1: none       ( ngeom x 1 ) 	int*      geom_group ;<C_BINDER_MOJO_NEWLINE>		// group for visibility                      ( ngeom x 1 ) 	int*      geom_priority ;<C_BINDER_MOJO_NEWLINE>		// geom contact priority                     ( ngeom x 1 ) 	int*      geom_plugin ;<C_BINDER_MOJO_NEWLINE>		// plugin instance id ;  -1: not in use        ( ngeom x 1 ) 	mjtByte*  geom_sameframe ;<C_BINDER_MOJO_NEWLINE>		// same frame as body  ( mjtSameframe )          ( ngeom x 1 ) 	mjtNum*   geom_solmix ;<C_BINDER_MOJO_NEWLINE>		// mixing coef for solref/imp in geom pair   ( ngeom x 1 ) 	mjtNum*   geom_solref ;<C_BINDER_MOJO_NEWLINE>		// constraint solver reference: contact      ( ngeom x mjNREF ) 	mjtNum*   geom_solimp ;<C_BINDER_MOJO_NEWLINE>		// constraint solver impedance: contact      ( ngeom x mjNIMP ) 	mjtNum*   geom_size ;<C_BINDER_MOJO_NEWLINE>		// geom-specific size parameters             ( ngeom x 3 ) 	mjtNum*   geom_aabb ;<C_BINDER_MOJO_NEWLINE>		// bounding box ,   ( center ,  size )               ( ngeom x 6 ) 	mjtNum*   geom_rbound ;<C_BINDER_MOJO_NEWLINE>		// radius of bounding sphere                 ( ngeom x 1 ) 	mjtNum*   geom_pos ;<C_BINDER_MOJO_NEWLINE>		// local position offset rel. to body        ( ngeom x 3 ) 	mjtNum*   geom_quat ;<C_BINDER_MOJO_NEWLINE>		// local orientation offset rel. to body     ( ngeom x 4 ) 	mjtNum*   geom_friction ;<C_BINDER_MOJO_NEWLINE>		// friction for  ( slide ,  spin ,  roll )           ( ngeom x 3 ) 	mjtNum*   geom_margin ;<C_BINDER_MOJO_NEWLINE>		// detect contact if dist<margin             ( ngeom x 1 ) 	mjtNum*   geom_gap ;<C_BINDER_MOJO_NEWLINE>		// include in solver if dist<margin-gap      ( ngeom x 1 ) 	mjtNum*   geom_fluid ;<C_BINDER_MOJO_NEWLINE>		// fluid interaction parameters              ( ngeom x mjNFLUID ) 	mjtNum*   geom_user ;<C_BINDER_MOJO_NEWLINE>		// user data                                 ( ngeom x nuser_geom ) 	float*    geom_rgba ;<C_BINDER_MOJO_NEWLINE>		// rgba when material is omitted             ( ngeom x 4 ) 	// sites	int*      site_type ;<C_BINDER_MOJO_NEWLINE>		// geom type for rendering  ( mjtGeom )          ( nsite x 1 ) 	int*      site_bodyid ;<C_BINDER_MOJO_NEWLINE>		// id of site's body                         ( nsite x 1 ) 	int*      site_matid ;<C_BINDER_MOJO_NEWLINE>		// material id for rendering ;  -1: none       ( nsite x 1 ) 	int*      site_group ;<C_BINDER_MOJO_NEWLINE>		// group for visibility                      ( nsite x 1 ) 	mjtByte*  site_sameframe ;<C_BINDER_MOJO_NEWLINE>		// same frame as body  ( mjtSameframe )          ( nsite x 1 ) 	mjtNum*   site_size ;<C_BINDER_MOJO_NEWLINE>		// geom size for rendering                   ( nsite x 3 ) 	mjtNum*   site_pos ;<C_BINDER_MOJO_NEWLINE>		// local position offset rel. to body        ( nsite x 3 ) 	mjtNum*   site_quat ;<C_BINDER_MOJO_NEWLINE>		// local orientation offset rel. to body     ( nsite x 4 ) 	mjtNum*   site_user ;<C_BINDER_MOJO_NEWLINE>		// user data                                 ( nsite x nuser_site ) 	float*    site_rgba ;<C_BINDER_MOJO_NEWLINE>		// rgba when material is omitted             ( nsite x 4 ) 	// cameras	int*      cam_mode ;<C_BINDER_MOJO_NEWLINE>		// camera tracking mode  ( mjtCamLight )         ( ncam x 1 ) 	int*      cam_bodyid ;<C_BINDER_MOJO_NEWLINE>		// id of camera's body                       ( ncam x 1 ) 	int*      cam_targetbodyid ;<C_BINDER_MOJO_NEWLINE>		// id of targeted body ;  -1: none             ( ncam x 1 ) 	mjtNum*   cam_pos ;<C_BINDER_MOJO_NEWLINE>		// position rel. to body frame               ( ncam x 3 ) 	mjtNum*   cam_quat ;<C_BINDER_MOJO_NEWLINE>		// orientation rel. to body frame            ( ncam x 4 ) 	mjtNum*   cam_poscom0 ;<C_BINDER_MOJO_NEWLINE>		// global position rel. to sub-com in qpos0  ( ncam x 3 ) 	mjtNum*   cam_pos0 ;<C_BINDER_MOJO_NEWLINE>		// global position rel. to body in qpos0     ( ncam x 3 ) 	mjtNum*   cam_mat0 ;<C_BINDER_MOJO_NEWLINE>		// global orientation in qpos0               ( ncam x 9 ) 	int*      cam_orthographic ;<C_BINDER_MOJO_NEWLINE>		// orthographic camera ;  0: no ,  1: yes        ( ncam x 1 ) 	mjtNum*   cam_fovy ;<C_BINDER_MOJO_NEWLINE>		// y field-of-view  ( ortho ? len : deg )        ( ncam x 1 ) 	mjtNum*   cam_ipd ;<C_BINDER_MOJO_NEWLINE>		// inter-pupilary distance                   ( ncam x 1 ) 	int*      cam_resolution ;<C_BINDER_MOJO_NEWLINE>		// resolution: pixels [width ,  height]        ( ncam x 2 ) 	float*    cam_sensorsize ;<C_BINDER_MOJO_NEWLINE>		// sensor size: length [width ,  height]       ( ncam x 2 ) 	float*    cam_intrinsic ;<C_BINDER_MOJO_NEWLINE>		// [focal length ;  principal point]           ( ncam x 4 ) 	mjtNum*   cam_user ;<C_BINDER_MOJO_NEWLINE>		// user data                                 ( ncam x nuser_cam ) 	// lights	int*      light_mode ;<C_BINDER_MOJO_NEWLINE>		// light tracking mode  ( mjtCamLight )          ( nlight x 1 ) 	int*      light_bodyid ;<C_BINDER_MOJO_NEWLINE>		// id of light's body                        ( nlight x 1 ) 	int*      light_targetbodyid ;<C_BINDER_MOJO_NEWLINE>		// id of targeted body ;  -1: none             ( nlight x 1 ) 	mjtByte*  light_directional ;<C_BINDER_MOJO_NEWLINE>		// directional light                         ( nlight x 1 ) 	mjtByte*  light_castshadow ;<C_BINDER_MOJO_NEWLINE>		// does light cast shadows                   ( nlight x 1 ) 	float*    light_bulbradius ;<C_BINDER_MOJO_NEWLINE>		// light radius for soft shadows             ( nlight x 1 ) 	mjtByte*  light_active ;<C_BINDER_MOJO_NEWLINE>		// is light on                               ( nlight x 1 ) 	mjtNum*   light_pos ;<C_BINDER_MOJO_NEWLINE>		// position rel. to body frame               ( nlight x 3 ) 	mjtNum*   light_dir ;<C_BINDER_MOJO_NEWLINE>		// direction rel. to body frame              ( nlight x 3 ) 	mjtNum*   light_poscom0 ;<C_BINDER_MOJO_NEWLINE>		// global position rel. to sub-com in qpos0  ( nlight x 3 ) 	mjtNum*   light_pos0 ;<C_BINDER_MOJO_NEWLINE>		// global position rel. to body in qpos0     ( nlight x 3 ) 	mjtNum*   light_dir0 ;<C_BINDER_MOJO_NEWLINE>		// global direction in qpos0                 ( nlight x 3 ) 	float*    light_attenuation ;<C_BINDER_MOJO_NEWLINE>		// OpenGL attenuation  ( quadratic model )       ( nlight x 3 ) 	float*    light_cutoff ;<C_BINDER_MOJO_NEWLINE>		// OpenGL cutoff                             ( nlight x 1 ) 	float*    light_exponent ;<C_BINDER_MOJO_NEWLINE>		// OpenGL exponent                           ( nlight x 1 ) 	float*    light_ambient ;<C_BINDER_MOJO_NEWLINE>		// ambient rgb  ( alpha = 1 )                      ( nlight x 3 ) 	float*    light_diffuse ;<C_BINDER_MOJO_NEWLINE>		// diffuse rgb  ( alpha = 1 )                      ( nlight x 3 ) 	float*    light_specular ;<C_BINDER_MOJO_NEWLINE>		// specular rgb  ( alpha = 1 )                     ( nlight x 3 ) 	// flexes: contact properties	int*      flex_contype ;<C_BINDER_MOJO_NEWLINE>		// flex contact type                         ( nflex x 1 ) 	int*      flex_conaffinity ;<C_BINDER_MOJO_NEWLINE>		// flex contact affinity                     ( nflex x 1 ) 	int*      flex_condim ;<C_BINDER_MOJO_NEWLINE>		// contact dimensionality  ( 1 ,  3 ,  4 ,  6 )        ( nflex x 1 ) 	int*      flex_priority ;<C_BINDER_MOJO_NEWLINE>		// flex contact priority                     ( nflex x 1 ) 	mjtNum*   flex_solmix ;<C_BINDER_MOJO_NEWLINE>		// mix coef for solref/imp in contact pair   ( nflex x 1 ) 	mjtNum*   flex_solref ;<C_BINDER_MOJO_NEWLINE>		// constraint solver reference: contact      ( nflex x mjNREF ) 	mjtNum*   flex_solimp ;<C_BINDER_MOJO_NEWLINE>		// constraint solver impedance: contact      ( nflex x mjNIMP ) 	mjtNum*   flex_friction ;<C_BINDER_MOJO_NEWLINE>		// friction for  ( slide ,  spin ,  roll )           ( nflex x 3 ) 	mjtNum*   flex_margin ;<C_BINDER_MOJO_NEWLINE>		// detect contact if dist<margin             ( nflex x 1 ) 	mjtNum*   flex_gap ;<C_BINDER_MOJO_NEWLINE>		// include in solver if dist<margin-gap      ( nflex x 1 ) 	mjtByte*  flex_internal ;<C_BINDER_MOJO_NEWLINE>		// internal flex collision enabled           ( nflex x 1 ) 	int*      flex_selfcollide ;<C_BINDER_MOJO_NEWLINE>		// self collision mode  ( mjtFlexSelf )          ( nflex x 1 ) 	int*      flex_activelayers ;<C_BINDER_MOJO_NEWLINE>		// number of active element layers ,  3D only  ( nflex x 1 ) 	// flexes: other properties	int*      flex_dim ;<C_BINDER_MOJO_NEWLINE>		// 1: lines ,  2: triangles ,  3: tetrahedra     ( nflex x 1 ) 	int*      flex_matid ;<C_BINDER_MOJO_NEWLINE>		// material id for rendering                 ( nflex x 1 ) 	int*      flex_group ;<C_BINDER_MOJO_NEWLINE>		// group for visibility                      ( nflex x 1 ) 	int*      flex_vertadr ;<C_BINDER_MOJO_NEWLINE>		// first vertex address                      ( nflex x 1 ) 	int*      flex_vertnum ;<C_BINDER_MOJO_NEWLINE>		// number of vertices                        ( nflex x 1 ) 	int*      flex_edgeadr ;<C_BINDER_MOJO_NEWLINE>		// first edge address                        ( nflex x 1 ) 	int*      flex_edgenum ;<C_BINDER_MOJO_NEWLINE>		// number of edges                           ( nflex x 1 ) 	int*      flex_elemadr ;<C_BINDER_MOJO_NEWLINE>		// first element address                     ( nflex x 1 ) 	int*      flex_elemnum ;<C_BINDER_MOJO_NEWLINE>		// number of elements                        ( nflex x 1 ) 	int*      flex_elemdataadr ;<C_BINDER_MOJO_NEWLINE>		// first element vertex id address           ( nflex x 1 ) 	int*      flex_elemedgeadr ;<C_BINDER_MOJO_NEWLINE>		// first element edge id address             ( nflex x 1 ) 	int*      flex_shellnum ;<C_BINDER_MOJO_NEWLINE>		// number of shells                          ( nflex x 1 ) 	int*      flex_shelldataadr ;<C_BINDER_MOJO_NEWLINE>		// first shell data address                  ( nflex x 1 ) 	int*      flex_evpairadr ;<C_BINDER_MOJO_NEWLINE>		// first evpair address                      ( nflex x 1 ) 	int*      flex_evpairnum ;<C_BINDER_MOJO_NEWLINE>		// number of evpairs                         ( nflex x 1 ) 	int*      flex_texcoordadr ;<C_BINDER_MOJO_NEWLINE>		// address in flex_texcoord ;  -1: none        ( nflex x 1 ) 	int*      flex_vertbodyid ;<C_BINDER_MOJO_NEWLINE>		// vertex body ids                           ( nflexvert x 1 ) 	int*      flex_edge ;<C_BINDER_MOJO_NEWLINE>		// edge vertex ids  ( 2 per edge )               ( nflexedge x 2 ) 	int*      flex_elem ;<C_BINDER_MOJO_NEWLINE>		// element vertex ids  ( dim+1 per elem )        ( nflexelemdata x 1 ) 	int*      flex_elemedge ;<C_BINDER_MOJO_NEWLINE>		// element edge ids                          ( nflexelemedge x 1 ) 	int*      flex_elemlayer ;<C_BINDER_MOJO_NEWLINE>		// element distance from surface ,  3D only    ( nflexelem x 1 ) 	int*      flex_shell ;<C_BINDER_MOJO_NEWLINE>		// shell fragment vertex ids  ( dim per frag )   ( nflexshelldata x 1 ) 	int*      flex_evpair ;<C_BINDER_MOJO_NEWLINE>		//  ( element ,  vertex )  collision pairs         ( nflexevpair x 2 ) 	mjtNum*   flex_vert ;<C_BINDER_MOJO_NEWLINE>		// vertex positions in local body frames     ( nflexvert x 3 ) 	mjtNum*   flex_xvert0 ;<C_BINDER_MOJO_NEWLINE>		// Cartesian vertex positions in qpos0       ( nflexvert x 3 ) 	mjtNum*   flexedge_length0 ;<C_BINDER_MOJO_NEWLINE>		// edge lengths in qpos0                     ( nflexedge x 1 ) 	mjtNum*   flexedge_invweight0 ;<C_BINDER_MOJO_NEWLINE>		// edge inv. weight in qpos0                 ( nflexedge x 1 ) 	mjtNum*   flex_radius ;<C_BINDER_MOJO_NEWLINE>		// radius around primitive element           ( nflex x 1 ) 	mjtNum*   flex_stiffness ;<C_BINDER_MOJO_NEWLINE>		// finite element stiffness matrix           ( nflexelem x 21 ) 	mjtNum*   flex_damping ;<C_BINDER_MOJO_NEWLINE>		// Rayleigh's damping coefficient            ( nflex x 1 ) 	mjtNum*   flex_edgestiffness ;<C_BINDER_MOJO_NEWLINE>		// edge stiffness                            ( nflex x 1 ) 	mjtNum*   flex_edgedamping ;<C_BINDER_MOJO_NEWLINE>		// edge damping                              ( nflex x 1 ) 	mjtByte*  flex_edgeequality ;<C_BINDER_MOJO_NEWLINE>		// is edge equality constraint defined       ( nflex x 1 ) 	mjtByte*  flex_rigid ;<C_BINDER_MOJO_NEWLINE>		// are all verices in the same body          ( nflex x 1 ) 	mjtByte*  flexedge_rigid ;<C_BINDER_MOJO_NEWLINE>		// are both edge vertices in same body       ( nflexedge x 1 ) 	mjtByte*  flex_centered ;<C_BINDER_MOJO_NEWLINE>		// are all vertex coordinates  ( 0 , 0 , 0 )         ( nflex x 1 ) 	mjtByte*  flex_flatskin ;<C_BINDER_MOJO_NEWLINE>		// render flex skin with flat shading        ( nflex x 1 ) 	int*      flex_bvhadr ;<C_BINDER_MOJO_NEWLINE>		// address of bvh root ;  -1: no bvh           ( nflex x 1 ) 	int*      flex_bvhnum ;<C_BINDER_MOJO_NEWLINE>		// number of bounding volumes                ( nflex x 1 ) 	float*    flex_rgba ;<C_BINDER_MOJO_NEWLINE>		// rgba when material is omitted             ( nflex x 4 ) 	float*    flex_texcoord ;<C_BINDER_MOJO_NEWLINE>		// vertex texture coordinates                ( nflextexcoord x 2 ) 	// meshes	int*      mesh_vertadr ;<C_BINDER_MOJO_NEWLINE>		// first vertex address                      ( nmesh x 1 ) 	int*      mesh_vertnum ;<C_BINDER_MOJO_NEWLINE>		// number of vertices                        ( nmesh x 1 ) 	int*      mesh_faceadr ;<C_BINDER_MOJO_NEWLINE>		// first face address                        ( nmesh x 1 ) 	int*      mesh_facenum ;<C_BINDER_MOJO_NEWLINE>		// number of faces                           ( nmesh x 1 ) 	int*      mesh_bvhadr ;<C_BINDER_MOJO_NEWLINE>		// address of bvh root                       ( nmesh x 1 ) 	int*      mesh_bvhnum ;<C_BINDER_MOJO_NEWLINE>		// number of bvh                             ( nmesh x 1 ) 	int*      mesh_normaladr ;<C_BINDER_MOJO_NEWLINE>		// first normal address                      ( nmesh x 1 ) 	int*      mesh_normalnum ;<C_BINDER_MOJO_NEWLINE>		// number of normals                         ( nmesh x 1 ) 	int*      mesh_texcoordadr ;<C_BINDER_MOJO_NEWLINE>		// texcoord data address ;  -1: no texcoord    ( nmesh x 1 ) 	int*      mesh_texcoordnum ;<C_BINDER_MOJO_NEWLINE>		// number of texcoord                        ( nmesh x 1 ) 	int*      mesh_graphadr ;<C_BINDER_MOJO_NEWLINE>		// graph data address ;  -1: no graph          ( nmesh x 1 ) 	float*    mesh_vert ;<C_BINDER_MOJO_NEWLINE>		// vertex positions for all meshes           ( nmeshvert x 3 ) 	float*    mesh_normal ;<C_BINDER_MOJO_NEWLINE>		// normals for all meshes                    ( nmeshnormal x 3 ) 	float*    mesh_texcoord ;<C_BINDER_MOJO_NEWLINE>		// vertex texcoords for all meshes           ( nmeshtexcoord x 2 ) 	int*      mesh_face ;<C_BINDER_MOJO_NEWLINE>		// vertex face data                          ( nmeshface x 3 ) 	int*      mesh_facenormal ;<C_BINDER_MOJO_NEWLINE>		// normal face data                          ( nmeshface x 3 ) 	int*      mesh_facetexcoord ;<C_BINDER_MOJO_NEWLINE>		// texture face data                         ( nmeshface x 3 ) 	int*      mesh_graph ;<C_BINDER_MOJO_NEWLINE>		// convex graph data                         ( nmeshgraph x 1 ) 	mjtNum*   mesh_scale ;<C_BINDER_MOJO_NEWLINE>		// scaling applied to asset vertices         ( nmesh x 3 ) 	mjtNum*   mesh_pos ;<C_BINDER_MOJO_NEWLINE>		// translation applied to asset vertices     ( nmesh x 3 ) 	mjtNum*   mesh_quat ;<C_BINDER_MOJO_NEWLINE>		// rotation applied to asset vertices        ( nmesh x 4 ) 	int*      mesh_pathadr ;<C_BINDER_MOJO_NEWLINE>		// address of asset path for mesh ;  -1: none  ( nmesh x 1 ) 	// skins	int*      skin_matid ;<C_BINDER_MOJO_NEWLINE>		// skin material id ;  -1: none                ( nskin x 1 ) 	int*      skin_group ;<C_BINDER_MOJO_NEWLINE>		// group for visibility                      ( nskin x 1 ) 	float*    skin_rgba ;<C_BINDER_MOJO_NEWLINE>		// skin rgba                                 ( nskin x 4 ) 	float*    skin_inflate ;<C_BINDER_MOJO_NEWLINE>		// inflate skin in normal direction          ( nskin x 1 ) 	int*      skin_vertadr ;<C_BINDER_MOJO_NEWLINE>		// first vertex address                      ( nskin x 1 ) 	int*      skin_vertnum ;<C_BINDER_MOJO_NEWLINE>		// number of vertices                        ( nskin x 1 ) 	int*      skin_texcoordadr ;<C_BINDER_MOJO_NEWLINE>		// texcoord data address ;  -1: no texcoord    ( nskin x 1 ) 	int*      skin_faceadr ;<C_BINDER_MOJO_NEWLINE>		// first face address                        ( nskin x 1 ) 	int*      skin_facenum ;<C_BINDER_MOJO_NEWLINE>		// number of faces                           ( nskin x 1 ) 	int*      skin_boneadr ;<C_BINDER_MOJO_NEWLINE>		// first bone in skin                        ( nskin x 1 ) 	int*      skin_bonenum ;<C_BINDER_MOJO_NEWLINE>		// number of bones in skin                   ( nskin x 1 ) 	float*    skin_vert ;<C_BINDER_MOJO_NEWLINE>		// vertex positions for all skin meshes      ( nskinvert x 3 ) 	float*    skin_texcoord ;<C_BINDER_MOJO_NEWLINE>		// vertex texcoords for all skin meshes      ( nskintexvert x 2 ) 	int*      skin_face ;<C_BINDER_MOJO_NEWLINE>		// triangle faces for all skin meshes        ( nskinface x 3 ) 	int*      skin_bonevertadr ;<C_BINDER_MOJO_NEWLINE>		// first vertex in each bone                 ( nskinbone x 1 ) 	int*      skin_bonevertnum ;<C_BINDER_MOJO_NEWLINE>		// number of vertices in each bone           ( nskinbone x 1 ) 	float*    skin_bonebindpos ;<C_BINDER_MOJO_NEWLINE>		// bind pos of each bone                     ( nskinbone x 3 ) 	float*    skin_bonebindquat ;<C_BINDER_MOJO_NEWLINE>		// bind quat of each bone                    ( nskinbone x 4 ) 	int*      skin_bonebodyid ;<C_BINDER_MOJO_NEWLINE>		// body id of each bone                      ( nskinbone x 1 ) 	int*      skin_bonevertid ;<C_BINDER_MOJO_NEWLINE>		// mesh ids of vertices in each bone         ( nskinbonevert x 1 ) 	float*    skin_bonevertweight ;<C_BINDER_MOJO_NEWLINE>		// weights of vertices in each bone          ( nskinbonevert x 1 ) 	int*      skin_pathadr ;<C_BINDER_MOJO_NEWLINE>		// address of asset path for skin ;  -1: none  ( nskin x 1 ) 	// height fields	mjtNum*   hfield_size ;<C_BINDER_MOJO_NEWLINE>		//  ( x ,  y ,  z_top ,  z_bottom )                    ( nhfield x 4 ) 	int*      hfield_nrow ;<C_BINDER_MOJO_NEWLINE>		// number of rows in grid                    ( nhfield x 1 ) 	int*      hfield_ncol ;<C_BINDER_MOJO_NEWLINE>		// number of columns in grid                 ( nhfield x 1 ) 	int*      hfield_adr ;<C_BINDER_MOJO_NEWLINE>		// address in hfield_data                    ( nhfield x 1 ) 	float*    hfield_data ;<C_BINDER_MOJO_NEWLINE>		// elevation data                            ( nhfielddata x 1 ) 	int*      hfield_pathadr ;<C_BINDER_MOJO_NEWLINE>		// address of hfield asset path ;  -1: none    ( nhfield x 1 ) 	// textures	int*      tex_type ;<C_BINDER_MOJO_NEWLINE>		// texture type  ( mjtTexture )                  ( ntex x 1 ) 	int*      tex_height ;<C_BINDER_MOJO_NEWLINE>		// number of rows in texture image           ( ntex x 1 ) 	int*      tex_width ;<C_BINDER_MOJO_NEWLINE>		// number of columns in texture image        ( ntex x 1 ) 	int*      tex_nchannel ;<C_BINDER_MOJO_NEWLINE>		// number of channels in texture image       ( ntex x 1 ) 	int*      tex_adr ;<C_BINDER_MOJO_NEWLINE>		// start address in tex_data                 ( ntex x 1 ) 	mjtByte*  tex_data ;<C_BINDER_MOJO_NEWLINE>		// pixel values                              ( ntexdata x 1 ) 	int*      tex_pathadr ;<C_BINDER_MOJO_NEWLINE>		// address of texture asset path ;  -1: none   ( ntex x 1 ) 	// materials	int*      mat_texid ;<C_BINDER_MOJO_NEWLINE>		// indices of textures ;  -1: none             ( nmat x mjNTEXROLE ) 	mjtByte*  mat_texuniform ;<C_BINDER_MOJO_NEWLINE>		// make texture cube uniform                 ( nmat x 1 ) 	float*    mat_texrepeat ;<C_BINDER_MOJO_NEWLINE>		// texture repetition for 2d mapping         ( nmat x 2 ) 	float*    mat_emission ;<C_BINDER_MOJO_NEWLINE>		// emission  ( x rgb )                           ( nmat x 1 ) 	float*    mat_specular ;<C_BINDER_MOJO_NEWLINE>		// specular  ( x white )                         ( nmat x 1 ) 	float*    mat_shininess ;<C_BINDER_MOJO_NEWLINE>		// shininess coef                            ( nmat x 1 ) 	float*    mat_reflectance ;<C_BINDER_MOJO_NEWLINE>		// reflectance  ( 0: disable )                   ( nmat x 1 ) 	float*    mat_metallic ;<C_BINDER_MOJO_NEWLINE>		// metallic coef                             ( nmat x 1 ) 	float*    mat_roughness ;<C_BINDER_MOJO_NEWLINE>		// roughness coef                            ( nmat x 1 ) 	float*    mat_rgba ;<C_BINDER_MOJO_NEWLINE>		// rgba                                      ( nmat x 4 ) 	// predefined geom pairs for collision detection ;  has precedence over exclude	int*      pair_dim ;<C_BINDER_MOJO_NEWLINE>		// contact dimensionality                    ( npair x 1 ) 	int*      pair_geom1 ;<C_BINDER_MOJO_NEWLINE>		// id of geom1                               ( npair x 1 ) 	int*      pair_geom2 ;<C_BINDER_MOJO_NEWLINE>		// id of geom2                               ( npair x 1 ) 	int*      pair_signature ;<C_BINDER_MOJO_NEWLINE>		// body1 << 16 + body2                       ( npair x 1 ) 	mjtNum*   pair_solref ;<C_BINDER_MOJO_NEWLINE>		// solver reference: contact normal          ( npair x mjNREF ) 	mjtNum*   pair_solreffriction ;<C_BINDER_MOJO_NEWLINE>		// solver reference: contact friction        ( npair x mjNREF ) 	mjtNum*   pair_solimp ;<C_BINDER_MOJO_NEWLINE>		// solver impedance: contact                 ( npair x mjNIMP ) 	mjtNum*   pair_margin ;<C_BINDER_MOJO_NEWLINE>		// detect contact if dist<margin             ( npair x 1 ) 	mjtNum*   pair_gap ;<C_BINDER_MOJO_NEWLINE>		// include in solver if dist<margin-gap      ( npair x 1 ) 	mjtNum*   pair_friction ;<C_BINDER_MOJO_NEWLINE>		// tangent1 ,  2 ,  spin ,  roll1 ,  2               ( npair x 5 ) 	// excluded body pairs for collision detection	int*      exclude_signature ;<C_BINDER_MOJO_NEWLINE>		// body1 << 16 + body2                       ( nexclude x 1 ) 	// equality constraints	int*      eq_type ;<C_BINDER_MOJO_NEWLINE>		// constraint type  ( mjtEq )                    ( neq x 1 ) 	int*      eq_obj1id ;<C_BINDER_MOJO_NEWLINE>		// id of object 1                            ( neq x 1 ) 	int*      eq_obj2id ;<C_BINDER_MOJO_NEWLINE>		// id of object 2                            ( neq x 1 ) 	int*      eq_objtype ;<C_BINDER_MOJO_NEWLINE>		// type of both objects  ( mjtObj )              ( neq x 1 ) 	mjtByte*  eq_active0 ;<C_BINDER_MOJO_NEWLINE>		// initial enable/disable constraint state   ( neq x 1 ) 	mjtNum*   eq_solref ;<C_BINDER_MOJO_NEWLINE>		// constraint solver reference               ( neq x mjNREF ) 	mjtNum*   eq_solimp ;<C_BINDER_MOJO_NEWLINE>		// constraint solver impedance               ( neq x mjNIMP ) 	mjtNum*   eq_data ;<C_BINDER_MOJO_NEWLINE>		// numeric data for constraint               ( neq x mjNEQDATA ) 	// tendons	int*      tendon_adr ;<C_BINDER_MOJO_NEWLINE>		// address of first object in tendon's path  ( ntendon x 1 ) 	int*      tendon_num ;<C_BINDER_MOJO_NEWLINE>		// number of objects in tendon's path        ( ntendon x 1 ) 	int*      tendon_matid ;<C_BINDER_MOJO_NEWLINE>		// material id for rendering                 ( ntendon x 1 ) 	int*      tendon_group ;<C_BINDER_MOJO_NEWLINE>		// group for visibility                      ( ntendon x 1 ) 	mjtByte*  tendon_limited ;<C_BINDER_MOJO_NEWLINE>		// does tendon have length limits            ( ntendon x 1 ) 	mjtNum*   tendon_width ;<C_BINDER_MOJO_NEWLINE>		// width for rendering                       ( ntendon x 1 ) 	mjtNum*   tendon_solref_lim ;<C_BINDER_MOJO_NEWLINE>		// constraint solver reference: limit        ( ntendon x mjNREF ) 	mjtNum*   tendon_solimp_lim ;<C_BINDER_MOJO_NEWLINE>		// constraint solver impedance: limit        ( ntendon x mjNIMP ) 	mjtNum*   tendon_solref_fri ;<C_BINDER_MOJO_NEWLINE>		// constraint solver reference: friction     ( ntendon x mjNREF ) 	mjtNum*   tendon_solimp_fri ;<C_BINDER_MOJO_NEWLINE>		// constraint solver impedance: friction     ( ntendon x mjNIMP ) 	mjtNum*   tendon_range ;<C_BINDER_MOJO_NEWLINE>		// tendon length limits                      ( ntendon x 2 ) 	mjtNum*   tendon_margin ;<C_BINDER_MOJO_NEWLINE>		// min distance for limit detection          ( ntendon x 1 ) 	mjtNum*   tendon_stiffness ;<C_BINDER_MOJO_NEWLINE>		// stiffness coefficient                     ( ntendon x 1 ) 	mjtNum*   tendon_damping ;<C_BINDER_MOJO_NEWLINE>		// damping coefficient                       ( ntendon x 1 ) 	mjtNum*   tendon_frictionloss ;<C_BINDER_MOJO_NEWLINE>		// loss due to friction                      ( ntendon x 1 ) 	mjtNum*   tendon_lengthspring ;<C_BINDER_MOJO_NEWLINE>		// spring resting length range               ( ntendon x 2 ) 	mjtNum*   tendon_length0 ;<C_BINDER_MOJO_NEWLINE>		// tendon length in qpos0                    ( ntendon x 1 ) 	mjtNum*   tendon_invweight0 ;<C_BINDER_MOJO_NEWLINE>		// inv. weight in qpos0                      ( ntendon x 1 ) 	mjtNum*   tendon_user ;<C_BINDER_MOJO_NEWLINE>		// user data                                 ( ntendon x nuser_tendon ) 	float*    tendon_rgba ;<C_BINDER_MOJO_NEWLINE>		// rgba when material is omitted             ( ntendon x 4 ) 	// list of all wrap objects in tendon paths	int*      wrap_type ;<C_BINDER_MOJO_NEWLINE>		// wrap object type  ( mjtWrap )                 ( nwrap x 1 ) 	int*      wrap_objid ;<C_BINDER_MOJO_NEWLINE>		// object id: geom ,  site ,  joint              ( nwrap x 1 ) 	mjtNum*   wrap_prm ;<C_BINDER_MOJO_NEWLINE>		// divisor ,  joint coef ,  or site id           ( nwrap x 1 ) 	// actuators	int*      actuator_trntype ;<C_BINDER_MOJO_NEWLINE>		// transmission type  ( mjtTrn )                 ( nu x 1 ) 	int*      actuator_dyntype ;<C_BINDER_MOJO_NEWLINE>		// dynamics type  ( mjtDyn )                     ( nu x 1 ) 	int*      actuator_gaintype ;<C_BINDER_MOJO_NEWLINE>		// gain type  ( mjtGain )                        ( nu x 1 ) 	int*      actuator_biastype ;<C_BINDER_MOJO_NEWLINE>		// bias type  ( mjtBias )                        ( nu x 1 ) 	int*      actuator_trnid ;<C_BINDER_MOJO_NEWLINE>		// transmission id: joint ,  tendon ,  site      ( nu x 2 ) 	int*      actuator_actadr ;<C_BINDER_MOJO_NEWLINE>		// first activation address ;  -1: stateless   ( nu x 1 ) 	int*      actuator_actnum ;<C_BINDER_MOJO_NEWLINE>		// number of activation variables            ( nu x 1 ) 	int*      actuator_group ;<C_BINDER_MOJO_NEWLINE>		// group for visibility                      ( nu x 1 ) 	mjtByte*  actuator_ctrllimited ;<C_BINDER_MOJO_NEWLINE>		// is control limited                        ( nu x 1 ) 	mjtByte*  actuator_forcelimited ;<C_BINDER_MOJO_NEWLINE>		// is force limited                          ( nu x 1 ) 	mjtByte*  actuator_actlimited ;<C_BINDER_MOJO_NEWLINE>		// is activation limited                     ( nu x 1 ) 	mjtNum*   actuator_dynprm ;<C_BINDER_MOJO_NEWLINE>		// dynamics parameters                       ( nu x mjNDYN ) 	mjtNum*   actuator_gainprm ;<C_BINDER_MOJO_NEWLINE>		// gain parameters                           ( nu x mjNGAIN ) 	mjtNum*   actuator_biasprm ;<C_BINDER_MOJO_NEWLINE>		// bias parameters                           ( nu x mjNBIAS ) 	mjtByte*  actuator_actearly ;<C_BINDER_MOJO_NEWLINE>		// step activation before force              ( nu x 1 ) 	mjtNum*   actuator_ctrlrange ;<C_BINDER_MOJO_NEWLINE>		// range of controls                         ( nu x 2 ) 	mjtNum*   actuator_forcerange ;<C_BINDER_MOJO_NEWLINE>		// range of forces                           ( nu x 2 ) 	mjtNum*   actuator_actrange ;<C_BINDER_MOJO_NEWLINE>		// range of activations                      ( nu x 2 ) 	mjtNum*   actuator_gear ;<C_BINDER_MOJO_NEWLINE>		// scale length and transmitted force        ( nu x 6 ) 	mjtNum*   actuator_cranklength ;<C_BINDER_MOJO_NEWLINE>		// crank length for slider-crank             ( nu x 1 ) 	mjtNum*   actuator_acc0 ;<C_BINDER_MOJO_NEWLINE>		// acceleration from unit force in qpos0     ( nu x 1 ) 	mjtNum*   actuator_length0 ;<C_BINDER_MOJO_NEWLINE>		// actuator length in qpos0                  ( nu x 1 ) 	mjtNum*   actuator_lengthrange ;<C_BINDER_MOJO_NEWLINE>		// feasible actuator length range            ( nu x 2 ) 	mjtNum*   actuator_user ;<C_BINDER_MOJO_NEWLINE>		// user data                                 ( nu x nuser_actuator ) 	int*      actuator_plugin ;<C_BINDER_MOJO_NEWLINE>		// plugin instance id ;  -1: not a plugin      ( nu x 1 ) 	// sensors	int*      sensor_type ;<C_BINDER_MOJO_NEWLINE>		// sensor type  ( mjtSensor )                    ( nsensor x 1 ) 	int*      sensor_datatype ;<C_BINDER_MOJO_NEWLINE>		// numeric data type  ( mjtDataType )            ( nsensor x 1 ) 	int*      sensor_needstage ;<C_BINDER_MOJO_NEWLINE>		// required compute stage  ( mjtStage )          ( nsensor x 1 ) 	int*      sensor_objtype ;<C_BINDER_MOJO_NEWLINE>		// type of sensorized object  ( mjtObj )         ( nsensor x 1 ) 	int*      sensor_objid ;<C_BINDER_MOJO_NEWLINE>		// id of sensorized object                   ( nsensor x 1 ) 	int*      sensor_reftype ;<C_BINDER_MOJO_NEWLINE>		// type of reference frame  ( mjtObj )           ( nsensor x 1 ) 	int*      sensor_refid ;<C_BINDER_MOJO_NEWLINE>		// id of reference frame ;  -1: global frame   ( nsensor x 1 ) 	int*      sensor_dim ;<C_BINDER_MOJO_NEWLINE>		// number of scalar outputs                  ( nsensor x 1 ) 	int*      sensor_adr ;<C_BINDER_MOJO_NEWLINE>		// address in sensor array                   ( nsensor x 1 ) 	mjtNum*   sensor_cutoff ;<C_BINDER_MOJO_NEWLINE>		// cutoff for real and positive ;  0: ignore   ( nsensor x 1 ) 	mjtNum*   sensor_noise ;<C_BINDER_MOJO_NEWLINE>		// noise standard deviation                  ( nsensor x 1 ) 	mjtNum*   sensor_user ;<C_BINDER_MOJO_NEWLINE>		// user data                                 ( nsensor x nuser_sensor ) 	int*      sensor_plugin ;<C_BINDER_MOJO_NEWLINE>		// plugin instance id ;  -1: not a plugin      ( nsensor x 1 ) 	// plugin instances	int*      plugin ;<C_BINDER_MOJO_NEWLINE>		// globally registered plugin slot number    ( nplugin x 1 ) 	int*      plugin_stateadr ;<C_BINDER_MOJO_NEWLINE>		// address in the plugin state array         ( nplugin x 1 ) 	int*      plugin_statenum ;<C_BINDER_MOJO_NEWLINE>		// number of states in the plugin instance   ( nplugin x 1 ) 	char*     plugin_attr ;<C_BINDER_MOJO_NEWLINE>		// config attributes of plugin instances     ( npluginattr x 1 ) 	int*      plugin_attradr ;<C_BINDER_MOJO_NEWLINE>		// address to each instance's config attrib  ( nplugin x 1 ) 	// custom numeric fields	int*      numeric_adr ;<C_BINDER_MOJO_NEWLINE>		// address of field in numeric_data          ( nnumeric x 1 ) 	int*      numeric_size ;<C_BINDER_MOJO_NEWLINE>		// size of numeric field                     ( nnumeric x 1 ) 	mjtNum*   numeric_data ;<C_BINDER_MOJO_NEWLINE>		// array of all numeric fields               ( nnumericdata x 1 ) 	// custom text fields	int*      text_adr ;<C_BINDER_MOJO_NEWLINE>		// address of text in text_data              ( ntext x 1 ) 	int*      text_size ;<C_BINDER_MOJO_NEWLINE>		// size of text field  ( strlen+1 )              ( ntext x 1 ) 	char*     text_data ;<C_BINDER_MOJO_NEWLINE>		// array of all text fields  ( 0-terminated )    ( ntextdata x 1 ) 	// custom tuple fields	int*      tuple_adr ;<C_BINDER_MOJO_NEWLINE>		// address of text in text_data              ( ntuple x 1 ) 	int*      tuple_size ;<C_BINDER_MOJO_NEWLINE>		// number of objects in tuple                ( ntuple x 1 ) 	int*      tuple_objtype ;<C_BINDER_MOJO_NEWLINE>		// array of object types in all tuples       ( ntupledata x 1 ) 	int*      tuple_objid ;<C_BINDER_MOJO_NEWLINE>		// array of object ids in all tuples         ( ntupledata x 1 ) 	mjtNum*   tuple_objprm ;<C_BINDER_MOJO_NEWLINE>		// array of object params in all tuples      ( ntupledata x 1 ) 	// keyframes	mjtNum*   key_time ;<C_BINDER_MOJO_NEWLINE>		// key time                                  ( nkey x 1 ) 	mjtNum*   key_qpos ;<C_BINDER_MOJO_NEWLINE>		// key position                              ( nkey x nq ) 	mjtNum*   key_qvel ;<C_BINDER_MOJO_NEWLINE>		// key velocity                              ( nkey x nv ) 	mjtNum*   key_act ;<C_BINDER_MOJO_NEWLINE>		// key activation                            ( nkey x na ) 	mjtNum*   key_mpos ;<C_BINDER_MOJO_NEWLINE>		// key mocap position                        ( nkey x nmocap*3 ) 	mjtNum*   key_mquat ;<C_BINDER_MOJO_NEWLINE>		// key mocap quaternion                      ( nkey x nmocap*4 ) 	mjtNum*   key_ctrl ;<C_BINDER_MOJO_NEWLINE>		// key control                               ( nkey x nu ) 	// names	int*      name_bodyadr ;<C_BINDER_MOJO_NEWLINE>		// body name pointers                        ( nbody x 1 ) 	int*      name_jntadr ;<C_BINDER_MOJO_NEWLINE>		// joint name pointers                       ( njnt x 1 ) 	int*      name_geomadr ;<C_BINDER_MOJO_NEWLINE>		// geom name pointers                        ( ngeom x 1 ) 	int*      name_siteadr ;<C_BINDER_MOJO_NEWLINE>		// site name pointers                        ( nsite x 1 ) 	int*      name_camadr ;<C_BINDER_MOJO_NEWLINE>		// camera name pointers                      ( ncam x 1 ) 	int*      name_lightadr ;<C_BINDER_MOJO_NEWLINE>		// light name pointers                       ( nlight x 1 ) 	int*      name_flexadr ;<C_BINDER_MOJO_NEWLINE>		// flex name pointers                        ( nflex x 1 ) 	int*      name_meshadr ;<C_BINDER_MOJO_NEWLINE>		// mesh name pointers                        ( nmesh x 1 ) 	int*      name_skinadr ;<C_BINDER_MOJO_NEWLINE>		// skin name pointers                        ( nskin x 1 ) 	int*      name_hfieldadr ;<C_BINDER_MOJO_NEWLINE>		// hfield name pointers                      ( nhfield x 1 ) 	int*      name_texadr ;<C_BINDER_MOJO_NEWLINE>		// texture name pointers                     ( ntex x 1 ) 	int*      name_matadr ;<C_BINDER_MOJO_NEWLINE>		// material name pointers                    ( nmat x 1 ) 	int*      name_pairadr ;<C_BINDER_MOJO_NEWLINE>		// geom pair name pointers                   ( npair x 1 ) 	int*      name_excludeadr ;<C_BINDER_MOJO_NEWLINE>		// exclude name pointers                     ( nexclude x 1 ) 	int*      name_eqadr ;<C_BINDER_MOJO_NEWLINE>		// equality constraint name pointers         ( neq x 1 ) 	int*      name_tendonadr ;<C_BINDER_MOJO_NEWLINE>		// tendon name pointers                      ( ntendon x 1 ) 	int*      name_actuatoradr ;<C_BINDER_MOJO_NEWLINE>		// actuator name pointers                    ( nu x 1 ) 	int*      name_sensoradr ;<C_BINDER_MOJO_NEWLINE>		// sensor name pointers                      ( nsensor x 1 ) 	int*      name_numericadr ;<C_BINDER_MOJO_NEWLINE>		// numeric name pointers                     ( nnumeric x 1 ) 	int*      name_textadr ;<C_BINDER_MOJO_NEWLINE>		// text name pointers                        ( ntext x 1 ) 	int*      name_tupleadr ;<C_BINDER_MOJO_NEWLINE>		// tuple name pointers                       ( ntuple x 1 ) 	int*      name_keyadr ;<C_BINDER_MOJO_NEWLINE>		// keyframe name pointers                    ( nkey x 1 ) 	int*      name_pluginadr ;<C_BINDER_MOJO_NEWLINE>		// plugin instance name pointers             ( nplugin x 1 ) 	char*     names ;<C_BINDER_MOJO_NEWLINE>		// names of all objects ,  0-terminated        ( nnames x 1 ) 	int*      names_map ;<C_BINDER_MOJO_NEWLINE>		// internal hash map of names                ( nnames_map x 1 ) 	// paths	char*     paths ;<C_BINDER_MOJO_NEWLINE>		// paths to assets ,  0-terminated             ( npaths x 1 ) <C_BINDER_MOJO_NEWLINE>	}; <C_BINDER_MOJO_NEWLINE>		typedef	struct mjModel_mjModel	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	#endif		// MUJOCO_MJMODEL_H_	<C_BINDER_MOJO_NEWLINE>	 <C_BINDER_MOJO_NEWLINE>	